<!DOCTYPE html><meta charset='UTF-8'><html><head><title> A Universe of Sorts </title><style>@font-face {font-family: 'Blog Mono'; src: url('/static/iosevka-fixed-extendedmedium.ttf');}@font-face {font-family: 'Blog Text'; src: url('/static/iosevka-etoile-regular.ttf');}html { font-size: 100%; }html,body { text-size-adjust: none; -webkit-text-size-adjust: none; -moz-text-size-adjust: none; -ms-text-size-adjust: none; } body { background-color: #FFFFFF; color: #000000;  font-family: 'Blog Text', monospace; font-size: 20px; line-height: 1.3em;  max-width: 100%; }
img { display:block; }.container { margin-left: 20%; margin-right: 10%; }.image { }
a:hover { color: #1a73e8; text-decoration: underline;  }
a { color: #1a73e8; text-decoration: none; }
a:visited { color: #1a73e8; text-decoration: none; }
a:active { color: #1a73e8; text-decoration: none; }

pre, .latexblock, blockquote { border-left-color:#000000;  border-left-style: solid;      border-left-width: 4px; padding-left: 5px; }
 blockquote { color: #222222; margin: 0px; }.latexblock, .latexinline, .code { font-family: 'Blog Mono', monospace; line-height: 1.2em; font-size: 80%;  }.latexblock, blockquote, .code, code { margin-top: 30px; margin-bottom: 30px; padding-bottom: 5px; padding-top: 5px; background-color: #FFFFFF; }.code, code { background-color: #FFFFFF; width: 100%; } .latexblock {  width: 100%; overflow-x: auto; white-space: nowrap; } .code pre { width: 100%; overflow-x: auto; margin: 0px; overflow-y: hidden; padding-top: 5px; padding-bottom: 5px; }
.latexinline { border-bottom-color: #000000; border-bottom-style: solid;                border-bottom-width: 1px; padding-bottom: 2px;                padding-left: 2px; padding-right: 2px; }pre, code, kbd, samp, tt{ font-family:'Blog Mono',monospace; }.latexblock .li-itemize{margin:1ex 0ex;}.latexblock .li-enumerate{margin:1ex 0ex;}.latexblock .footnotetext{margin:0ex; padding:0ex;}.latexblock div.footnotetext P{margin:0px; text-indent:1em;}.latexblock .thefootnotes{text-align:left;margin:0ex;}.latexblock .dt-thefootnotes{margin:0em;}.latexblock .dd-thefootnotes{margin:0em 0em 0em 2em;}.latexblock .footnoterule{margin:1em auto 1em 0px;width:50%;}.latexblock .caption{padding-left:2ex; padding-right:2ex; margin-left:auto; margin-right:auto}.latexblock .title{margin:2ex auto;text-align:center}.latexblock .titlemain{margin:1ex 2ex 2ex 1ex;}.latexblock .center{text-align:center;margin-left:auto;margin-right:auto;}.latexblock .flushleft{text-align:left;margin-left:0ex;margin-right:auto;}.latexblock .flushright{text-align:right;margin-left:auto;margin-right:0ex;}.latexblock div table{margin-left:inherit;margin-right:inherit;margin-bottom:2px;margin-top:2px}.latexblock td table{margin:auto;}.latexblock table{border-collapse:collapse;}.latexblock td{padding:0;}.latexblock .cellpadding0 tr td{padding:0;}.latexblock .cellpadding1 tr td{padding:1px;}.latexblock pre{text-align:left;margin-left:0ex;margin-right:auto;}.latexblock blockquote{margin-left:4ex;margin-right:4ex;text-align:left;}.latexblock td p{margin:0px;}.latexblock .hbar{border:none;height:2px;width:100%;background-color:black;}.latexblock .display{border-collapse:separate;border-spacing:2px;width:auto; border:none;}.latexblock .dcell{white-space:nowrap;padding:0px; border:none;}.latexblock .dcenter{margin:0ex auto;}.latexblock .theorem{text-align:left;margin:1ex auto 1ex 0ex;}.latexblock .tst{font-family:sans;font-style:oblique;color:maroon}.latexblock .highlight{color:lime}</style></head><body><div class='container'>

<h3><a id=a-universe-of-sorts href='#a-universe-of-sorts'> § </a> A Universe of Sorts</h3>
<h4><a id=siddharth-bhat href='#siddharth-bhat'> § </a> Siddharth Bhat</h4>
<ul>
<li>
 <a href=https://www.admonymous.co/bollu>
Leave feedback for me, <code>+ve</code> or <code>-ve</code>!</a>

</li>
<li>
 <a href=http://github.com/bollu>
My github</a>

</li>
<li>
 <a href=https://math.stackexchange.com/users/261373/siddharth-bhat>
My math.se profile</a>

</li>
<li>
 <a href=resume/main.pdf>
My resume</a>

</li>
<li>
 <a href=todo.html>
My reading list</a>

</li>
<li>
 email ID: rot13(<code>fvqqh.qehvq@tznvy.pbz</code>)
</li>

</ul>

<h4><a id=table-of-contents href='#table-of-contents'> § </a> Table of contents:</h4>
	
<ul>
<li>
 <a href=#lyndon-christoffel-convex-hull>
Lyndon + Christoffel = Convex Hull</a>

</li>
<li>
 <a href=#1-x-e-xof-of->
Geometric proof of <code>e^x >= 1+x</code>, <code>e^(-x) <= 1-x</code></a>

</li>
<li>
 <a href=#ranking-and-sorting>
Ranking and Sorting</a>

</li>
<li>
 <a href=#proof-of-minkowski-convex-body-theorem>
Proof of minkowski convex body theorem</a>

</li>
<li>
 <a href=#burrows-wheeler>
Burrows Wheeler (WIP)</a>

</li>
<li>
 <a href=#intuitionstic-logic-as-a-heytig-algebra>
Intuitionstic logic as a Heytig algebra</a>

</li>
<li>
 <a href=#edit-distance>
Edit distance</a>

</li>
<li>
 <a href=#evolution-of-bee-colonies>
Evolution of bee colonies</a>

</li>
<li>
 <a href=#best-practices-for-array-indexing>
Best practices for array indexing</a>

</li>
<li>
 <a href=#algebraic-structure-for-vector-clocks>
Algebraic structure for vector clocks</a>

</li>
<li>
 <a href=#networks-are-now-faster-than-disks>
Networks are now faster than disks</a>

</li>
<li>
 <a href=#einstein-de-haas-effect>
Einstein-de Haas effect</a>

</li>
<li>
 <a href=#rank-select-as-adjunction>
Rank-select as adjunction</a>

</li>
<li>
 <a href=#bounding-chains-uniformly-sample-colorings>
Bounding chains: uniformly sample colorings</a>

</li>
<li>
 <a href=#coupling-from-the-past>
Coupling from the past (WIP)</a>

</li>
<li>
 <a href=#word-problems-in-russia-and-america>
Word problems in Russia and America</a>

</li>
<li>
 <a href=#encoding-mathematical-hieararchies>
Encoding mathematical hieararchies</a>

</li>
<li>
 <a href=#learning-code-by-hearing-it>
Learning code by hearing it</a>

</li>
<li>
 <a href=#your-arm-can-be-a-spinor>
Your arm can be a spinor</a>

</li>
<li>
 <a href=#self-modifying-code-for-function-calls-look-ma-i-dont-need-a-stack>
Self modifying code for function calls</a>

</li>
<li>
 <a href=#adjunctions-as-advice>
Adjunctions as advice</a>

</li>
<li>
 <a href=#reversible-computation-as-groups-on-programs>
Reversible computation as groups on programs</a>

</li>
<li>
 <a href=#blazing-fast-math-rendering-on-the-web>
Blazing fast math rendering on the web</a>

</li>
<li>
 <a href=#vc-dimension>
VC dimension</a>

</li>
<li>
 <a href=#symplectic-version-of-classical-mechanics>
Symplectic version of classical mechanics (WIP)</a>

</li>
<li>
 <a href=#theorems-for-free>
Theorems for free</a>

</li>
<li>
 <a href=#how-to-reason-with-half-open-intervals>
How to reason with half-open intervals</a>

</li>
<li>
 <a href=#how-does-one-build-a-fusion-bomb>
how does one build a fusion bomb?</a>

</li>
<li>
 <a href=#christoffel-symbols-geometrically>
Christoffel symbols, geometrically</a>

</li>
<li>
 <a href=#a-natural-vector-space-without-an-explicit-basis>
A natural vector space without an explicit basis</a>

</li>
<li>
 <a href=#cache-oblivious-b-trees>
Cache oblivious B trees</a>

</li>
<li>
 <a href=#krohn-rhodes-decomposition>
Krohn-Rhodes decomposition (WIP)</a>

</li>
<li>
 <a href=#proving-block-matmul-using-program-analysis>
Proving block matmul using program analysis (WIP)</a>

</li>
<li>
 <a href=#why-i-like-algebra-over-analysis>
Why I like algebra over analysis</a>

</li>
<li>
 <a href=#using-for-cleaner-function-type-typedefs>
<code>using</code> for cleaner function type typedefs</a>

</li>
<li>
 <a href=#a-walkway-of-laterns>
A walkway of lanterns (WIP)</a>

</li>
<li>
 <a href=#natural-transformations>
Natural transformations</a>

</li>
<li>
 <a href=#the-hilarious-commentary-by-dinosaure-in-ocaml-git>
The hilarious commentary by dinosaure in OCaml git</a>

</li>
<li>
 <a href=#how-to-link-against-mlir-with-cmake>
How to link against MLIR with CMake</a>

</li>
<li>
 <a href=#energy-as-triangulaizing-state-space>
Energy as triangulaizing state space</a>

</li>
<li>
 <a href=#the-cutest-way-to-write-semidirect-products>
The cutest way to write semidirect products</a>

</li>
<li>
 <a href=#my-favourite-aplisms>
My Favourite APLisms</a>

</li>
<li>
 <a href=#proof-of-chinese-remainder-theorem-on-rings>
Proof of chinese remainder theorem on rings (WIP)</a>

</li>
<li>
 <a href=#monic-and-epic-arrows>
monic and epic arrows</a>

</li>
<li>
 <a href=#the-geometry-of-lagrange-multipliers>
The geometry of Lagrange multipliers</a>

</li>
<li>
 <a href=#efficient-tree-transformations-on-gpus>
Efficient tree transformations on GPUs (WIP)</a>

</li>
<li>
 <a href=#things-i-wish-i-knew-when-i-was-learning-apl>
Things I wish I knew when I was learning APL</a>

</li>
<li>
 <a href=#every-ideal-that-is-maximal-wrt-being-disjoint-from-a-multiplicative-subset-is-prime>
Every ideal that is maximal wrt. being disjoint from a multiplicative subset is prime</a>

</li>
<li>
 <a href=#getting-started-with-apl>
Getting started with APL</a>

</li>
<li>
 <a href=#spacechem-was-the-best-compiler-i-ever-used>
SpaceChem was the best compiler I ever used</a>

</li>
<li>
 <a href=#mnemonic-for-kruskal-and-prim>
Mnemonic for Kruskal and Prim</a>

</li>
<li>
 <a href=#legendre-transform>
Legendre transform</a>

</li>
<li>
 <a href=#cartesian-trees>
Cartesian Trees</a>

</li>
<li>
 <a href=#dfs-numbers-as-a-monotone-map>
DFS numbers as a monotone map</a>

</li>
<li>
 <a href=#self-attention-not-really>
Self attention? not really</a>

</li>
<li>
 <a href=#coarse-structures>
Coarse structures</a>

</li>
<li>
 <a href=#matroids-for-greedy-algorithms>
Matroids for greedy algorithms (WIP)</a>

</li>
<li>
 <a href=#grokking-zariski>
Grokking Zariski (WIP)</a>

</li>
<li>
 <a href=#my-preferred-version-of-quicksort>
My preferred version of quicksort</a>

</li>
<li>
 <a href=#geometric-proof-of-cauchy-schwarz-inequality>
Geometric proof of Cauchy Schwarz inequality</a>

</li>
<li>
 <a href=#dataflow-analysis-using-grobner-basis>
Dataflow analysis using Grobner basis</a>

</li>
<li>
 <a href=#fenwick-trees-and-orbits>
Fenwick trees and orbits</a>

</li>
<li>
 <a href=#dirichlet-inversion>
Dirichlet inversion (WIP)</a>

</li>
<li>
 <a href=#incunabulum-for-the-21st-century-making-the-j-interpreter-compile-in-2020>
Incunabulum for the 21st century: Making the J interpreter compile in 2020</a>

</li>
<li>
 <a href=#an-example-of-a-sequence-whose-successive-terms-get-closer-together-but-isnt-cauchy-does-not-converge>
An example of a sequence whose successive terms get closer together but isn't Cauchy (does not converge)</a>

</li>
<li>
 <a href=#krylov-subspace-method>
Krylov subspace method</a>

</li>
<li>
 <a href=#good-reference-to-the-rete-pattern-matching-algorithm>
Good reference to the Rete pattern matching algorithm</a>

</li>
<li>
 <a href=#leapfrog-integration>
Leapfrog Integration</a>

</li>
<li>
 <a href=#comparison-of-forward-and-reverse-mode-ad>
Comparison of forward and reverse mode automatic differentiation</a>

</li>
<li>
 <a href=#an-invitation-to-homology-and-cohomology-part-1--homology>
An invitation to homology and cohomology: Part 1 --- Homology</a>

</li>
<li>
 <a href=#an-invitation-to-homology-and-cohomology-part-2--cohomology>
An invitation to homology and cohomology: Part 2 --- Cohomology</a>

</li>
<li>
 <a href=#stuff-i-learnt-in-2019>
Stuff I learnt in 2019</a>

</li>
<li>
 <a href=#a-motivation-for-p-adic-analysis>
A motivation for p-adic analysis</a>

</li>
<li>
 <a href=#line-of-investigation-to-build-physical-intuition-for-semidirect-products>
Line of investigation to build physical intuition for semidirect products</a>

</li>
<li>
 <a href=#topology-is-really-about-computation--part-2>
Topology is really about computation --- part 2</a>

</li>
<li>
 <a href=#topology-is-really-about-computation--part-1>
Topology is really about computation --- part 1</a>

</li>
<li>
 <a href=#pslq-algorithm-finding-integer-relations-between-reals>
PSLQ algorithm: finding integer relations between reals</a>

</li>
<li>
 <a href=#geometric-characterization-of-normal-subgroups>
Geometric characterization of normal subgroups</a>

</li>
<li>
 <a href=#radical-ideals-nilpotents-and-reduced-rings>
Radical ideals, nilpotents, and reduced rings</a>

</li>
<li>
 <a href=#my-disenchantment-with-abstract-interpretation>
My disenchantment with abstract interpretation</a>

</li>
<li>
 <a href=#computing-equivalent-gate-sets-using-grobner-bases>
Computing equivalent gate sets using grobner bases</a>

</li>
<li>
 <a href=#the-janus-programming-language--time-reversible-computation>
The janus programming language --- Time reversible computation</a>

</li>
<li>
 <a href=#a--b--a-book-about-proofs-of-combinatorial-closed-forms>
<code>A = B</code> --- A book about proofs of combinatorial closed forms (TODO link)</a>

</li>
<li>
 <a href=#generating-k-bitsets-of-a-given-length-n>
Generating <code>k</code> bitsets of a given length <code>n</code></a>

</li>
<li>
 <a href=#bondi-k-calculus>
Bondi k-calculus</a>

</li>
<li>
 <a href=#vivado-toolchain-craziness>
Vivado toolchain craziness </a>

</li>
<li>
 <a href=#what-the-hell-is-a-grobner-basis-ideals-as-rewrite-systems>
What the hell <i>is</i> a Grobner basis? Ideals as rewrite systems</a>

</li>
<li>
 <a href=#lie-bracket-versus-torsion>
Lie bracket versus torsion</a>

</li>
<li>
 <a href=#spatial-partitioning-data-structures-in-molecular-dynamics>
Spatial partitioning data structures in molecular dynamics</a>

</li>
<li>
 <a href=#vector-arthur-whitney-and-text-editors>
Vector: Arthur Whitney and text editors</a>

</li>
<li>
 <a href=#discrete-random-distributions-with-conditioning-in-20-lines-of-haskell>
Discrete random distributions with conditioning in 20 lines of haskell</a>

</li>
<li>
 <a href=#everything-you-know-about-word2vec-is-wrong>
Everything you know about word2vec is wrong</a>

</li>
<li>
 <a href=#small-haskell-mcmc-implementation>
Small Haskell MCMC implementation </a>

</li>
<li>
 <a href=#debugging-debug-info-in-ghc>
Debugging debug info in GHC </a>

</li>
<li>
 <a href=#ghc-llvm-code-generator-switch-to-unreachable>
GHC LLVM code generator: Switch to unreachable</a>

</li>
<li>
 <a href=#concurrency-in-haskell>
Concurrency in Haskell</a>

</li>
<li>
 <a href=#handy-list-of-differential-geometry-definitions>
Handy list of differential geometry definitions</a>

</li>
<li>
 <a href=#lazy-programs-have-space-leaks-strict-programs-have-time-leaks>
Lazy programs have space leaks, Strict programs have time leaks</a>

</li>
<li>
 <a href=#presburger-arithmetic-can-represent-the-collatz-conjecture>
Presburger arithmetic can represent the Collatz Conjecture</a>

</li>
<li>
 <a href=#using-compactness-to-argue-about-covers>
Using compactness to argue about covers</a>

</li>
<li>
 <a href=#stephen-wolframs-live-stream>
Stephen wolfram's live stream</a>

</li>
<li>
 <a href=#japanese-financial-counting-system>
Japanese Financial Counting system</a>

</li>
<li>
 <a href=#cleave-as-a-word-has-some-of-the-most-irregular-inflections>
<code>Cleave</code> as a word has some of the most irregular inflections</a>

</li>
<li>
 <a href=#mccunes-single-axiom-for-group-theory>
McCune's single axiom for group theory</a>

</li>
<li>
 <a href=#arthur-whitney-dense-code>
Arthur Whitney: dense code</a>

</li>
<li>
 <a href=#how-does-one-work-with-arrays-in-a-linear-language>
How does one work with arrays in a linear language?</a>

</li>
<li>
 <a href=#linear-optimisation-is-the-same-as-linear-feasibility-checking>
Linear optimisation is the same as linear feasibility checking</a>

</li>
<li>
 <a href=#quantum-computation-without-complex-numbers>
Quantum computation without complex numbers</a>

</li>
<li>
 <a href=#linguistic-fun-fact-comparative-illusion>
Linguistic fun fact: Comparative Illusion </a>

</li>
<li>
 <a href=content/blog/stuff-i-learnt-this-year-2018.md>
Stuff I learnt in 2018</a>

</li>
<li>
 <a href=content/blog/papers-I-read-and-loved-in-2017.md>
Stuff I learnt in 2017</a>

</li>
<li>
 <a href=content/blog/reading-kmett-structs.md>
Reading the <code>structs</code> library</a>

</li>
<li>
 <a href=content/blog/machines/reading-kmett-machines.md>
Reading the <code>machines</code> library (WIP)</a>

</li>
<li>
 <a href=content/blog/laziness-for-c-programmers.md>
Explaining laziness (WIP)</a>

</li>
<li>
 <a href=stg-explained.md>
Explaining STG(WIP)</a>

</li>
<li>
 <a href=content/blog/ghc-micro-optimisations-or-why-proc-points-suck.md>
Simplexhc: proc points suck / making GHC an order of magnitude faster</a>

</li>
<li>
 <a href=this-month-in-simplexhc-dec-2017.md>
Simplexhc: dec 2017</a>

</li>
<li>
 <a href=this-week-in-simpexhc-oct-29-2017.md>
Simplexhc: oct 29 2017</a>

</li>
<li>
 <a href=this-week-in-simplexhc-07-2017.md>
Simplexhc: july 2017</a>

</li>
<li>
 <a href=this-week-in-simplexhc-2017-07-06.md>
Simplexhc: july 6th 2017</a>

</li>
<li>
 <a href=content/blog/announcing-simplexhc.md>
Simplexhc: announcement</a>

</li>
<li>
 <a href=content/blog/gsoc-vispy.md>
GSoC 2015 proposal</a>

</li>
<li>
 <a href=content/blog/gsoc-vispy-week-1-and-2.md>
GSoC 2015 week 1</a>

</li>
<li>
 <a href=content/blog/gsoc-vispy-week-3-and-4.md>
GSoC 2015 week 3 and 4</a>

</li>
<li>
 <a href=content/blog/gsoc-vispy-week-5.md>
GSoC 2015 week 5</a>

</li>
<li>
 <a href=content/blog/gsoc-vispy-week-6.md>
GSoC 2015 week 6</a>

</li>
<li>
 <a href=content/blog/gsoc-vispy-week-7.md>
GSoC 2015 week 7</a>

</li>
<li>
 <a href=content/blog/gsoc-vispy-report-6.md>
GSoC 2015 final report</a>

</li>
<li>
 <a href=#link-dump>
Link Dump</a>

</li>
<li>
 <a href=#big-list-of-emacs-gripes>
Big list of emacs gripes</a>

</li>
<li>
 <a href=#big-list-of-writing>
Big list of writing</a>

</li>
<li>
 <a href=#big-list-of-coq>
Big list of Coq</a>

</li>
<li>
 <a href=#big-list-of-latex>
Big list of Latex</a>

</li>
<li>
 <a href=#recipes>
Recipes</a>

</li>

</ul>

<h2><a id=lyndon-christoffel-convex-hull href='#lyndon-christoffel-convex-hull'> § </a> <a href=#lyndon-christoffel-convex-hull>
Lyndon + Christoffel = Convex Hull</a>
</h2>
Actual "real world" use-case of lyndon factorization, cribbed from here:
<ul>
<li>
 <a href=https://archipel.uqam.ca/8354/1/Reutenauer-2009a-preprint.pdf>
Lyndon + Christoffel = digitally convex</a>

</li>
<li>
 Combinatorics on Words: Christoffel Words and Repetitions in Words
</li>

</ul>

I wanted to learn a real-world use-case of lyndon factorization so I could
remember it. I found a whole bridge between combinatorics/strings and
discrete geometry (they call it "digital geometry") that I didn't know
existed before.
<ul>
<li>
 If you have a line with rational slope <span class='latexinline'>
<span style="font-style:italic">p</span>/<span style="font-style:italic">q</span></span> and you want to draw a
  "discretized line" by connecting integer points in ZxZ, you can describe this
  discretized line as starting from <span class='latexinline'>
(0, 0)</span>, making moves <span class='latexinline'>
<span style="font-style:italic">dx</span></span> (move up 1 unit
  along <span class='latexinline'>
<span style="font-style:italic">x</span></span>), <span class='latexinline'>
<span style="font-style:italic">dy</span></span> (move up 1 unit along <span class='latexinline'>
<span style="font-style:italic">y</span></span>), finally reaching the point 
  <span class='latexinline'>
(<span style="font-style:italic">p</span>, <span style="font-style:italic">q</span>)</span>. For example, to reach the point <span class='latexinline'>
(2, 3)</span>, you can make the moves 
  <span class='latexinline'>
[<span style="font-style:italic">dx</span>, <span style="font-style:italic">dy</span>, <span style="font-style:italic">dx</span>, <span style="font-style:italic">dy</span>, <span style="font-style:italic">dy</span>]</span>.
</li>

</ul>

<ul>
<li>
 A christoffel word is a word <span class='latexinline'>
<span style="font-style:italic">w</span> &#X2208; <span style="font-style:italic">dx</span>, <span style="font-style:italic">dy</span><sup>&#X22C6;</sup></span> such that it hugs a line of
  rational slope <span class='latexinline'>
<span style="font-style:italic">p</span>/<span style="font-style:italic">q</span></span> as close as possible. Formally, there are no integer
  points between the line with slope <span class='latexinline'>
<span style="font-style:italic">p</span>/<span style="font-style:italic">q</span></span> starting from the origin, and the
  discretized line as described by <span class='latexinline'>
<span style="font-style:italic">w</span></span>. An example picture:
</li>

</ul>

<img src="./static/christoffel-word-example.png">
<ul>
<li>
 It turns out that all primitive christoffel words are Lyndon words. I'm not
  100% sure what primitive is, but the take-away is that these primitive
  christoffel words represent discrete lines that are <i>good</i> approximations
  of lines.
</li>

</ul>

<ul>
<li>
 Now, we are given a discrete sequence of adjacent line segments going
  upwards, where the line segments are described by <span class='latexinline'>
<span style="font-style:italic">dx</span>, <span style="font-style:italic">dy</span></span> moves. We want to
  check if the discrete curve defined by them is well-approximating a convex
  polygon.
</li>

</ul>

<ul>
<li>
 We compute the lyndon factorization of the word. This splits the
  original line segment into a series of line segments, where each
  successive line segment has lower slope than the previous (since the
  lyndon decomposition splits words into non-decreasing lex order).
</li>

</ul>

<img src="./static/lyndon-convex.png">
<ul>
<li>
 We can then check that each word in the lyndon decomposition is a Christoffel
  word. If it is, then your sequence of moves describes a "good  discrete
  convex hull", since as described above, a christoffel word "hugs the line"
  well. 
</li>

</ul>

<h2><a id=e-x-1-xof-of- href='#e-x-1-xof-of-'> § </a> <a href=#1-x-e-xof-of->
Geometric proof of <code>e^x >= 1+x</code>, <code>e^(-x) <= 1-x</code></a>
</h2>
Let's concentrate on the <code>e^x >= 1 + x</code> part. 
<ol>
<li>
 The tangent of <code>e^x</code> at <code>x = 0</code> is <code>1 + x</code>, since the taylor series
   of <code>e^x</code> truncated upto <code>x</code> is <code>1 + x</code>.
</li>
<li>
 <code>e^x</code> is a strongly convex function, since <code>(e^x)'' = e^x</code> which is positive
   everywhere. Hence, <code>e^x</code> will always lie above its tangent.
</li>

</ol>

Similarly, for <code>e^(-x)</code>, we can either note that it's  substitution of <code>x</code> with
<code>-x</code> in our previous statement, and thus our previous statement will continue
to hold.  Alternatively, working through the math:
<ol>
<li>
 <code>1 -x</code> is tangent at <code>x=0</code> to <code>e^(-x)</code>
</li>
<li>
 <code>(e^(-x))'' = -(e^(-x))' e^(-x)</code> which is again positive everywhere, and
   hence, <code>e^(-x)</code> is strongly convex.
</li>

</ol>

<h2><a id=ranking-and-sorting href='#ranking-and-sorting'> § </a> <a href=#ranking-and-sorting>
Ranking and Sorting</a>
</h2>
We we want to sort an arrray <code>xs</code> and write the results into an array <code>ys</code>.
In both cases, the invariant to be satisfied is that <code>ys</code> is <code>xs</code> in ascending
order. I'll be considering two broad ways to implement such a thing:
<ul>
<li>
 1. <b>(RANK)</b> Index straight into <code>ys</code>, reindexed into <code>xs</code>. We name the reindexing
  array as <code>rs</code> (<code>rs</code> for <i>ranks</i>).
</li>

</ul>

<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> <b><u><font color="#000000">for</font></u></b>(<b><font color="#000000">int</font></b> i = <font color="#000000">0</font>; i &lt; N; ++i) {
<font color="#000000">3:</font>    ys[rs[i]] = xs[i]
<font color="#000000">4:</font> }
<font color="#000000">5:</font> </tt></pre>
</div>

<ul>
<li>
 2. <b>(SELECT)</b> Reindex into <code>ys</code>, index straight into <code>xs</code>. 
  We name the reindexing array <code>ss</code> (<code>ss</code> for <i>selects</i>).
</li>

</ul>

<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> <b><u><font color="#000000">for</font></u></b>(<b><font color="#000000">int</font></b> i = <font color="#000000">0</font>; i &lt; N; ++i) {
<font color="#000000">3:</font>    ys[i] = xs[ss[i]]
<font color="#000000">4:</font> }
<font color="#000000">5:</font> </tt></pre>
</div>

<h4><a id=defnition-of-rank href='#defnition-of-rank'> § </a> Defnition of rank</h4>
In the case of <b>(RANK)</b>, the specification is that the rank of an element <code>e</code>
is the number of elements that are:
<ol>
<li>
 less than <code>e</code>.
</li>
<li>
 equal to <code>e</code> but occur before <code>e</code>.
</li>

</ol>

This ensures that rank is a <i>permutation</i>: that is, every element <code>e</code> is given
a <i>unique</i> index. 
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> <b><font color="#000000">int</font></b> rank(<b><u><font color="#000000">const</font></u></b> <b><font color="#000000">int</font></b> *xs, <b><font color="#000000">int</font></b> i) { 
<font color="#000000">03:</font>     <b><font color="#000000">int</font></b> cnt = <font color="#000000">0</font>;
<font color="#000000">04:</font>     <b><u><font color="#000000">for</font></u></b> (<b><font color="#000000">int</font></b> j = <font color="#000000">0</font>; j &lt; N; ++j) {
<font color="#000000">05:</font>         <b><u><font color="#000000">if</font></u></b> (xs[j] &lt; xs[i] || (xs[j] == xs[i] &amp;&amp; j &lt; i)) cnt += <font color="#000000">1</font>;
<font color="#000000">06:</font>     }
<font color="#000000">07:</font>     <b><u><font color="#000000">return</font></u></b> cnt;
<font color="#000000">08:</font> }
<font color="#000000">09:</font> 
<font color="#000000">10:</font> <b><u><font color="#000000">for</font></u></b>(<b><font color="#000000">int</font></b> i = <font color="#000000">0</font>; i &lt; N; ++i) {
<font color="#000000">11:</font>   rs[i] = rank(xs, i);
<font color="#000000">12:</font> }
<font color="#000000">13:</font> </tt></pre>
</div>

<h4><a id=rank-alternative-1 href='#rank-alternative-1'> § </a> Rank: Alternative 1</h4>
An alternative way to look at our definition of rank is that we are
sorting the tuples  <code>(xs[i], i)</code> using lex ordering. So if two indeces
<code>i, j</code> have the same value, then we sort on the index.
<h4><a id=rank-alternative-2 href='#rank-alternative-2'> § </a> Rank: Alternative 2</h4>
We could have also defined rank as:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> <b><font color="#000000">int</font></b> rank(<b><font color="#000000">int</font></b> *xs, <b><font color="#000000">int</font></b> i) { 
<font color="#000000">3:</font>     <b><font color="#000000">int</font></b> cnt = <font color="#000000">0</font>;
<font color="#000000">4:</font>     <b><u><font color="#000000">for</font></u></b> (<b><font color="#000000">int</font></b> j = <font color="#000000">0</font>; j &lt; i; ++j) {
<font color="#000000">5:</font>         <b><u><font color="#000000">if</font></u></b> (xs[j] &lt;= xs[i]) cnt += <font color="#000000">1</font>
<font color="#000000">6:</font>     }
<font color="#000000">7:</font>     <b><u><font color="#000000">return</font></u></b> cnt;
<font color="#000000">8:</font> }
<font color="#000000">9:</font> </tt></pre>
</div>

I declined from doing so because I wanted to show the lex-ordering
interpretation of <code>rank</code> will be be useful later.
<h4><a id=definition-of-select href='#definition-of-select'> § </a> Definition of select</h4>
For <b>(SELECT)</b>, we'll need to think a little harder. Let's try to rewrite
our way to glory:
<ul>
<li>
 1. From definition of rank:
</li>

</ul>

<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> ys[rs[i]] = xs[i]
<font color="#000000">3:</font> </tt></pre>
</div>

<ul>
<li>
 2. move <code>i -> ss[i]</code> where <code>ss[i]</code> is guaranteed to be a permutation,
  so we will write each index eventually:
</li>

</ul>

<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> ys[rs[ss[i]]] = xs[ss[i]]
<font color="#000000">3:</font> </tt></pre>
</div>

<ul>
<li>
 3. Stipulate that <code>rs[ss[i]] = i</code>, since we want a <code>ys[i]</code>:
</li>

</ul>

<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> ys[i] = xs[ss[i]]
<font color="#000000">3:</font> </tt></pre>
</div>

This gives us necessary and sufficient conditions on how to find an <code>ss</code>:
<code>ss</code> must be a permutation that is an inverse permutation to <code>rs</code>.
<h4><a id=how-to-invert-a-permutation href='#how-to-invert-a-permutation'> § </a> How to invert a permutation?</h4>
How does one invert a permutation? We have a permutation <code>rs[i]</code> that maps
<code>i</code> to <code>rs[i]</code>. We want to find a new permutation <code>ss[i]</code> such that 
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> rs[ss[i]] = i
<font color="#000000">3:</font> </tt></pre>
</div>

Equivalently:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> // ss[i] is an index 'k'...
<font color="#000000">3:</font> ss[i] = k 
<font color="#000000">4:</font> // 'k' is the location of 'i' in rs.
<font color="#000000">5:</font> rs[k] = i
<font color="#000000">6:</font> </tt></pre>
</div>

So if we first tag each location of <code>rs</code> with its index, and then sort
with the values of <code>rs</code> being the keys, then <code>ss[i]</code> will be the values.
In pictures:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> rs[i]          [3 4 0 1 2]
<font color="#000000">3:</font> rs_tagged[i]   [(3, 0) (4, 1) (0, 2) (1, 3) (2, 4)]
<font color="#000000">4:</font> rs_sorted[i]   [(0, 2) (1, 3) (2, 4) (3, 0) (4, 1)]
<font color="#000000">5:</font> ss[i]          [    2      3      4      0      1 ]
<font color="#000000">6:</font> rs[ss[i]]      [ rs[2]  rs[3]  rs[4]  rs[0]  rs[1]]
<font color="#000000">7:</font> rs[ss[i]]      [    0      1      2      3      4 ]
<font color="#000000">8:</font> </tt></pre>
</div>

<h4><a id=rank-and-select-are-inverses href='#rank-and-select-are-inverses'> § </a> Rank and Select are inverses</h4>
It's nice, there are a couple of miracles that lined up here:
<ul>
<li>
 Rank starts with <code>r</code> and select starts with <code>s</code> so we get nice naming.
</li>
<li>
 Rank and select are true inverse permutations of each other.
</li>

</ul>

<h4><a id=generalized-rank-and-select-are-adjoint href='#generalized-rank-and-select-are-adjoint'> § </a> Generalized rank and select are adjoint</h4>
We had to "fix" our definition of rank to avoid equal elements in the array.
Hence, we had the rule that we also sort by indexes if the elements are
equal. However, if we now decide to ignore this rule, we will then recreate
the classical <i>adjunction</i> between rank and select.
<h4><a id=references href='#references'> § </a> References</h4>
<ul>
<li>
 Richard Bird: Pearls of functional algorithm design
</li>

</ul>

<h2><a id=proof-of-minkowski-convex-body-theorem href='#proof-of-minkowski-convex-body-theorem'> § </a> <a href=#proof-of-minkowski-convex-body-theorem>
Proof of minkowski convex body theorem</a>
</h2>
We can derive a proof of the minkowski convex body theorem starting from
Blichfeldt’s theorem.
<h4><a id=blichfeldts-theorem href='#blichfeldts-theorem'> § </a> Blichfeldt's theorem</h4>
This theorem allows us to prove that a set 
of large-enough-size in any lattice will have two points such that their
difference lies in the lattice. Formally, we have:
<ol>
<li>
 A lattice <span class='latexinline'>
<span style="font-style:italic">L</span>(<span style="font-style:italic">B</span>) &#X2261; { <span style="font-style:italic">Bx</span> : <span style="font-style:italic">x</span> &#X2208; &#X2124;<sup><span style="font-style:italic">n</span></sup> }</span> for some basis 
   <span class='latexinline'>
<span style="font-style:italic">B</span> &#X2208; <sup><span style="font-style:italic">n</span></sup></span>. The lattice <span class='latexinline'>
<span style="font-style:italic">L</span></span> is spanned by integer linear
   combinations of rows of <span class='latexinline'>
<span style="font-style:italic">B</span></span>.
</li>
<li>
 A body <span class='latexinline'>
<span style="font-style:italic">S</span> &#X2286; <span style="font-style:italic">R</span><sup><span style="font-style:italic">n</span></sup></span> which <b>need not be convex!</b>, which 
   has volume greater than <span class='latexinline'>
det(<span style="font-style:italic">B</span>)</span>. Recall that for a lattice <span class='latexinline'>
<span style="font-style:italic">L</span>(<span style="font-style:italic">B</span>)</span>,
   the volume of a fundamental unit / fundamental parallelopiped is <span class='latexinline'>
<span style="font-style:italic">det</span>(<span style="font-style:italic">B</span>)</span>.
</li>

</ol>

Blichfeldt's theorem tells us that there exists two points <span class='latexinline'>
<span style="font-style:italic">x</span><sub>1</sub>, <span style="font-style:italic">x</span><sub>2</sub> &#X2208; <span style="font-style:italic">S</span></span>
such that <span class='latexinline'>
<span style="font-style:italic">x</span><sub>1</sub> &#X2212; <span style="font-style:italic">x</span><sub>2</sub> &#X2208; <span style="font-style:italic">L</span></span>.
<h4><a id=proof href='#proof'> § </a> Proof</h4>
The idea is to:
<ol>
<li>
 Chop up sections of <span class='latexinline'>
<span style="font-style:italic">S</span></span> across all translates of the fundamental parallelopiped
   that have non-empty intersections with <span class='latexinline'>
<span style="font-style:italic">S</span></span> back to the origin. This makes
   all of them overlap with the fundamental parallelopiped with the origin.
</li>
<li>
 Since <span class='latexinline'>
<span style="font-style:italic">S</span></span> has volume great that <span class='latexinline'>
det(<span style="font-style:italic">B</span>)</span>, but the fundamental paralellopiped
   only has volume <span class='latexinline'>
det(<span style="font-style:italic">B</span>)</span>, points from two different parallelograms <b>must</b>
   overlap.
</li>
<li>
 "Undo" the translation to find two points which are of the form <span class='latexinline'>
<span style="font-style:italic">x</span><sub>1</sub> = <span style="font-style:italic">l</span><sub>1</sub> + &#X3B4;</span>,
   <span class='latexinline'>
<span style="font-style:italic">x</span><sub>2</sub> = <span style="font-style:italic">l</span><sub>2</sub> + &#X3B4;</span>. they must have the same <span class='latexinline'>
&#X3B4;</span> since they overlapped
   when they were laid on the fundamental paralellopiped. Also notice that <span class='latexinline'>
<span style="font-style:italic">l</span><sub>1</sub> &#X2260; <span style="font-style:italic">l</span><sub>2</sub></span>
   since they came from two different parallograms on the plane!
</li>
<li>
 Notice that <span class='latexinline'>
<span style="font-style:italic">x</span><sub>1</sub> &#X2212; <span style="font-style:italic">x</span><sub>2</sub> = <span style="font-style:italic">l</span><sub>1</sub> &#X2212; <span style="font-style:italic">l</span><sub>2</sub>&#X2208; <span style="font-style:italic">L</span> &#X2260; 0</span>, since we already argued
   that <span class='latexinline'>
<span style="font-style:italic">l</span><sub>1</sub> &#X2260; <span style="font-style:italic">l</span><sub>2</sub></span>. This gives us what we want.
</li>

</ol>

<h4><a id=minkowskis-convex-body-theorem-from-blichfeldts-theorem href='#minkowskis-convex-body-theorem-from-blichfeldts-theorem'> § </a> Minkowskis' Convex body Theorem from Blichfeldt's theorem</h4>
Consider a convex set <span class='latexinline'>
<span style="font-style:italic">S</span> &#X2286; &#X211D;<sup><span style="font-style:italic">n</span></sup></span>
that is symmetric about the origin with volume greater than <span class='latexinline'>
2<sup><span style="font-style:italic">n</span></sup> <span style="font-style:italic">det</span>(<span style="font-style:italic">B</span>)</span>.
Create a new set <span class='latexinline'>
<span style="font-style:italic">T</span></span> which is <span class='latexinline'>
<span style="font-style:italic">S</span> * 0.5</span>. Formally:
<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">T</span>&#XA0;&#X2261;&#XA0;<span style="font-style:italic">S</span>/2&#XA0;=&#XA0;{&#XA0;(<span style="font-style:italic">x</span><sub>1</sub>/2,&#XA0;<span style="font-style:italic">x</span><sub>2</sub>,&#XA0;&#X2026;,&#XA0;<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>/2)&#XA0;&#XA0;:&#XA0;(<span style="font-style:italic">x</span><sub>1</sub>,&#XA0;<span style="font-style:italic">x</span><sub>2</sub>,&#XA0;&#X2026;,&#XA0;<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>)&#XA0;&#X2208;&#XA0;<span style="font-style:italic">S</span>&#XA0;}</td></tr>
</table></div>
We now see that <span class='latexinline'>
<span style="font-style:italic">Vol</span>(<span style="font-style:italic">T</span>) &gt; <span style="font-style:italic">det</span>(<span style="font-style:italic">B</span>)</span> to invoke  Blichfeldt's theorem.
Formally:
<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">Vol</span>(<span style="font-style:italic">T</span>)&#XA0;=&#XA0;1/2<sup><span style="font-style:italic">n</span></sup>&#XA0;<span style="font-style:italic">Vol</span>(<span style="font-style:italic">S</span>)&#XA0;&gt;&#XA0;1/2<sup><span style="font-style:italic">n</span></sup>&#XA0;(2<sup><span style="font-style:italic">n</span></sup>&#XA0;<span style="font-style:italic">det</span>(<span style="font-style:italic">B</span>))&#XA0;=&#XA0;<span style="font-style:italic">det</span>(<span style="font-style:italic">B</span>)</td></tr>
</table></div>
We can apply Blichfeldt's theorem to get our hands on two points <span class='latexinline'>
<span style="font-style:italic">x</span><sub>1</sub>, <span style="font-style:italic">x</span><sub>2</sub> &#X2208; <span style="font-style:italic">T</span></span>
such that <span class='latexinline'>
<span style="font-style:italic">x</span><sub>1</sub> &#X2212; <span style="font-style:italic">x</span><sub>2</sub> &#X2208; <span style="font-style:italic">L</span></span>. 
<div class='latexblock'><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">x</span><sub>1</sub>&#XA0;&#X2208;&#XA0;<span style="font-style:italic">T</span>&#XA0;&#X21D2;&#XA0;2<span style="font-style:italic">x</span><sub>1</sub>&#XA0;&#X2208;&#XA0;<span style="font-style:italic">S</span>&#XA0;&#XA0;(<span style="font-style:italic">S</span>&#XA0;=&#XA0;2<span style="font-style:italic">T</span>)&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">x</span><sub>2</sub>&#XA0;&#X2208;&#XA0;<span style="font-style:italic">T</span>&#XA0;&#X21D2;&#XA0;2<span style="font-style:italic">x</span><sub>2</sub>&#XA0;&#X2208;&#XA0;<span style="font-style:italic">S</span>&#XA0;&#XA0;(<span style="font-style:italic">S</span>&#XA0;=&#XA0;2<span style="font-style:italic">T</span>)&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >2<span style="font-style:italic">x</span><sub>2</sub>&#XA0;&#X2208;&#XA0;<span style="font-style:italic">S</span>&#XA0;&#X21D2;&#XA0;&#X2212;2<span style="font-style:italic">x</span><sub>2</sub>&#XA0;&#X2208;&#XA0;<span style="font-style:italic">S</span>&#XA0;(<span style="font-style:italic">S</span> is symmetric about origin)&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">(2<span style="font-style:italic">x</span><sub>1</sub>)&#XA0;+&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">&#XA0;(&#X2212;2<span style="font-style:italic">x</span><sub>2</sub>)&#XA0;&#X2208;&#XA0;<span style="font-style:italic">S</span>&#XA0;(<span style="font-style:italic">S</span> is convex)</td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">x</span><sub>1</sub>&#XA0;&#X2212;&#XA0;<span style="font-style:italic">x</span><sub>2</sub>&#XA0;&#X2208;&#XA0;<span style="font-style:italic">S</span>&#XA0;(Simplification)</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >nonzero lattice point&#XA0;&#X2208;&#XA0;<span style="font-style:italic">S</span>&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table>
</div>
<h4><a id=references href='#references'> § </a> References</h4>
<ul>
<li>
 <a href=https://www.theoremoftheday.org/GeometryAndTrigonometry/Minkowski/TotDMinkowski.pdf>
Theorem of the day</a>

</li>

</ul>

<h2><a id=burrows-wheeler href='#burrows-wheeler'> § </a> <a href=#burrows-wheeler>
Burrows Wheeler</a>
</h2>
We aim to get the <span class='latexinline'>
<span style="font-style:italic">O</span>(<span style="font-style:italic">n</span>)</span> algorithm for burrows wheeler, by starting from the
naive <span class='latexinline'>
<span style="font-style:italic">O</span>(<span style="font-style:italic">n</span><sup>2</sup>)</span> implementation and then slowly chipping away to get to the
fastest algorithm
                 
<h4><a id=string-rotations href='#string-rotations'> § </a> String rotations</h4>
Given a string <span class='latexinline'>
<span style="font-style:italic">s</span></span> of length <span class='latexinline'>
<span style="font-style:italic">n</span></span>, we can index it as <span class='latexinline'>
<span style="font-style:italic">s</span>[0]</span>, <span class='latexinline'>
<span style="font-style:italic">s</span>[1]</span>, upto
<span class='latexinline'>
<span style="font-style:italic">s</span>[<span style="font-style:italic">n</span>&#X2212;1]</span>. We can now build a table consisting of <i>rotations</i> of the string.
We'll define:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> lrot :: [a] -&gt; [a]
<font color="#000000">3:</font> lrot [] = []; lrot (x:xs) = xs ++ [x]
<font color="#000000">4:</font> </tt></pre>
</div>

We can build a table of left-rotations:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> foobar
<font color="#000000">3:</font> oobarf
<font color="#000000">4:</font> obarfo
<font color="#000000">5:</font> barfoo
<font color="#000000">6:</font> arfoob
<font color="#000000">7:</font> rfooba
<font color="#000000">8:</font> </tt></pre>
</div>

We can immediately notice that it's a <i>symmetric matrix</i>. We can prove
this as follows. We write <span class='latexinline'>
<span style="font-style:italic">lrot</span>(<span style="font-style:italic">rot</span>, <span style="font-style:italic">s</span>)</span> as an array such that:
<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">lrot</span>(<span style="font-style:italic">rot</span>,&#XA0;<span style="font-style:italic">s</span>)[<span style="font-style:italic">i</span>]&#XA0;=&#XA0;<span style="font-style:italic">s</span>[(<span style="font-style:italic">rot</span>&#XA0;+&#XA0;<span style="font-style:italic">i</span>)&#XA0;</td></tr>
</table></div>
Now, we note that on row <span class='latexinline'>
<span style="font-style:italic">r</span></span> of our array we have the string <span class='latexinline'>
<span style="font-style:italic">lrot</span>(<span style="font-style:italic">r</span>, <span style="font-style:italic">s</span>)</span>.
So the value at row <span class='latexinline'>
<span style="font-style:italic">r</span></span>, column <span class='latexinline'>
<span style="font-style:italic">c</span></span> is <span class='latexinline'>
</span>.
But this is symmetric in <span class='latexinline'>
<span style="font-style:italic">c</span>, <span style="font-style:italic">r</span></span> so can be written as <span class='latexinline'>
</span>,
which is equal to <span class='latexinline'>
<span style="font-style:italic">lrot</span>(<span style="font-style:italic">c</span>, <span style="font-style:italic">s</span>)[<span style="font-style:italic">r</span>]</span>. Formally:
<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">lrot</span>(<span style="font-style:italic">r</span>,&#XA0;<span style="font-style:italic">s</span>)[<span style="font-style:italic">c</span>]&#XA0;=&#XA0;<span style="font-style:italic">s</span>[(<span style="font-style:italic">r</span>&#XA0;+&#XA0;<span style="font-style:italic">c</span>)&#XA0;</td></tr>
</table></div>
<h4><a id=sorts-of-string-rotations href='#sorts-of-string-rotations'> § </a> Sorts of string rotations</h4>
We're next interested in considering <i>sorted order</i> of the string
rotations. For example, in the case of the string "here, there",
all the rotations are:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> here-there  0
<font color="#000000">03:</font> ere-thereh  1
<font color="#000000">04:</font> re-therehe  2
<font color="#000000">05:</font> e-thereher  3
<font color="#000000">06:</font> -therehere  4
<font color="#000000">07:</font> therehere-  5
<font color="#000000">08:</font> herehere-t  6
<font color="#000000">09:</font> erehere-th  7
<font color="#000000">10:</font> rehere-the  8
<font color="#000000">11:</font> ehere-ther  9
<font color="#000000">12:</font> </tt></pre>
</div>

which is calculated with the help of the following haskell code:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> lrot :: [a] -&gt; [a]
<font color="#000000">3:</font> lrot [] = []; lrot (a:as) = as ++ [a]
<font color="#000000">4:</font> 
<font color="#000000">5:</font> lrots :: [a] -&gt; [[a]]; lrots as = take (length as) (iterate lrot as)
<font color="#000000">6:</font> 
<font color="#000000">7:</font> main =  putStrLn $ intercalate <font color="#808080">"\n"</font>  
<font color="#000000">8:</font>   (zipWith (\s i -&gt; s &lt;&gt; <font color="#808080">"  "</font> &lt;&gt; show i)
<font color="#000000">9:</font>            (lrots <font color="#808080">"here-there"</font>) [<font color="#000000">0</font>,<font color="#000000">1</font>..])
<font color="#000000">10:</font> </tt></pre>
</div>

If we now <i>sort</i> these rotations, we get:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> -therehere  0
<font color="#000000">03:</font> e-thereher  1
<font color="#000000">04:</font> ehere-ther  2
<font color="#000000">05:</font> ere-thereh  3
<font color="#000000">06:</font> erehere-th  4
<font color="#000000">07:</font> here-there  5
<font color="#000000">08:</font> herehere-t  6
<font color="#000000">09:</font> re-therehe  7
<font color="#000000">10:</font> rehere-the  8
<font color="#000000">11:</font> therehere-  9
<font color="#000000">12:</font> </tt></pre>
</div>

we produce this by chainging the above definition of <code>main</code> to:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> main =  putStrLn $ intercalate "\n"  
<font color="#000000">3:</font>   (zipWith (\s i -&gt; s &lt;&gt; "  " &lt;&gt; show i)
<font color="#000000">4:</font>            -- | extra `sort` here
<font color="#000000">5:</font>            (sort $ lrots "here-there") [0,1..])
<font color="#000000">6:</font> </tt></pre>
</div>

Let's look at the <b>final column</b> of that table. We have:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> -thereher|e|  0
<font color="#000000">03:</font> e-therehe|r|  1
<font color="#000000">04:</font> ehere-the|r|  2
<font color="#000000">05:</font> ere-there|h|  3
<font color="#000000">06:</font> erehere-t|h|  4
<font color="#000000">07:</font> here-ther|e|  5 &lt;- ORIGINAL STRING
<font color="#000000">08:</font> herehere-|t|  6
<font color="#000000">09:</font> re-thereh|e|  7
<font color="#000000">10:</font> rehere-th|e|  8
<font color="#000000">11:</font> therehere|-|  9
<font color="#000000">12:</font> 
<font color="#000000">13:</font> 0123456789
<font color="#000000">14:</font> errhhetee-
<font color="#000000">15:</font> </tt></pre>
</div>

Now, we'll show how to write a <i>really cool</i> function call <code>bwt</code> such that:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> bwtinv (<font color="#808080">"errhhetee-"</font>,<font color="#000000">5</font>) = <font color="#808080">"here-there"</font>
<font color="#000000">3:</font> </tt></pre>
</div>

The <code>5</code> is the index of the original string in the list. That is, given
the jumbled up last-column and the index of the original string, we're
able to reconstruct the original string. The reason this is useful is
that the jumbled string <code>"errhhetee-"</code> is easier to compress: it has
long runs of <code>r</code>, <code>h</code>, and <code>e</code> which makes it easier to compress.
The process we performed of rotating, sorting the rotations and taking
the final column is the Burrows-Wheeler transform. in code:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> <b><u><font color="#000000">import</font></u></b> Data.<b><font color="#000000">List</font></b>
<font color="#000000">03:</font> lrot :: [a] -&gt; [a]
<font color="#000000">04:</font> lrot [] = []; lrot (a:as) = as ++ [a]
<font color="#000000">05:</font> 
<font color="#000000">06:</font> lrots :: [a] -&gt; [[a]]
<font color="#000000">07:</font> lrots as = take (length as) (iterate lrot as)
<font color="#000000">08:</font> 
<font color="#000000">09:</font> findix :: <b><font color="#000000">Eq</font></b> a =&gt; a -&gt; [a] -&gt; <b><font color="#000000">Int</font></b>
<font color="#000000">10:</font> findix a as = length (takeWhile (/= a) as)
<font color="#000000">11:</font> 
<font color="#000000">12:</font> lastcol :: [[a]] -&gt; [a]; lastcol = map last
<font color="#000000">13:</font> 
<font color="#000000">14:</font> bwt :: <b><font color="#000000">Eq</font></b> a =&gt; <b><font color="#000000">Ord</font></b> a =&gt; [a] -&gt; ([a], <b><font color="#000000">Int</font></b>)
<font color="#000000">15:</font> bwt as = <b><u><font color="#000000">let</font></u></b> as' = (sort . lrots) as in (lastcol as', findix as as')
<font color="#000000">16:</font> </tt></pre>
</div>

Now we need to understand how <code>bwtinv</code> is defined and what it does.
The definition is:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> import Control.Arrow (&amp;&amp;&amp;)
<font color="#000000">03:</font> 
<font color="#000000">04:</font> bwtinv :: Eq a =&gt; Ord a =&gt; ([a], Int) -&gt; [a]
<font color="#000000">05:</font> bwtinv (as, k) = recreate as !! k
<font color="#000000">06:</font> 
<font color="#000000">07:</font> -- recreate · lastcol · sort · rots = sort · rots
<font color="#000000">08:</font> recreate :: (Eq a, Ord a) =&gt; [a] -&gt; [[a]]
<font color="#000000">09:</font> recreate as = recreate' (length as) as
<font color="#000000">10:</font> 
<font color="#000000">11:</font> recreate' :: (Eq a, Ord a) =&gt; Int -&gt; [a] -&gt; [[a]]
<font color="#000000">12:</font> recreate' 0 = map (const [])
<font color="#000000">13:</font> recreate' n = hdsort . consCol . (id &amp;&amp;&amp; recreate' (n-1))
<font color="#000000">14:</font> 
<font color="#000000">15:</font> 
<font color="#000000">16:</font> hdsort :: Ord a =&gt; [[a]] -&gt; [[a]]
<font color="#000000">17:</font> hdsort = let cmp (x:xs) (y:ys) = compare x y
<font color="#000000">18:</font>          in sortBy cmp 
<font color="#000000">19:</font> 
<font color="#000000">20:</font> consCol :: ([a], [[a]]) -&gt; [[a]]
<font color="#000000">21:</font> consCol = uncurry (zipWith (:))
<font color="#000000">22:</font> </tt></pre>
</div>

OK, so much for the code. what does it <i>do</i>?
The idea is that:
<ul>
<li>
 we recreate the entire matrix from the last column using <code>recreate</code>
  and take the <code>k</code>th element.
</li>

</ul>

<ul>
<li>
 <code>recreate</code> apprents a copy of the initial last column to a matrix of
  columns, and then sorts this.
</li>

</ul>

<h4><a id=references href='#references'> § </a> References</h4>
<ul>
<li>
 Richard Bird: Pearls of functional algorithm design
</li>

</ul>

<h2><a id=intuitionstic-logic-as-a-heytig-algebra href='#intuitionstic-logic-as-a-heytig-algebra'> § </a> <a href=#intuitionstic-logic-as-a-heytig-algebra>
Intuitionstic logic as a Heytig algebra</a>
</h2>
<i>open sets</i> form a Heytig Algebra, which is a lattice plus an implication
operator. So it's stronger than a lattice, but weaker than a boolean algebra.
Formally, a Heytig algebra over a set <span class='latexinline'>
<span style="font-style:italic">X</span></span> is a collection <span class='latexinline'>
(<span style="font-style:italic">L</span>, &#X2228;, &#X2227;, &#X21D2;)</span>
where <span class='latexinline'>
(<span style="font-style:italic">X</span>, &#X2228;, &#X2227;)</span> form a lattice, and <span class='latexinline'>
&#X21D2;</span> obeys the axiom
<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">&#X21D2;:&#XA0;<span style="font-style:italic">L</span>&#XA0;&#X2192;&#XA0;<span style="font-style:italic">L</span>;&#XA0;(<span style="font-style:italic">c</span>&#XA0;&#X2227;&#XA0;<span style="font-style:italic">a</span>)&#XA0;&#X2264;&#XA0;<span style="font-style:italic">b</span>&#XA0;&#XA0;&#X21D0;&#X21D2;&#XA0;<span style="font-style:italic">c</span>&#XA0;&#X2264;&#XA0;(<span style="font-style:italic">a</span>&#XA0;&#X21D2;&#XA0;<span style="font-style:italic">b</span>)
</td></tr>
</table></div>
In any topological space <span class='latexinline'>
(<span style="font-style:italic">U</span>, &#X3C4;)</span> (<span class='latexinline'>
<span style="font-style:italic">U</span></span> for universe set)
the open sets of that space form a Heytig algebra.
Here, set-union and set-intersection become the lattice join and lattice meet.
We define a "weak complement" denoted by <span class='latexinline'>
&#XAC;</span> which is defined as:
<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">&#XAC;&#XA0;<span style="font-style:italic">A</span>&#XA0;&#X2261;&#XA0;<span style="font-family:monospace">interior</span>(<span style="font-style:italic">A</span><sup><span style="font-style:italic">C</span></sup>)
</td></tr>
</table></div>
We need the <span class='latexinline'>
<span style="font-family:monospace">interior</span></span> to make sure that we're left with an open
set. Also, this <span class='latexinline'>
&#XAC;</span> is not really a complement, since we won't have that
<span class='latexinline'>
&#XAC; &#XAC; <span style="font-style:italic">A</span> = <span style="font-style:italic">A</span></span>. but, more on that later!
We write open intervals with round parenthesis:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font>     A
<font color="#000000">3:</font> --(===)--
<font color="#000000">4:</font> </tt></pre>
</div>

<span class='latexinline'>
&#XAC; <span style="font-style:italic">A</span></span> of the above set <span class='latexinline'>
<span style="font-style:italic">A</span></span> becomes the open interval that is in the
interior of <span class='latexinline'>
<span style="font-style:italic">A</span></span> complement.
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> --(===)-- A
<font color="#000000">3:</font> ==]---[== A complement
<font color="#000000">4:</font> ==)---(== Not A
<font color="#000000">5:</font> </tt></pre>
</div>

Now, we can try to ask, when is <span class='latexinline'>
&#XAC; &#XAC; <span style="font-style:italic">A</span> = <span style="font-style:italic">U</span></span> (where <span class='latexinline'>
<span style="font-style:italic">U</span></span> is the universe
set or the full space). If we consider a set containing a single point,
then we will have:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> ==)(== A 
<font color="#000000">3:</font> ------------ Not A  
<font color="#000000">4:</font> ============ Not (Not A)
<font color="#000000">5:</font> </tt></pre>
</div>

in words:
<div class='latexblock'><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">A</span>&#XA0;=&#XA0;<span style="font-style:italic">U</span>&#XA0;&#X2216;&#XA0;{&#XA0;1&#XA0;}&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&#XAC;&#XA0;<span style="font-style:italic">A</span>&#XA0;=&#XA0;<span style="font-family:monospace">interior</span>(<span style="font-style:italic">A</span><sup><span style="font-style:italic">c</span></sup>)&#XA0;=&#XA0;<span style="font-family:monospace">interior</span>({&#XA0;1&#XA0;})&#XA0;=&#XA0;&#X2205;&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&#XAC;&#XA0;&#XAC;&#XA0;<span style="font-style:italic">A</span>&#XA0;=&#XA0;<span style="font-family:monospace">interior</span>((&#XAC;&#XA0;<span style="font-style:italic">A</span>)<sup><span style="font-style:italic">c</span></sup>)&#XA0;=&#XA0;<span style="font-family:monospace">interior</span>(&#X2205;<sup><span style="font-style:italic">c</span></sup>)&#XA0;=&#XA0;<span style="font-family:monospace">interior</span>(<span style="font-style:italic">U</span>)&#XA0;=&#XA0;<span style="font-style:italic">U</span>&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table>
</div>
So in some sense, the law of excluded middle is "almost true": It holds that <span class='latexinline'>
<span style="font-style:italic">A</span> &#X2243; &#XAC; &#XAC; <span style="font-style:italic">A</span></span>,
where <span class='latexinline'>
<span style="font-style:italic">A</span></span> excludes a set of points of measure zero.
This is really interesting, since it gives some sort of oddball probabilistic
flavour to things where if we blind ourselves to measure-0 sets, then <span class='latexinline'>
&#XAC; &#XAC; <span style="font-style:italic">A</span> = <span style="font-style:italic">A</span></span>.
Now, we look at implication. The implication <span class='latexinline'>
<span style="font-style:italic">A</span> &#X21D2; <span style="font-style:italic">B</span></span> is the largest
set open <span class='latexinline'>
<span style="font-style:italic">C</span></span> such that <span class='latexinline'>
<span style="font-style:italic">C</span> &#X2227; <span style="font-style:italic">A</span> = <span style="font-style:italic">B</span></span>. In pictures:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> ---(========)----- A
<font color="#000000">3:</font> ---------(=====)-- B
<font color="#000000">4:</font> ---------(==)----- A &amp;&amp; B
<font color="#000000">5:</font> ===)-----(======== A -&gt; B
<font color="#000000">6:</font> </tt></pre>
</div>

The reason this is true is that from the definition:
<div class='latexblock'><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&#X21D2;:&#XA0;<span style="font-style:italic">L</span>&#XA0;&#X2192;&#XA0;<span style="font-style:italic">L</span>;&#XA0;&#XA0;<span style="font-style:italic">c</span>&#XA0;&#X2264;&#XA0;(<span style="font-style:italic">a</span>&#XA0;&#X21D2;&#XA0;<span style="font-style:italic">b</span>)&#XA0;&#XA0;&#X21D0;&#X21D2;&#XA0;(<span style="font-style:italic">c</span>&#XA0;&#X2227;&#XA0;<span style="font-style:italic">a</span>)&#XA0;&#X2264;&#XA0;<span style="font-style:italic">b</span>&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >replacing &#X2264; with = for insight:&#XA0;&#XA0;&#XA0;&#XA0;</td><td style="text-align:right;white-space:nowrap" >&#X21D2;:&#XA0;<span style="font-style:italic">L</span>&#XA0;&#X2192;&#XA0;<span style="font-style:italic">L</span>;&#XA0;&#XA0;<span style="font-style:italic">c</span>&#XA0;=&#XA0;(<span style="font-style:italic">a</span>&#XA0;&#X21D2;&#XA0;<span style="font-style:italic">b</span>)&#XA0;&#XA0;&#X21D0;&#X21D2;&#XA0;(<span style="font-style:italic">c</span>&#XA0;&#X2227;&#XA0;<span style="font-style:italic">a</span>)&#XA0;=&#XA0;<span style="font-style:italic">b</span>&#XA0;&#XA0;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table>
</div>
Alternatively, we can use the fact that in regular boolean algebra:
                    
<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">a</span>&#XA0;&#X21D2;&#XA0;<span style="font-style:italic">b</span>&#XA0;=&#XA0;&#XAC;&#XA0;<span style="font-style:italic">a</span>&#XA0;&#X2228;&#XA0;<span style="font-style:italic">b</span></td></tr>
</table></div>
to derive <span class='latexinline'>
<span style="font-style:italic">A</span> &#X2212;&gt; <span style="font-style:italic">B</span></span>:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> ---(========)----- A
<font color="#000000">3:</font> ===)--------(===== NOT A
<font color="#000000">4:</font> ---------(=====)-- B
<font color="#000000">5:</font> [Extend B to everything that doesn't include
<font color="#000000">6:</font>   more of A than already included]
<font color="#000000">7:</font> ===)-----(======== NOT A or B = A -&gt; B
<font color="#000000">8:</font> </tt></pre>
</div>

<h4><a id=contained-in- href='#contained-in-'> § </a> <code>a -> b</code> as <code>a</code> contained in <code>b</code>:</h4>
We'll show that <code>a -> b</code> is true/top/the full real line if and only if
<code>a</code> is contained in <code>b</code>. We can show this using <span class='latexinline'>
&#XAC; <span style="font-style:italic">a</span> &#X2228; <span style="font-style:italic">b</span></span> definition:
<ol>
<li>
 <span class='latexinline'>
<span style="font-style:italic">a</span> &#X2264; <span style="font-style:italic">b</span></span> (given)
</li>
<li>
 Since <span class='latexinline'>
<span style="font-style:italic">a</span> &#X2264; <span style="font-style:italic">b</span></span>, <span class='latexinline'>
&#XAC; <span style="font-style:italic">a</span> &#X2265; &#XAC; <span style="font-style:italic">b</span></span>, since <span class='latexinline'>
&#XAC;</span> reverses inclusion order.
</li>
<li>
 <span class='latexinline'>
<span style="font-style:italic">x</span> &#X2265; <span style="font-style:italic">y</span></span> implies that <span class='latexinline'>
<span style="font-style:italic">x</span> &#X2228; <span style="font-style:italic">p</span> &#X2265; <span style="font-style:italic">y</span> &#X2228; <span style="font-style:italic">p</span></span> for all p, since <span class='latexinline'>
<span style="font-style:italic">p</span></span> is 
   on both sides.
</li>
<li>
 Specializing to <span class='latexinline'>
<span style="font-style:italic">x</span> = &#XAC; <span style="font-style:italic">a</span></span>, <span class='latexinline'>
<span style="font-style:italic">y</span> = &#XAC; <span style="font-style:italic">b</span></span>, <span class='latexinline'>
<span style="font-style:italic">p</span> = <span style="font-style:italic">b</span></span> gives us
   <span class='latexinline'>
&#XAC; <span style="font-style:italic">a</span> &#X2228; <span style="font-style:italic">b</span> &#X2265; &#XAC; <span style="font-style:italic">b</span> &#X2228; <span style="font-style:italic">b</span></span>
</li>
<li>
 <span class='latexinline'>
&#XAC; <span style="font-style:italic">b</span> &#X2228; <span style="font-style:italic">b</span></span> is universe <span class='latexinline'>
<span style="font-style:italic">U</span></span>
</li>
<li>
 <span class='latexinline'>
&#XAC; <span style="font-style:italic">a</span> &#X2228; <span style="font-style:italic">b</span> &#X2265; <span style="font-style:italic">U</span></span>, which means it's equal to <span class='latexinline'>
<span style="font-style:italic">U</span></span> (nothing can be greater than <span class='latexinline'>
<span style="font-style:italic">U</span></span>).
</li>

</ol>

We can also show this geometrically:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> ----------(===)---- A
<font color="#000000">3:</font> ------(==========) B
<font color="#000000">4:</font> ----------(===)---- A &amp;&amp; B
<font color="#000000">5:</font> [Extend B to everything that doesn't include
<font color="#000000">6:</font>   more of A than already included.
<font color="#000000">7:</font>   But all of A is
<font color="#000000">8:</font>   already included!]
<font color="#000000">9:</font> ================== A -&gt; B
<font color="#000000">10:</font> </tt></pre>
</div>

<h4><a id=as-containment href='#as-containment'> § </a> reading <code>curry</code>, <code>uncurry</code> using <code>a -> b</code> as containment:</h4>
<code>curry</code>, <code>uncurry</code> are the adjunction/isomorphism:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> ((c,a) -&gt; b) ~ (c -&gt; (a -&gt; b))
<font color="#000000">3:</font> </tt></pre>
</div>

Read this as:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> ( c     ,         a)     -&gt;         b
<font color="#000000">3:</font> (c `intersection` a) `contained in` b
<font color="#000000">4:</font> </tt></pre>
</div>

if and only if
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> c      -&gt;        (a       -&gt;      b)
<font color="#000000">3:</font> c `contained in` (a `implication` b)
<font color="#000000">4:</font> </tt></pre>
</div>

That is, we have "read" <code>curry/uncurry</code> as:
<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">c</span>&#XA0;&#X2227;&#XA0;<span style="font-style:italic">a</span>&#XA0;&#X2264;&#XA0;<span style="font-style:italic">b</span>&#XA0;&#XA0;&#X21D0;&#X21D2;&#XA0;<span style="font-style:italic">c</span>&#XA0;&#X2264;&#XA0;<span style="font-style:italic">a</span>&#XA0;&#X21D2;&#XA0;<span style="font-style:italic">b</span>
</td></tr>
</table></div>
which was the definition of <span class='latexinline'>
&#X21D2;</span> we wanted!
<h4><a id=references href='#references'> § </a> References</h4>
<ul>
<li>
 <a href=https://mail.haskell.org/pipermail/haskell-cafe/2020-May/132297.html>
Email by Olaf Klinke on haskell-cafe</a>

</li>

</ul>

<h2><a id=edit-distance href='#edit-distance'> § </a> <a href=#edit-distance>
Edit distance</a>
</h2>
This implementation of edit distance crystallizes the fact that when computing
edit distance, we only ever move forwards on solving the problem. we <i>do not</i>
store the results of the overlapping computations, though we could. Rather,
the goal of this implementation is to capture the traversal pattern necessary
for edit distance into a <code>Cursor</code>, and to view the edit distance problem from
the point of view of this <code>Cursor</code>. 
The problem setting is that we have a source string, a destination
string, and we wish to perform operations that convert the source
string into the destination string. The operations allowed are to:
<ul>
<li>
 Insert a character from the destination to the source.
</li>
<li>
 Remove a character from the source.
</li>
<li>
 Replace a character in the source with a character from the destination.
</li>

</ul>

We want to minimise the number of operations to be used. 
Let's see how we model this.
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> <i><font color="#222222">{-# LANGUAGE ViewPatterns #-}</font></i>
<font color="#000000">3:</font> <b><u><font color="#000000">type</font></u></b> <b><font color="#000000">Ix</font></b> = <b><font color="#000000">Int</font></b>; <b><u><font color="#000000">type</font></u></b> <b><font color="#000000">DestIx</font></b> = <b><font color="#000000">Ix</font></b>; <b><u><font color="#000000">type</font></u></b> <b><font color="#000000">SrcIx</font></b> = <b><font color="#000000">Ix</font></b>;
<font color="#000000">4:</font> <b><u><font color="#000000">data</font></u></b> <b><font color="#000000">Move</font></b> = <b><font color="#000000">InsertFromDest</font></b> <b><font color="#000000">DestIx</font></b> |
<font color="#000000">5:</font>             <b><font color="#000000">RemoveFromSrc</font></b> <b><font color="#000000">SrcIx</font></b> |
<font color="#000000">6:</font>             <b><font color="#000000">ReplaceSrcWithDest</font></b> <b><font color="#000000">SrcIx</font></b> <b><font color="#000000">DestIx</font></b>
<font color="#000000">7:</font>         <b><u><font color="#000000">deriving</font></u></b>(<b><font color="#000000">Show</font></b>)
<font color="#000000">8:</font> </tt></pre>
</div>

Our cost model says that each move costs <code>1</code>. We are charged for every
move we make. We are to minimize the number of operations.
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> movescost :: [<b><font color="#000000">Move</font></b>] -&gt; <b><font color="#000000">Int</font></b>; movescost = length
<font color="#000000">3:</font> </tt></pre>
</div>

We model this as us having a <code>Cursor</code> which contains  list <code>[a]</code> and information
about where we are in the list as an <code>Ix</code>. 
This is the same as a <code>Zipper</code> for a list, except that in this case, we only
allow ourselves to walk forward. 
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> <b><u><font color="#000000">data</font></u></b> <b><font color="#000000">Cursor</font></b> a = <b><font color="#000000">Cursor</font></b> <b><font color="#000000">Ix</font></b> [a]
<font color="#000000">3:</font> </tt></pre>
</div>

<ul>
<li>
 <code>cdone</code> tells is if we have completely consumed a cursor.
</li>
<li>
 <code>cix</code> tells us the index of the cursor.
</li>
<li>
 <code>cval</code> lets us dereference a cursor.
</li>
<li>
 <code>incr</code> lets us move a cursor to the next array entry.
</li>
<li>
 <code>cursor</code> converts a list into a <code>Cursor</code> at the first index.
</li>

</ul>

<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> cdone :: <b><font color="#000000">Cursor</font></b> a -&gt; <b><font color="#000000">Bool</font></b>; cdone (<b><font color="#000000">Cursor</font></b> ix vs) = ix &gt;= length vs
<font color="#000000">3:</font> cix :: <b><font color="#000000">Cursor</font></b> a -&gt; <b><font color="#000000">Ix</font></b>; cix (<b><font color="#000000">Cursor</font></b> ix <b><u><font color="#000000">_</font></u></b>) = ix
<font color="#000000">4:</font> cval :: <b><font color="#000000">Cursor</font></b> a -&gt; a; cval c@(<b><font color="#000000">Cursor</font></b> ix vs) = vs !! ix
<font color="#000000">5:</font> incr :: <b><font color="#000000">Cursor</font></b> a -&gt; <b><font color="#000000">Cursor</font></b> a; incr (<b><font color="#000000">Cursor</font></b> ix vs) = <b><font color="#000000">Cursor</font></b> (ix+<font color="#000000">1</font>) vs
<font color="#000000">6:</font> cursor :: [a] -&gt; <b><font color="#000000">Cursor</font></b> a; cursor = <b><font color="#000000">Cursor</font></b> <font color="#000000">0</font>
<font color="#000000">7:</font> </tt></pre>
</div>

We implement <code>edit</code>, that tells us how to edit the source string into
the destination string. The convention is <code>edit <src-str> <dest-str></code>.
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> <i><font color="#222222">-- | decide how to get ixth character of bs from our as.</font></i>
<font color="#000000">3:</font> edit :: <b><font color="#000000">Eq</font></b> a =&gt; <b><font color="#000000">Cursor</font></b> a -&gt; <b><font color="#000000">Cursor</font></b> a -&gt; [<b><font color="#000000">Move</font></b>]
<font color="#000000">4:</font> </tt></pre>
</div>

<ul>
<li>
 1. If both strings have been consumed, then no moves are to be made.
</li>

</ul>

<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> edit (cdone -&gt; <b><font color="#000000">True</font></b>) (cdone -&gt; <b><font color="#000000">True</font></b>) = []
<font color="#000000">3:</font> </tt></pre>
</div>

<ul>
<li>
 2. If the destination string has been fully matched while the source string
   has not, then remove characters from the source string.
</li>

</ul>

<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> edit a@(cdone -&gt; <b><font color="#000000">False</font></b>) b@(cdone -&gt; <b><font color="#000000">True</font></b>) = 
<font color="#000000">3:</font>   (<b><font color="#000000">RemoveFromSrc</font></b> (cix a)):edit (incr a) b
<font color="#000000">4:</font> </tt></pre>
</div>

<ul>
<li>
 3. If the source string has run out of characters while the destination string
   still has characters, insert characters from the destination string.
</li>

</ul>

<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> edit a@(cdone -&gt; <b><font color="#000000">True</font></b>) b@(cdone -&gt; <b><font color="#000000">False</font></b>) = 
<font color="#000000">3:</font>   (<b><font color="#000000">InsertFromDest</font></b> (cix b)):edit a (incr b)
<font color="#000000">4:</font> </tt></pre>
</div>

<ul>
<li>
 4. Otherwise, we have characters remaining in both strings. Try the
   options of (1) replacing a source character with a destination 
   character (2) removing a character from the source and continuing,
   and (3) if the current characters match, then keep the match and try
   to combine characters that come later in the string. We pick the
   best out of these using the <code>argmin</code> combinator.
</li>

</ul>

<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> edit a b =  
<font color="#000000">3:</font>   <b><u><font color="#000000">let</font></u></b> nomatch = argmin movescost 
<font color="#000000">4:</font>                 (<b><font color="#000000">ReplaceSrcWithDest</font></b> (cix a) (cix b):edit (incr a) (incr b))
<font color="#000000">5:</font>                 (<b><font color="#000000">RemoveFromSrc</font></b> (cix a):edit (incr a) b) 
<font color="#000000">6:</font>   <b><u><font color="#000000">in</font></u></b> <b><u><font color="#000000">case</font></u></b> cval a == cval b <b><u><font color="#000000">of</font></u></b>
<font color="#000000">7:</font>       <b><font color="#000000">True</font></b> -&gt; argmin movescost nomatch (edit (incr a) (incr b))
<font color="#000000">8:</font>       <b><font color="#000000">False</font></b> -&gt; nomatch 
<font color="#000000">9:</font> </tt></pre>
</div>

      
The helper used for finding minimum according to a cost model.
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> argmin :: (a -&gt; <b><font color="#000000">Int</font></b>) -&gt; a -&gt; a -&gt; a
<font color="#000000">3:</font> argmin f a a' = if (f a) &lt; (f a') <b><u><font color="#000000">then</font></u></b> a <b><u><font color="#000000">else</font></u></b> a'
<font color="#000000">4:</font> </tt></pre>
</div>

<h2><a id=evolution-of-bee-colonies href='#evolution-of-bee-colonies'> § </a> <a href=#evolution-of-bee-colonies>
Evolution of bee colonies</a>
</h2>
This kind of culture that beehives have is called as 'eusociality'.
I'm interested in this because I want to understand what alien societies might
look like, and what selection pressures are required to have bee-like societies
evolve. Many sci-fi books (Ender's game for example) depict aliens with such
a society, but tend to be hazy on how this state of affairs came to be.
<ul>
<li>
 <a href=https://en.wikipedia.org/wiki/Evolution_of_eusociality>
Evolution of eusociality</a>

</li>

</ul>

<h2><a id=best-practices-for-array-indexing href='#best-practices-for-array-indexing'> § </a> <a href=#best-practices-for-array-indexing>
Best practices for array indexing</a>
</h2>
These are rules I'm going to follow when I solve problems on 
<a href=https://codeforces.com/>
codeforces</a>
. I've arrived at these rules by repeatedly
noticing the kinds of mistakes I make and attempting to adopt conventions
to eliminate these.
<h4><a id=rule-1-half-open-intervals href='#rule-1-half-open-intervals'> § </a> Rule 1: Half-open intervals</h4>
Intervals are only represented as <code>[begin, past-the-end)</code> That is, we start at
<code>begin</code>, include numbers <code>begin+1, begin+2, ...</code>, upto, <b>but excluding</b>
<code>past-the-end</code>.
So, for example, <code>[0, 3) = [0, 1, 2]</code>, while <code>[0, 1) = [0]</code>, and <code>[0, 0) = []</code>.
I am not allowed to use <code>[begin, end]</code>, or <code>(before-begin, past-the-end)</code> or
any such variation I represent and think of intervals.
<h4><a id=loopsledo-whileonal-operators-when-using- href='#loopsledo-whileonal-operators-when-using-'> § </a> Rule 2: No relational operators when using <code>for/while/do while</code> loops.</h4>
When I write my loop conditions, I am not allowed to use relational operators.
I must only write <code>i != n</code> or <code>i == m</code>.
I am not allowed to write <code>i < n</code>, <code>i <= n</code>, <code>i > n</code>, <code>i >= n</code> for my <code>for</code> loops.
<h4><a id=rule-3-the-loop-iterator-lives-in-getting-to-space href='#rule-3-the-loop-iterator-lives-in-getting-to-space'> § </a> Rule 3: The loop iterator lives in "getting to" space:</h4>
The loop iterator <code>i</code> in <code>for(int i = a; i != b; ++i)</code> is to be thought of as
getting to/living right before" the values <code>[a, a+1, a+2, ... b-1]</code>. In
ASCII-art:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> || a-1 || a   || a+1 || ... || b-1 ||  b  || b+1 ||
<font color="#000000">3:</font>        ^^     ^^     ^^            ^^
<font color="#000000">4:</font>      (i=a) (i=a+1)  (i=a+2) ...   (i=b)
<font color="#000000">5:</font> </tt></pre>
</div>

<h4><a id=ruel-4-one-always-reads-loops-according-to-the-above-rules href='#ruel-4-one-always-reads-loops-according-to-the-above-rules'> § </a> Ruel 4: One always reads loops according to the above rules</h4>
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> <b><u><font color="#000000">for</font></u></b>(<b><font color="#000000">int</font></b> i = begin; i != past-the-end; ++i) {
<font color="#000000">3:</font>   <i><font color="#222222">// NO: i from begin to past-the-end.</font></i>
<font color="#000000">4:</font>   <i><font color="#222222">// YES: [i _getting to_ the beginning] till [i _getting_ past-the-end]</font></i>
<font color="#000000">5:</font> }
<font color="#000000">6:</font> </tt></pre>
</div>

<h4><a id=the-rationale-for-banning-relational-operators href='#the-rationale-for-banning-relational-operators'> § </a> The rationale for banning relational operators</h4>
There is a strong difference in qualia between <code>i < n</code> and <code>i != n</code>. The former
makes on aware of when the loop runs; the latter of when the loop quits.
I wish to be cognizant of the precisely when a loop quits. 
On writing <code>i != past-the-end</code>, I know that we quit as soon as we
<b>get past the end</b>. This feels much clearer than being aware that the loops
runs as long as <code>i < n</code>.
<h4><a id=indexpen-indexing-length- href='#indexpen-indexing-length-'> § </a> half-open indexing: length <-> index</h4>
The first advantage of these conventions is that 
<code>[begin, past-the-end)</code> is the same as <code>[begin, begin+length)</code>. I've found this
to be of great help to flit between length-based-thoughts and
indexing-based-thoughts.
<h4><a id=lengthpen-indexing- href='#lengthpen-indexing-'> § </a> half-open indexing: <code>0</code> length</h4>
The second almost trivial point is that <code>[begin, begin+length)</code> holds when
<code>length</code> is <b>zero</b>. That is,
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> <b><u><font color="#000000">for</font></u></b>(<b><font color="#000000">int</font></b> i = begin; i != begin + <font color="#000000">0</font>; ++ i) { ... }
<font color="#000000">3:</font> </tt></pre>
</div>

does the right thing and iterates over no elements.
<h4><a id=lengthpen-indexing- href='#lengthpen-indexing-'> § </a> half-open indexing: <code>-ve</code> length</h4>
The third neat point is that <code>[begin, begin+length)</code> holds even when <code>length</code>
is <b>negative</b>. Hence, if we want to index the last two elements of an
array, we recall that we start from index <code>(n-1)</code>, and we want a segment
of length <code>-2</code> from there, so our loop is:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> <b><u><font color="#000000">for</font></u></b>(<b><font color="#000000">int</font></b> i = n-<font color="#000000">1</font>; i != (n-<font color="#000000">1</font>) + -<font color="#000000">2</font>; i--) {
<font color="#000000">3:</font>  <i><font color="#222222">// loops over the correct segment.</font></i>
<font color="#000000">4:</font> }
<font color="#000000">5:</font> </tt></pre>
</div>

<h4><a id=half-open-indexing-splitting-an-array href='#half-open-indexing-splitting-an-array'> § </a> half-open indexing: splitting an array</h4>
Finally, this convention helps when attempting to take the beginning part
of a list and the rest of the list. If we want to split an array into
two segments at some index <code>len</code>,
<ul>
<li>
 The first sub-array is <code>[0, len)</code> since it starts at location <code>0</code> and has
  length <code>len</code>.
</li>
<li>
 Since we have taken <code>len</code> elements, the second sub-array must have length
  <code>n-len</code>. It must start at index <code>len</code> since <code>len</code> is past-the-end for the
  first sub-array. So, the second sub-array has indeces <code>[len, n-len)</code>.
</li>

</ul>

Notice how we used <i>both</i> the "length view" and the "past the end" view to
quickly derive the bounds of the second array from the first array.
<h4><a id=half-open-indexing-uniformly-generate-power-of-2-intervals href='#half-open-indexing-uniformly-generate-power-of-2-intervals'> § </a> half-open indexing: uniformly generate power-of-2 intervals.</h4>
If we want intervals of length <span class='latexinline'>
2<sup><span style="font-style:italic">n</span></sup></span>: <code>1, 2, 4, 8, ...</code> which is common if one
is building data structures such as segment trees and fenwick trees, 
in a half-open representation, this literally becomes <code>[a, a+1)</code>, 
<code>[a, a+2)</code>, <code>[a, a+4)</code> and so on. On the other hand, if one wants
to use closed interval based indexing, one needs to generate the
series <span class='latexinline'>
2<sup><span style="font-style:italic">n</span></sup> &#X2212; 1</span>, which is <code>[a, a+0]</code>, <code>[a, a+3]</code>, <code>[a, a+7]</code> which is
slightly more finicky.
<h4><a id=how-to-deal-with-strides href='#how-to-deal-with-strides'> § </a> How to deal with strides</h4>
If there's a loop
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> <b><u><font color="#000000">for</font></u></b>(<b><font color="#000000">int</font></b> i = <font color="#000000">0</font>; i &lt; <font color="#000000">5</font>; i += <font color="#000000">2</font>) { ... }
<font color="#000000">3:</font> </tt></pre>
</div>

the naive <code>i != 5</code> translation will not work since <code>i</code> only takes
on even numbers <code>[0, 2, 4, 6, ...]</code>. For this, we can perform a
simple transformation and always make sure our loop variables increment
by <code>1</code>. In a compiler, this is often called as "canonicalizing the loop
induction variable". In LLVM the canonicalization is
<a href=https://llvm.org/docs/Passes.html#indvars-canonicalize-induction-variables>
performed by the <code>-indvars</code> pass</a>
.
The above example canonicalized becomes:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> <i><font color="#222222">// btc = backedge taken count. How many times we have</font></i>
<font color="#000000">3:</font> <i><font color="#222222">// gone past the "back edge" of the loop to go back to the</font></i>
<font color="#000000">4:</font> <i><font color="#222222">// beginning of the loop.</font></i>
<font color="#000000">5:</font> <b><u><font color="#000000">for</font></u></b>(<b><font color="#000000">int</font></b> btc = <font color="#000000">0</font>; btc != <font color="#000000">5</font> / <font color="#000000">2</font>; btc += <font color="#000000">1</font>) { <b><u><font color="#000000">const</font></u></b> <b><font color="#000000">int</font></b> i = btc * <font color="#000000">2</font>; }
<font color="#000000">6:</font> </tt></pre>
</div>

<h4><a id=in-conclusion href='#in-conclusion'> § </a> In conclusion</h4>
These are rules that I dreamed up after noticing my idiosyncracies in
loop-writing.
<h2><a id=algebraic-structure-for-vector-clocks href='#algebraic-structure-for-vector-clocks'> § </a> Algebraic structure for vector clocks</h2>
<i>I</i> update my time, ie, union(time me, time me), I get an element that's one up the lattice.
When I union with someone else, I get the max. So we have an algebraic structure
which is <span class='latexinline'>
(<span style="font-style:italic">L</span>, &#X2264;, <span style="font-style:italic">next</span>: <span style="font-style:italic">L</span> &#X2192; <span style="font-style:italic">L</span>)</span> where <code>next</code> is monotone for <code>(L, <=)</code>.
The  induced union operator <span class='latexinline'>
&#X222A;: <span style="font-style:italic">L</span> &#XD7; <span style="font-style:italic">L</span> &#X2192; <span style="font-style:italic">L</span></span> is:
<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">x</span>&#XA0;&#X22C3;&#XA0;<span style="font-style:italic">y</span>&#XA0;&#X2261;&#XA0;</td><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell">&#X23A7;<br>
&#X23A8;<br>
&#X23A9;</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">next</span>(<span style="font-style:italic">x</span>)</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">x</span>&#XA0;=&#XA0;<span style="font-style:italic">y</span>&#XA0;&#XA0;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">max</span>(<span style="font-style:italic">x</span>,&#XA0;<span style="font-style:italic">y</span>)</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">x</span>&#XA0;&#X2260;&#XA0;<span style="font-style:italic">y</span>&#XA0;</td></tr>
</table></td></tr>
</table></td></tr>
</table></div>
<ul>
<li>
 Is the total ordering on vector clocks <i>not</i> isomorphic to the total ordering on <span class='latexinline'>
&#X211D;</span>?
</li>

</ul>

This also shows up in the case of the "Gallager-Humblet-Spira Algorithm" and
the fragment-name-union-rule.
<h2><a id=networks-are-now-faster-than-disks href='#networks-are-now-faster-than-disks'> § </a> <a href=#networks-are-now-faster-than-disks>
Networks are now faster than disks</a>
</h2>
I learnt of this counter-intutive fact first from this
<a href=https://www.usenix.org/legacy/publications/login/2011-10/openpdfs/Burd.pdf>
usenix article no SQL</a>
.
On checking up, it seems to actually be true. 
<a href=https://research.cs.cornell.edu/ladis2009/talks/dean-keynote-ladis2009.pdf>
Jeff Dean's keynote at LADIS 2009</a>
 report these numbers:
<ul>
<li>
 Round trip within same datacenter: 500,000 ns
</li>
<li>
 Disk seek: 10,000,000 ns [regular disk]
</li>

</ul>

On the other hand, a commentor on <a href=https://serverfault.com/questions/238417/are-networks-now-faster-than-disks>
this discussion at serverfault</a>

mentioned that SSDs might be much faster, and the numbers bear out:
<ul>
<li>
 Read 4K randomly from SSD: 150,000 ns
</li>
<li>
 Round trip within same datacenter: 500,000 ns
</li>
<li>
 Disk seek: 10,000,000 ns [regular disk]
</li>

</ul>

<h2><a id=einstein-de-haas-effect href='#einstein-de-haas-effect'> § </a> <a href=#einstein-de-haas-effect>
Einstein-de Haas effect</a>
</h2>
I learnt of this from hacker news. This is some crazy experiment that shows
that the 'quantum angular momentum' (spin) and the 'classical angular momentum'
need to be conserved <i>together</i> for physics to work out:
<blockquote> There's an experiment that transfers that angular momentum all the way up to macroscopic levels. By magnetizing a cylinder of iron, all the spins start pointing in the same direction. By conservation of angular momentum, the cylinder itself has to start spinning in the opposite direction. I'm very fond of this experiment, because it magnifies a strange quantum phenomenon to the classical level.</blockquote>
So, my understanding of the experiment is:
<ul>
<li>
 classical angular momentum and quantum angular momentum are related.
</li>
<li>
 quantum angular momentum is decomposed into spin and orbital angular momentum.
</li>
<li>
 for something like iron, spin is 96% of magnetization
</li>
<li>
 angular momentum is proportional to magnetization
</li>
<li>
 So, the experiment measures the <i>spin</i> (mostly) in terms of the classical
  spinning of the cylinder.
</li>

</ul>

<h4><a id=references href='#references'> § </a> References</h4>
<ul>
<li>
 <a href=https://en.m.wikipedia.org/wiki/Einstein%E2%80%93de_Haas_effect>
Einstein-de Hass effect on Wikipedia</a>

</li>

</ul>

<h2><a id=rank-select-as-adjunction href='#rank-select-as-adjunction'> § </a> <a href=#rank-select-as-adjunction>
Rank-select as adjunction</a>
</h2>
We will introduce two operations <code>rank</code>, <code>select</code>, --- these are used to
build memory-efficient data structures that can still be queried quickly.
We will show how <code>rank</code> and <code>select</code> are adjoint. This will also us to also
consider <code>coselect</code>, which is a variation of <code>select</code> that is not commonly
discussed.
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> <i><font color="#222222">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</font></i>
<font color="#000000">03:</font> 
<font color="#000000">04:</font> <b><u><font color="#000000">import</font></u></b> Data.<b><font color="#000000">List</font></b>
<font color="#000000">05:</font> <b><u><font color="#000000">newtype</font></u></b> <b><font color="#000000">Count</font></b> = <b><font color="#000000">Count</font></b> <b><font color="#000000">Int</font></b> <b><u><font color="#000000">deriving</font></u></b>(<b><font color="#000000">Eq</font></b>, <b><font color="#000000">Show</font></b>, <b><font color="#000000">Ord</font></b>, <b><font color="#000000">Num</font></b>)
<font color="#000000">06:</font> <b><u><font color="#000000">newtype</font></u></b> <b><font color="#000000">Ix</font></b> = <b><font color="#000000">Ix</font></b> <b><font color="#000000">Int</font></b> <b><u><font color="#000000">deriving</font></u></b>(<b><font color="#000000">Eq</font></b>, <b><font color="#000000">Show</font></b>, <b><font color="#000000">Ord</font></b>, <b><font color="#000000">Num</font></b>)
<font color="#000000">07:</font> 
<font color="#000000">08:</font> 
<font color="#000000">09:</font> eqscan :: <b><font color="#000000">Eq</font></b> a =&gt; a -&gt; [a] -&gt; [<b><font color="#000000">Count</font></b>]
<font color="#000000">10:</font> eqscan a0 as = map <b><font color="#000000">Count</font></b> $ scanl (+) <font color="#000000">0</font> [<b><u><font color="#000000">if</font></u></b> a0 == a <b><u><font color="#000000">then</font></u></b> <font color="#000000">1</font> <b><u><font color="#000000">else</font></u></b> <font color="#000000">0</font> | a &lt;- as]
<font color="#000000">11:</font> 
<font color="#000000">12:</font> <i><font color="#222222">-- | finds the index `Ix` in `as` at which `a` has occured</font></i>
<font color="#000000">13:</font> <i><font color="#222222">-- | for the `Count`th time.</font></i>
<font color="#000000">14:</font> select :: <b><font color="#000000">Eq</font></b> a =&gt; a -&gt; [a] -&gt; <b><font color="#000000">Count</font></b> -&gt; <b><font color="#000000">Maybe</font></b> <b><font color="#000000">Ix</font></b>
<font color="#000000">15:</font> select a0 as c = <b><font color="#000000">Ix</font></b> &lt;$&gt; findIndex (== c) (eqscan a0 as)
<font color="#000000">16:</font> 
<font color="#000000">17:</font> <i><font color="#222222">-- | finds the number of times `a` has occured in `as` till `Ix`.</font></i>
<font color="#000000">18:</font> rank :: <b><font color="#000000">Eq</font></b> a =&gt; a -&gt; [a] -&gt; <b><font color="#000000">Ix</font></b> -&gt; <b><font color="#000000">Count</font></b>
<font color="#000000">19:</font> rank a as (<b><font color="#000000">Ix</font></b> ix) = (eqscan a as) !! ix
<font color="#000000">20:</font> </tt></pre>
</div>

Given this, we can prove that <code>select</code> and <code>rank</code> are adjunctions. There
are different ways to think about this. My favourite way to is to notice
that an <code>Ix</code> (index) is much "finer" information than <code>Count</code>. Hence,
the concrete domain must be <code>Ix</code>, the abstract domain must be <code>Count</code>,
and rank-select is an abstract interpretation!
<h4><a id=co-select href='#co-select'> § </a> Co-select</h4>
We can build another version of <code>select</code> called <code>co-select</code> that scans
from the right. Alternatively, it finds on the reverse list:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> coselect :: Eq a =&gt; a -&gt; [a] -&gt; Count -&gt; Maybe Ix
<font color="#000000">3:</font> coselect a0 as c = Ix &lt;$&gt; findIndex (== c) (reverse (eqscan a0 as))
<font color="#000000">4:</font> </tt></pre>
</div>

Thanks to Edward Kmett for teaching me this.
<h2><a id=bounding-chains-uniformly-sample-colorings href='#bounding-chains-uniformly-sample-colorings'> § </a> <a href=#bounding-chains-uniformly-sample-colorings>
Bounding chains: uniformly sample colorings</a>
</h2>
We wish to <i>uniformly sample</i> <code>k</code> colorings of a graph <span class='latexinline'>
<span style="font-style:italic">G</span></span> with maximum degree
<span class='latexinline'>
&#X394;</span>. Hence, we require <span class='latexinline'>
<span style="font-style:italic">k</span> &#X2265; &#X394; + 1</span>. To perform this sampling,
we use MCMC to sample from a markov chain whose states are <span class='latexinline'>
<span style="font-style:italic">k</span></span>-colorings of <span class='latexinline'>
<span style="font-style:italic">G</span></span>,
whose stationary distribution is the uniform distribution over valid colorings.
The issue with MCMC techniques is that we never know when our chain has reached
the stationary state. To ensure we receive uniformly distributed samples,
we built a "bounding chain" <span class='latexinline'>
<span style="font-style:italic">W</span></span> which has the following properties:
<ul>
<li>
 States of <span class='latexinline'>
<span style="font-style:italic">W</span></span> cover states of <span class='latexinline'>
<span style="font-style:italic">X</span></span> [ie, state space of <span class='latexinline'>
<span style="font-style:italic">W</span></span> are subsets of the state space of <span class='latexinline'>
<span style="font-style:italic">X</span></span>].
</li>
<li>
 <span class='latexinline'>
<span style="font-style:italic">W</span></span>'s convergence to a stationary state can be checked.
</li>
<li>
 Upon convergence of <span class='latexinline'>
<span style="font-style:italic">W</span></span>, state of <span class='latexinline'>
<span style="font-style:italic">W</span></span> = state of <span class='latexinline'>
<span style="font-style:italic">X</span></span>.
</li>

</ul>

We will in fact run the <span class='latexinline'>
<span style="font-style:italic">W</span></span> chain, and prove that running the <span class='latexinline'>
<span style="font-style:italic">W</span></span> chain
is equivalent to running a 'shadow' of the <span class='latexinline'>
<span style="font-style:italic">X</span></span> chain, and that stationary
states of the <span class='latexinline'>
<span style="font-style:italic">W</span></span> chain correspond to stationary sates of the <span class='latexinline'>
<span style="font-style:italic">X</span></span> chain.
Let <span class='latexinline'>
<span style="font-style:italic">X</span></span> be the chain whose states are valid <span class='latexinline'>
<span style="font-style:italic">k</span></span> colorings of <span class='latexinline'>
<span style="font-style:italic">G</span></span>. In one step
of the chain <span class='latexinline'>
<span style="font-style:italic">X</span></span>, we choose a vertex <span class='latexinline'>
<span style="font-style:italic">v</span></span> uniformly at random; we then choose a
color <span class='latexinline'>
<span style="font-style:italic">c</span>&#X2032;<sub><span style="font-style:italic">v</span></sub></span> uniformly at random for <span class='latexinline'>
<span style="font-style:italic">v</span></span> that makes it a proper coloring. The vertex
<span class='latexinline'>
<span style="font-style:italic">v</span></span> is changed to this new color <span class='latexinline'>
<span style="font-style:italic">c</span>&#X2032;</span>. This is a symmetric proposal distribution,
Hence this chain has the uniform distribution over <span class='latexinline'>
<span style="font-style:italic">k</span></span>-colorings to be
the stationary state.
Sampling exactly from this chain is hard: construct an initial state <span class='latexinline'>
<span style="font-style:italic">X</span><sub>0</sub></span>
amounts to finding some valid <span class='latexinline'>
<span style="font-style:italic">k</span></span> coloring which in itself might be
challenging. Worse, we do not know whether the chain <span class='latexinline'>
<span style="font-style:italic">X</span></span> has reached a
stationary state or not.
<h4><a id=bounding-chain href='#bounding-chain'> § </a> Bounding Chain</h4>
We construct a new chain <span class='latexinline'>
<span style="font-style:italic">W</span></span> (the bounding chain of <span class='latexinline'>
<span style="font-style:italic">X</span></span>), whose states are <i>sets of colors</i> for
vertices in <span class='latexinline'>
<span style="font-style:italic">G</span></span>. Formally, the states of <span class='latexinline'>
<span style="font-style:italic">W</span></span> are functions <span class='latexinline'>
<span style="font-style:italic">Vert</span>(<span style="font-style:italic">G</span>) &#X2192; 2<sup><span style="font-style:italic">C</span></sup></span> where
<span class='latexinline'>
<span style="font-style:italic">Vert</span>(<span style="font-style:italic">G</span>)</span> denotes the vertices of <span class='latexinline'>
<span style="font-style:italic">G</span></span>; <span class='latexinline'>
<span style="font-style:italic">C</span></span> the set of colors. The transition
will be to pick a vertex <span class='latexinline'>
<span style="font-style:italic">v</span></span> uniformly at random. Then, pick a new set of
legal colors <span class='latexinline'>
<span style="font-style:italic">C</span>&#X2032;<sub><span style="font-style:italic">v</span></sub></span> for <span class='latexinline'>
<span style="font-style:italic">v</span></span>, such that:
<ul>
<li>
 It is guaranteed that if <span class='latexinline'>
<span style="font-style:italic">X</span></span> were transitioning on <span class='latexinline'>
<span style="font-style:italic">v</span></span>, the
  color <span class='latexinline'>
<span style="font-style:italic">c</span>&#X2032;<sub><span style="font-style:italic">v</span></sub></span> that would be picked by <span class='latexinline'>
<span style="font-style:italic">X</span></span> for <span class='latexinline'>
<span style="font-style:italic">v</span></span> is a member of <span class='latexinline'>
<span style="font-style:italic">C</span>&#X2032;<sub><span style="font-style:italic">v</span></sub></span>. [state is covered]
</li>
<li>
 The size of the set <span class='latexinline'>
<span style="font-style:italic">C</span>&#X2032;<sub><span style="font-style:italic">v</span></sub></span> attempts to be smaller than the current set of colorings <span class='latexinline'>
<span style="font-style:italic">C</span><sub><span style="font-style:italic">v</span></sub></span>. [convergence]
</li>

</ul>

We describe the transition function next. But first, we need an alternate
lens on the transitions of <span class='latexinline'>
<span style="font-style:italic">X</span></span> that is amenable to massaging. 
<h4><a id=equivalent-description-of-the-transitions-of- href='#equivalent-description-of-the-transitions-of-'> § </a> Equivalent description of the transitions of <span class='latexinline'>
<span style="font-style:italic">X</span></span>:</h4>
<ol>
<li>
 Choosing a color uniformly at random from the set of valid colors
   for a vertex.
</li>
<li>
 Choosing colors from <span class='latexinline'>
<span style="font-style:italic">C</span></span> without replacement until we get a color 
   that is a valid color. 
</li>

</ol>

We claim that (1) and (2) have the same probability distribution.
Abstracting slightly, we state:
<ol>
<li>
 Probability of choosing an element <span class='latexinline'>
<span style="font-style:italic">t</span> &#X2208; <span style="font-style:italic">T</span></span> uniformly from  <span class='latexinline'>
<span style="font-style:italic">T</span> &#X2286; <span style="font-style:italic">S</span></span>.
   This has probability <span class='latexinline'>
1/|<span style="font-style:italic">T</span>|</span>.
</li>
<li>
 Probability of choosing a particular element <span class='latexinline'>
<span style="font-style:italic">t</span> &#X2208; <span style="font-style:italic">T</span></span>, by picking elements
   from <span class='latexinline'>
<span style="font-style:italic">S</span></span> without replacement until we get some element in <span class='latexinline'>
<span style="font-style:italic">T</span></span>.
</li>

</ol>

(1) and (2) have the same probability distribution.
<h4><a id=proof-by-induction href='#proof-by-induction'> § </a> Proof by induction:</h4>
Process (2) in code is the following:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> <b><u><font color="#000000">def</font></u></b> process(S, T):
<font color="#000000">3:</font>   <b><u><font color="#000000">assert</font></u></b>(issubset(T, S)) <i><font color="#222222"># precondition</font></i>
<font color="#000000">4:</font>   s = np.random.choice(S) <i><font color="#222222"># uniform choice over S.</font></i>
<font color="#000000">5:</font>   <b><u><font color="#000000">if</font></u></b> s <b><u><font color="#000000">in</font></u></b> T: <b><u><font color="#000000">return</font></u></b> s <i><font color="#222222"># |T|/|S| prob. to enter `if`.</font></i>
<font color="#000000">6:</font>   <b><u><font color="#000000">else</font></u></b>:
<font color="#000000">7:</font>     <i><font color="#222222"># (1 - |T|/|S|) to enter `else`</font></i>
<font color="#000000">8:</font>     Snext = S.remove(s); <b><u><font color="#000000">return</font></u></b> process(Snext, T) 
<font color="#000000">9:</font> </tt></pre>
</div>

We claim that the probability that <code>process(S, T) = t0</code> for a fixed <code>t0</code> in <code>T</code>
is <span class='latexinline'>
1/|<span style="font-style:italic">T</span>|</span>. We create a new function <code>indicator</code> to express this:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> <b><u><font color="#000000">def</font></u></b> indicator(t0, S, T):
<font color="#000000">3:</font>   <b><u><font color="#000000">assert</font></u></b>(t0 <b><u><font color="#000000">in</font></u></b> T) <i><font color="#222222"># precondition</font></i>
<font color="#000000">4:</font>   <b><u><font color="#000000">assert</font></u></b>(issubset(T, S)) <i><font color="#222222"># precondition</font></i>
<font color="#000000">5:</font> 
<font color="#000000">6:</font>   <b><u><font color="#000000">return</font></u></b> t0 == process(S, T)
<font color="#000000">7:</font> </tt></pre>
</div>

Let's push in <code>t0 ==</code> into the definiton of <code>process</code> after inling <code>process</code>.
This gives us:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> <b><u><font color="#000000">def</font></u></b> indicator(t0, S, T):
<font color="#000000">03:</font>   <b><u><font color="#000000">assert</font></u></b>(t0 <b><u><font color="#000000">in</font></u></b> T) <i><font color="#222222"># precondition</font></i>
<font color="#000000">04:</font>   <b><u><font color="#000000">assert</font></u></b>(issubset(T, S)) <i><font color="#222222"># precondition</font></i>
<font color="#000000">05:</font> 
<font color="#000000">06:</font>   s = np.random.choice(S)
<font color="#000000">07:</font>   <b><u><font color="#000000">if</font></u></b> s <b><u><font color="#000000">in</font></u></b> T:
<font color="#000000">08:</font>     <i><font color="#222222"># T/S prob. for x in T</font></i>
<font color="#000000">09:</font>     <b><u><font color="#000000">return</font></u></b> t0 == s <i><font color="#222222"># 1/|T| prob. for t0 == x</font></i>
<font color="#000000">10:</font>   <b><u><font color="#000000">else</font></u></b>:
<font color="#000000">11:</font>     <i><font color="#222222">#  (1 - |T|/|S|) to reach else branch.</font></i>
<font color="#000000">12:</font>     Snext = S.remove(s); <b><u><font color="#000000">return</font></u></b> process(Snext, T) 
<font color="#000000">13:</font> 
<font color="#000000">14:</font> </tt></pre>
</div>

Now, we write down the recurrence for the probability that we are trying
to compute: <span class='latexinline'>
<span style="font-style:italic">P</span>(<span style="font-style:italic">t</span>0, <span style="font-style:italic">S</span>, <span style="font-style:italic">T</span>)</span> is the probability that <code>indicator(t0, S, T)</code> returns
<code>True</code>. Alternatively, it's the probability that <code>process(S, T)</code> returns <code>t0</code>.
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> P(t0, S, T) = prob. that process(S, T) = t0
<font color="#000000">3:</font> P(t0, T, T) = T/|T| * 1/|T| = 1/|T| [base case]
<font color="#000000">4:</font> P(t0, S, T) = 1/|S| + (1 - |T|/|S|) * P(t0, |S|-1, T) [induction]
<font color="#000000">5:</font> </tt></pre>
</div>

We assume for induction that <code>P(t0, |S|-1, T) = 1/|T|</code>. On substitution into <code>[induction]</code>,
we get:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> P(t0, S, T) 
<font color="#000000">3:</font> = 1/|S| + (1 - |T|/|S|) * P(t0, |S|-1, T) [induction]
<font color="#000000">4:</font> = 1/|S| + (1 - |T|/|S|) * 1/|T| 
<font color="#000000">5:</font> = 1/|S| + (1/|T| - 1/|S|)s
<font color="#000000">6:</font> = 1/|T|
<font color="#000000">7:</font> </tt></pre>
</div>

Which is indeed the same probability as (1):
<blockquote> 1. Choosing an element uniformly from a subset <span class='latexinline'>
<span style="font-style:italic">T</span></span> = <code>1/|T|</code>.</blockquote>
<h4><a id=proof-by-program-analysis-version-1 href='#proof-by-program-analysis-version-1'> § </a> Proof by program analysis, Version 1</h4>
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> <b><u><font color="#000000">def</font></u></b> process(S, T):
<font color="#000000">3:</font>   s = np.random.choice(S)
<font color="#000000">4:</font>   <b><u><font color="#000000">if</font></u></b> s <b><u><font color="#000000">in</font></u></b> T: <b><u><font color="#000000">return</font></u></b> s
<font color="#000000">5:</font>   <b><u><font color="#000000">else</font></u></b> <b><u><font color="#000000">return</font></u></b> process(S.remove(s), T)
<font color="#000000">6:</font> </tt></pre>
</div>

Notice that the last return is tail-call. This program can be rewritten as:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> <b><u><font color="#000000">def</font></u></b> process(S, T):
<font color="#000000">3:</font>   <b><u><font color="#000000">while</font></u></b> True:
<font color="#000000">4:</font>     s = np.random.choice(S)
<font color="#000000">5:</font>     <b><u><font color="#000000">if</font></u></b> s <b><u><font color="#000000">in</font></u></b> T: <b><u><font color="#000000">return</font></u></b> s
<font color="#000000">6:</font>     S = S.remove(s)
<font color="#000000">7:</font> </tt></pre>
</div>

As previously, we create an <code>indicator</code> function and study its behaviour:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> <b><u><font color="#000000">def</font></u></b> indicator(t0, S, T):
<font color="#000000">3:</font>   <b><u><font color="#000000">assert</font></u></b>(t0 <b><u><font color="#000000">in</font></u></b> T) <i><font color="#222222"># precondition</font></i>
<font color="#000000">4:</font>   <b><u><font color="#000000">assert</font></u></b>(issubset(T, S)) <i><font color="#222222"># precondition</font></i>
<font color="#000000">5:</font> 
<font color="#000000">6:</font>   <b><u><font color="#000000">while</font></u></b> True:
<font color="#000000">7:</font>     s = np.random.choice(S)
<font color="#000000">8:</font>     <b><u><font color="#000000">if</font></u></b> s <b><u><font color="#000000">in</font></u></b> T: <b><u><font color="#000000">return</font></u></b> t0 == s
<font color="#000000">9:</font>     S = S.remove(s)
<font color="#000000">10:</font> </tt></pre>
</div>

We know that this programs only returns a value from the line:
<ul>
<li>
 <code>if s in T: return t0 == s</code>
</li>

</ul>

We now compute <code>P(process(S, T) == t0)</code>.
Whatever the return value of <code>indicator</code>, we can assume that it occured within
the <code>if</code> condition. We can use this to compute:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> P(indicator(t0, S, T) = True)
<font color="#000000">3:</font>  = P(t0 == s | s in T) [program only returns in this case]
<font color="#000000">4:</font>  = 1/|T|
<font color="#000000">5:</font> </tt></pre>
</div>

<h4><a id=proof-by-program-analysis-version-2 href='#proof-by-program-analysis-version-2'> § </a> Proof by program analysis, Version 2</h4>
Alternatively, we can also analyze this as we did in the <i>first</i> proof,
using the rule:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> <b><u><font color="#000000">def</font></u></b> f():
<font color="#000000">3:</font>   <b><u><font color="#000000">return</font></u></b> <b><u><font color="#000000">if</font></u></b> cond1 then cond2 <b><u><font color="#000000">else</font></u></b> cond3
<font color="#000000">4:</font> </tt></pre>
</div>

will have probability:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> P(cond1) * P(cond2|cond1) + P(not cond1) * P(cond3|not cond1)
<font color="#000000">3:</font> </tt></pre>
</div>

Using this, we can analyze <code>indicator </code>as:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> P(indicator(t0, S, T) = True)
<font color="#000000">3:</font>  = P(s in T) * P(t0 == s |s in T) + 
<font color="#000000">4:</font>     P(s not in T) * P(indicator(t0, S.remove(s), T) | s not in T)
<font color="#000000">5:</font>  = |T|/|S| * 1/|T| + 
<font color="#000000">6:</font>     (|S|-|T|)/|S| * P(indicator(t0, S.remove(s), T))
<font color="#000000">7:</font>  = 1/|S| + (|S|-|T|)/|S| * 1/|T| [by induction]
<font color="#000000">8:</font>  = 1/|T|
<font color="#000000">9:</font> </tt></pre>
</div>

<h4><a id=sampling-using-the-above-definition href='#sampling-using-the-above-definition'> § </a> Sampling using the above definition</h4>
Recall that <span class='latexinline'>
<span style="font-style:italic">State</span>(<span style="font-style:italic">X</span>) &#X2261; <span style="font-style:italic">V</span> &#X2192; <span style="font-style:italic">C</span></span>, <span class='latexinline'>
<span style="font-style:italic">State</span>(<span style="font-style:italic">W</span>) &#X2261; <span style="font-style:italic">V</span> &#X2192; 2<sup><span style="font-style:italic">C</span></sup></span>.
Let <span class='latexinline'>
<span style="font-style:italic">x</span>[&#XA0;], <span style="font-style:italic">w</span>[&#XA0;]</span> be the states of some run in the markov chains.
We start by having <span class='latexinline'>
<span style="font-style:italic">x</span>[0]</span> to be <i>any</i> valid k-coloring of <span class='latexinline'>
<span style="font-style:italic">G</span></span>, and <span class='latexinline'>
<span style="font-style:italic">w</span>[0]</span> to
be the state where all vertices have all possible colors; <span class='latexinline'>
<span style="font-style:italic">w</span>[0] &#X2261; _ &#X21A6; <span style="font-style:italic">C</span></span>.
Clearly, <span class='latexinline'>
<span style="font-style:italic">x</span>[0] &#X2208; <span style="font-style:italic">w</span>[0]</span>.
By induction we assume that <span class='latexinline'>
<span style="font-style:italic">x</span>[<span style="font-style:italic">n</span>&#X2212;1] &#X2208; <span style="font-style:italic">w</span>[<span style="font-style:italic">n</span>&#X2212;1]</span>. We must now calculate a
<span class='latexinline'>
<span style="font-style:italic">w</span>[<span style="font-style:italic">n</span>], <span style="font-style:italic">x</span>[<span style="font-style:italic">n</span>]</span> such that (1) <span class='latexinline'>
<span style="font-style:italic">x</span>[<span style="font-style:italic">n</span>] &#X2208; <span style="font-style:italic">w</span>[<span style="font-style:italic">n</span>]</span>, (2) <span class='latexinline'>
<span style="font-style:italic">x</span>[<span style="font-style:italic">n</span>]</span>'s proposal is symmetric. 
(3) <span class='latexinline'>
<span style="font-style:italic">w</span>[<span style="font-style:italic">n</span>]</span>'s proposal is symmetric.
<h4><a id=ooccluded-set- href='#ooccluded-set-'> § </a> Occluded set <span class='latexinline'>
<span style="font-style:italic">O</span></span></h4>
Define <span class='latexinline'>
<span style="font-style:italic">O</span> &#X2286; <span style="font-style:italic">C</span></span> (for occluded) be the set colors that might possibly
be blocked for <span class='latexinline'>
<span style="font-style:italic">v</span></span> from our view of <code>w</code>. Note that this is an
<b>over-approxmation</b>: that is, there may be colors that are not blocked for <code>v</code>, which we
believe to be blocked from <code>w</code>'s point of view.
<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">O</span>&#XA0;&#X2261;&#XA0;&#XA0;{&#XA0;<span style="font-style:italic">c</span>&#XA0;&#X2208;&#XA0;<span style="font-style:italic">C</span>&#XA0;:&#XA0;(<span style="font-style:italic">v</span>,&#XA0;&#X3B1;)&#XA0;&#X2208;&#XA0;<span style="font-style:italic">E</span>,&#XA0;<span style="font-style:italic">c</span>&#XA0;&#X2208;&#XA0;<span style="font-style:italic">w</span>[<span style="font-style:italic">n</span>&#X2212;1](&#X3B1;)&#XA0;}</td></tr>
</table></div>
<h4><a id=aallowed-set- href='#aallowed-set-'> § </a> Allowed set <span class='latexinline'>
<span style="font-style:italic">A</span></span></h4>
Define <span class='latexinline'>
<span style="font-style:italic">A</span> &#X2282; <span style="font-style:italic">C</span></span> (for allowed) to be <span class='latexinline'>
<span style="font-style:italic">C</span> &#X2212; <span style="font-style:italic">O</span></span>. Note that <span class='latexinline'>
<span style="font-style:italic">A</span></span> is
an <b>under-approxmation</b>, since <code>O</code> was an <i>over-approximation</i>. That is:
<ul>
<li>
 Any color in <code>A</code> is definitely a legal color for <code>v</code> in <code>x[n]</code>.  
</li>
<li>
 There are colors which are legal for <code>v</code> in <code>x[n]</code> that is not in <code>A</code>.
</li>

</ul>

<h4><a id=s-the-sequence-of-states-for-transition href='#s-the-sequence-of-states-for-transition'> § </a> S: the sequence of states for transition</h4>
Now, we pick elements of <span class='latexinline'>
<span style="font-style:italic">C</span></span> in sequence till we get an element of <code>A</code>.
call this sequence <span class='latexinline'>
<span style="font-style:italic">S</span></span>. 
We will at worst pick <span class='latexinline'>
&#X394; + 1</span> elements for <span class='latexinline'>
<span style="font-style:italic">S</span></span>, since the max-degree
of the graph is <span class='latexinline'>
&#X394;</span>.
<h4><a id=transition href='#transition'> § </a> Transition</h4>
Let <span class='latexinline'>
<span style="font-style:italic">i</span></span> be the first index in <span class='latexinline'>
<span style="font-style:italic">S</span></span> where we get a color that is <i>truly legal</i>
for <span class='latexinline'>
<span style="font-style:italic">v</span></span> in <span class='latexinline'>
<span style="font-style:italic">x</span>[<span style="font-style:italic">n</span>]</span>. Note that such an index will always exist: We pick
elements into <span class='latexinline'>
<span style="font-style:italic">S</span></span> till we get an element in <span class='latexinline'>
<span style="font-style:italic">A</span></span>, and elements of <span class='latexinline'>
<span style="font-style:italic">A</span></span> are 
always legal. However, there can be elements which are not in <span class='latexinline'>
<span style="font-style:italic">A</span></span> that
are still legal for <span class='latexinline'>
<span style="font-style:italic">v</span></span> in <span class='latexinline'>
<span style="font-style:italic">x</span>[<span style="font-style:italic">n</span>]</span>, since <span class='latexinline'>
<span style="font-style:italic">A</span></span> is an under-approximation.
<ul>
<li>
 We assign <span class='latexinline'>
<span style="font-style:italic">x</span>[<span style="font-style:italic">n</span>](<span style="font-style:italic">v</span>) = <span style="font-style:italic">i</span></span>. So, <code>x</code> only cares about <code>S[:i]</code>.
</li>
<li>
 We assign  <span class='latexinline'>
<span style="font-style:italic">w</span>[<span style="font-style:italic">n</span>](<span style="font-style:italic">v</span>) = <span style="font-style:italic">A</span></span>. So, <code>W</code> cares about the entire sequence.
</li>

</ul>

By the lemma proven, we know that this process of picking colors <code>C</code> 
in a sequence till we get a color that is legal for <span class='latexinline'>
<span style="font-style:italic">v</span></span> at index <span class='latexinline'>
<span style="font-style:italic">i</span></span>
is the same as picking uniformly at random from the set of colors that are legal for 
<span class='latexinline'>
<span style="font-style:italic">v</span></span>. 
<h4><a id=an-example href='#an-example'> § </a> An example</h4>
For example, we could have:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> X | p:2 --- q:4
<font color="#000000">03:</font> W | p:{1, 2} --- q:{4, 5}
<font color="#000000">04:</font> 
<font color="#000000">05:</font> we are sampling q:
<font color="#000000">06:</font> 
<font color="#000000">07:</font> O = {1, 2}
<font color="#000000">08:</font> A = {3, 4, 5}
<font color="#000000">09:</font> S = [2, 1, 3]
<font color="#000000">10:</font> 
<font color="#000000">11:</font> X | p:1 -- q:2 
<font color="#000000">12:</font> W | p:{1, 2} -- q:{1, 2, 3}
<font color="#000000">13:</font> </tt></pre>
</div>

If we analyze <code>S = [2, 1, 3]</code> we notice that:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> 2: invalid for W(p:[1, 2]), invalid for X(p:2)    
<font color="#000000">3:</font> 1: invalid for W, valid for X  
<font color="#000000">4:</font> 3: valid for W, valid for X
<font color="#000000">5:</font> </tt></pre>
</div>

So, what we are really sampling ix:
<ul>
<li>
 A <i>prefix</i> sequence <code>SX = [1]</code> (for Xs transition)
</li>
<li>
 A <i>leftover</i> sequence <code>SW = [2, 3]</code> (for Ws transition)
</li>

</ul>

To transition <code>X</code>, we can safely drop <code>SW</code>. However, to transition <code>W</code> correctly,
we generate more elements in the sequence, till we hit a "safe" element.
<h4><a id=an-optimisation-on-picking-colors-why-we-need-a-blocking-set href='#an-optimisation-on-picking-colors-why-we-need-a-blocking-set'> § </a> An optimisation on picking colors: why we need a blocking set</h4>
Define the set <span class='latexinline'>
<span style="font-style:italic">B</span> &#X2286; <span style="font-style:italic">C</span></span> (for blocked) which governs which values
<span class='latexinline'>
<span style="font-style:italic">x</span>[<span style="font-style:italic">n</span>]</span> <b>surely cannot take</b> from our view of <span class='latexinline'>
<span style="font-style:italic">w</span>[<span style="font-style:italic">n</span>&#X2212;1]</span>.
Note that <span class='latexinline'>
<span style="font-style:italic">B</span></span> is an <b>under-approximation</b>. <code>v</code> might have
more colors that are blocked than what <code>w</code> sees.
<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">B</span>&#XA0;&#X2261;&#XA0;{&#XA0;<span style="font-style:italic">c</span>&#XA0;&#X2208;&#XA0;<span style="font-style:italic">C</span>&#XA0;:&#XA0;(<span style="font-style:italic">v</span>,&#XA0;&#X3B1;)&#XA0;&#X2208;&#XA0;<span style="font-style:italic">E</span>,&#XA0;<span style="font-style:italic">w</span>[<span style="font-style:italic">n</span>&#X2212;1](&#X3B1;)&#XA0;=&#XA0;{<span style="font-style:italic">c</span>}&#XA0;}</td></tr>
</table></div>
       
Rather than sampling colors from <code>C</code> till we get an element of <code>A</code>, we can
sample colors from <code>C/B</code>. We know that the colors in <code>B</code> can <b>never</b> be used 
by <span class='latexinline'>
<span style="font-style:italic">X</span></span>, since the colors in <code>B</code> are those that we know are blocked <b>for sure</b>.
This is used in the theoretical analysis of the paper.
<h4><a id=termination href='#termination'> § </a> Termination</h4>
We terminate when <span class='latexinline'>
<span style="font-style:italic">W</span></span> has "trapped" <span class='latexinline'>
<span style="font-style:italic">X</span></span>. That is, <span class='latexinline'>
|<span style="font-style:italic">w</span>[<span style="font-style:italic">n</span>](<span style="font-style:italic">v</span>)| = 1</span> forall <span class='latexinline'>
<span style="font-style:italic">v</span> &#X2208; <span style="font-style:italic">V</span></span>.
In such a case, the states of <span class='latexinline'>
<span style="font-style:italic">W</span></span> is equal to states of <span class='latexinline'>
<span style="font-style:italic">X</span></span>. This is
a coalescence (as it occurs in coupling from the past). From the coupling
from the past theory, we know that we have reached a stationary state of <span class='latexinline'>
<span style="font-style:italic">A</span></span>
when this happens.
<h4><a id=pseudocode href='#pseudocode'> § </a> Pseudocode</h4>
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> <i><font color="#222222">-- | colors, vertices, edges</font></i>
<font color="#000000">03:</font> cs :: [<b><font color="#000000">C</font></b>]; cs = ...
<font color="#000000">04:</font> vs :: [<b><font color="#000000">V</font></b>]; vs = ...
<font color="#000000">05:</font> es :: [(<b><font color="#000000">V</font></b>, <b><font color="#000000">V</font></b>); es = ...
<font color="#000000">06:</font> 
<font color="#000000">07:</font> 
<font color="#000000">08:</font> <i><font color="#222222">-- | definitely not allowed</font></i>
<font color="#000000">09:</font> blocked :: (<b><font color="#000000">V</font></b> -&gt; [<b><font color="#000000">C</font></b>]) -&gt; (<b><font color="#000000">V</font></b> -&gt; [<b><font color="#000000">C</font></b>])
<font color="#000000">10:</font> blocked v2cs v0 = concat [v2cs w | (v, w) &lt;- es, v == v0, length (v2cs w) == <font color="#000000">1</font>]
<font color="#000000">11:</font> 
<font color="#000000">12:</font> 
<font color="#000000">13:</font> <i><font color="#222222">-- | maybe not allowed</font></i>
<font color="#000000">14:</font> occluded :: (<b><font color="#000000">V</font></b> -&gt; [<b><font color="#000000">C</font></b>]) -&gt; (<b><font color="#000000">V</font></b> -&gt; [<b><font color="#000000">C</font></b>])
<font color="#000000">15:</font> occluded v2cs v0 = concat [v2cs w | (v, w) &lt;- es, v == v0]
<font color="#000000">16:</font> 
<font color="#000000">17:</font> <i><font color="#222222">-- | definitely allowed from Ws point of view</font></i>
<font color="#000000">18:</font> allowed :: (<b><font color="#000000">V</font></b> -&gt; [<b><font color="#000000">C</font></b>]) -&gt; (<b><font color="#000000">V</font></b> -&gt; [<b><font color="#000000">C</font></b>])
<font color="#000000">19:</font> allowed v2cs = cs \\ occluded v2cs 
<font color="#000000">20:</font> 
<font color="#000000">21:</font> <i><font color="#222222">-- | perturb the color function to another function</font></i>
<font color="#000000">22:</font> perturb :: (<b><font color="#000000">V</font></b> -&gt; [<b><font color="#000000">C</font></b>]) -&gt; <b><font color="#000000">Rand</font></b> (<b><font color="#000000">V</font></b> -&gt; [<b><font color="#000000">C</font></b>])
<font color="#000000">23:</font> perturb v2cs = <b><u><font color="#000000">do</font></u></b> $ 
<font color="#000000">24:</font>   randv &lt;- uniform_rand vs
<font color="#000000">25:</font>   randc_for_v &lt;- uniform_rand (allowed v2cs v)
<font color="#000000">26:</font>   return $ \v -&gt; <b><u><font color="#000000">if</font></u></b> v == randv <b><u><font color="#000000">then</font></u></b> randc_for_v <b><u><font color="#000000">else</font></u></b> v2cs v
<font color="#000000">27:</font>   
<font color="#000000">28:</font> 
<font color="#000000">29:</font> <i><font color="#222222">-- | check if we are done</font></i>
<font color="#000000">30:</font> terminated :: (<b><font color="#000000">V</font></b> -&gt; [<b><font color="#000000">C</font></b>]) -&gt; <b><font color="#000000">Bool</font></b>
<font color="#000000">31:</font> terminated v2cs = all [length (v2cs v) == <font color="#000000">1</font> | v &lt;- vs]
<font color="#000000">32:</font> 
<font color="#000000">33:</font> <i><font color="#222222">-- | generate chain</font></i>
<font color="#000000">34:</font> chain :: (<b><font color="#000000">V</font></b> -&gt; [<b><font color="#000000">C</font></b>]) -&gt; <b><font color="#000000">Rand</font></b> [<b><font color="#000000">V</font></b> -&gt; [<b><font color="#000000">C</font></b>]]
<font color="#000000">35:</font> chain f = <b><u><font color="#000000">do</font></u></b>
<font color="#000000">36:</font>   <b><u><font color="#000000">if</font></u></b> terminated f 
<font color="#000000">37:</font>   <b><u><font color="#000000">then</font></u></b> [] <b><u><font color="#000000">else</font></u></b> <b><u><font color="#000000">do</font></u></b> 
<font color="#000000">38:</font>     f;' &lt;- perturb f; fs &lt;- chain f'; return (f:fs)
<font color="#000000">39:</font> 
<font color="#000000">40:</font> <i><font color="#222222">-- | return a sample</font></i>
<font color="#000000">41:</font> sample :: (<b><font color="#000000">V</font></b> -&gt; [<b><font color="#000000">C</font></b>]) -&gt; <b><font color="#000000">Rand</font></b> (<b><font color="#000000">V</font></b> -&gt; [<b><font color="#000000">C</font></b>])
<font color="#000000">42:</font> sample = last . chain
<font color="#000000">43:</font> 
<font color="#000000">44:</font> </tt></pre>
</div>

<h4><a id=references href='#references'> § </a> References</h4>
<ul>
<li>
 <a href=https://dl.acm.org/doi/10.1145/276698.276709>
Exact Sampling and Approximate Counting Techniques</a>

</li>

</ul>

<h2><a id=coupling-from-the-past href='#coupling-from-the-past'> § </a> <a href=#coupling-from-the-past>
Coupling from the past</a>
</h2>
<h4><a id=relationship-between-cftp-and-reset-transitions href='#relationship-between-cftp-and-reset-transitions'> § </a> Relationship between CFTP and reset transitions</h4>
<h4><a id=references href='#references'> § </a> References</h4>
<ul>
<li>
 <a href=http://blog.sigfpe.com/2018/10/running-from-past.html>
Dan piponi, running from the past</a>

</li>
<li>
 <a href=https://pdfs.semanticscholar.org/622e/a9c9c665002670ff26119d1aad5c3c5e0be8.pdf>
Coupling from the past, a user's guide</a>

</li>

</ul>

<h2><a id=word-problems-in-russia-and-america href='#word-problems-in-russia-and-america'> § </a> <a href=#word-problems-in-russia-and-america>
Word problems in Russia and America</a>
</h2>
<ul>
<li>
 <a href=http://toomandre.com/travel/sweden05/WP-SWEDEN-NEW.pdf>
link to article by <i>Andrei Toom</i></a>

</li>

</ul>

scathing critique of how ameriacn math education is screwed:
 also, interesting
anecdote about how looking for 'reality' in mathematical problems may in fact
break student's ability to think in the abstract! This is a deep insight.
<h2><a id=encoding-mathematical-hieararchies href='#encoding-mathematical-hieararchies'> § </a> <a href=#encoding-mathematical-hieararchies>
Encoding mathematical hieararchies</a>
</h2>
I've wanted to learn how the SageMATH system is organized when it comes to math
hieararchies. I also wish to learn how <code>lean4</code> encodes their hiearchies. I know
how mathematical components does it. This might help narrow in on what what the
"goldilocks zone" is for typeclass design.
<h4><a id=references href='#references'> § </a> References</h4>
<ul>
<li>
 <a href=https://cicm-conference.org/2016/slides/I3.pdf>
Slides : Infrastructure for generic code in <code>SageMath</code></a>

</li>
<li>
 <a href=https://arxiv.org/abs/2001.04301>
Tabled typeclass resolution</a>

</li>
<li>
 <a href=https://math-comp.github.io/mcb/>
Mathematical components, the book</a>

</li>

</ul>

<h2><a id=learning-code-by-hearing-it href='#learning-code-by-hearing-it'> § </a> <a href=#learning-code-by-hearing-it>
Learning code by hearing it</a>
</h2>
I learnt of this from an amazing discussion on HackerNews, where a sighted
programmed, who is going blind, asked the community if he could remain
a software engineer. An answer by <code>kolanos</code> read:
<blockquote> You can definitely continue as a software engineer. I'm living proof. ... For example, as you get better with a screen reader, you'll be bumping the speech rate up to 1.75-2X normal speech. ... Typos will be easily spotted as they just won't "sound right". It will be like listening to a familiar song and then hitting an off note in the melody. <b>And this includes code</b>. Also, because code is no longer represented visually as blocks,  you'll find you're <b>building an increasingly detailed memory model of your code</b>.   Sighted people do this, too, but they tend to visualize in their mind. When you abandon this two dimensional representation, <b>your non-visual mental map suffers no spatial limits</b>. You'll be amazed how good your memory will get without the crutch of sight.</blockquote>
I find this incredibly fascinating. I think I'm going to try this: I'll listen
to lectures on <code>1.5-2x</code> anyway, so this may work just as well. I'm planning
on trying this with the MLIR codebase, which I want to get to know intimately.
I'll write updates on how this goes.
<a href=https://drewdevault.com/>
Drew DeVault</a>
 also posted links to tools/scripts
for programming without needing visual feedback:
<ul>
<li>
 <a href=https://git.sr.ht/~sircmpwn/dotfiles/tree/master/lib/vim/vimspeak.vim>
vimspeak.vim</a>

  for, if I understand correctly, speaking out loud the current state
  [which buffer, which mode, what line], as well as reading out text from
  the buffer.
</li>
<li>
 <a href=https://git.sr.ht/~sircmpwn/dotfiles/tree/master/bin/swaytalk>
An extension to the Sway tiling window manager</a>

  for providing audio cues.
</li>

</ul>

I also learnt about <a href=http://emacspeak.sourceforge.net/>
emacspeak</a>
, which
supposedly works well for an audio-based-workflow.
<ul>
<li>
 [https://news.ycombinator.com/item?id=22919455]
</li>

</ul>

<h2><a id=your-arm-can-be-a-spinor href='#your-arm-can-be-a-spinor'> § </a> <a href=#your-arm-can-be-a-spinor>
Your arm can be a spinor</a>
</h2>
I tend to forget the name of this trick. It exhibits spinors in real life:
a system that needs to rotate by 720 degrees to return back to its
original state, versus the usual 360 tha we are generally used to. We need
to consider our entire arm + cup we are holding as a system for this to work.
<ul>
<li>
 <a href=https://en.wikipedia.org/wiki/Plate_trick>
'Plate trick'</a>

</li>
<li>
 <a href=https://www.youtube.com/watch?v=Rzt_byhgujg>
Baliense cup trick</a>

</li>

</ul>

<h3><a id=self-modifying-code-for-function-calls-look-ma-i-dont-need-a-stack href='#self-modifying-code-for-function-calls-look-ma-i-dont-need-a-stack'> § </a> <a href=#self-modifying-code-for-function-calls-look-ma-i-dont-need-a-stack>
Self modifying code for function calls: Look ma, I don't need a stack!</a>
</h3>
If one does not have recursive calls, one can eliminate the need to push
return addresses on a call stack by writing self-modifying code ---
I leant of this from TAOCP, volume 1. 
Knuth shows this off once he introduces <code>MIXAL</code>, his fantasy
aseembly language in which TAOCP programs are written.
I'll explain the usual way one performs call-return, then explain the nifty
self-modifying-code way. I think this is the cleanest, most accessible
example of self-modifying-code that I know. 
<h4><a id=callretditional-solution-for- href='#callretditional-solution-for-'> § </a> The traditional solution for <code>call/ret</code></h4>
We wish to have function <code>f</code> call function <code>g</code>. For <code>g</code> to be able to
return control to <code>f</code>, <code>f</code> pushes a return address into the call stack,
that <code>g</code> pops and <code>jmp</code>s to
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> f's body
<font color="#000000">3:</font> START_F:
<font color="#000000">4:</font>       ...
<font color="#000000">5:</font> L0    push addr(L0); location of instr to be run after call.
<font color="#000000">6:</font>       jmp START_G
<font color="#000000">7:</font> L1:   &lt;code after call&gt;
<font color="#000000">8:</font> </tt></pre>
</div>

<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> g's body
<font color="#000000">3:</font> START_G:
<font color="#000000">4:</font>       ...
<font color="#000000">5:</font>       retloc = pop ; pop location to jump to
<font color="#000000">6:</font> RETG: jmp retloc
<font color="#000000">7:</font> </tt></pre>
</div>

Rather than <code>push</code>ing and <code>pop</code>ing, we can <i>rewrite</i> the code of <code>g</code>, to <i>change</i> <code>retloc</code> before a call
to <code>g</code>. In made-up-pseudocode, here's what that would look like:
<h4><a id=the-jump-based-solution href='#the-jump-based-solution'> § </a> The jump based solution</h4>
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> * f's body
<font color="#000000">3:</font> START_F:
<font color="#000000">4:</font>       ...
<font color="#000000">5:</font> L0    store loc(RETG) assemble(jmp addr(L1))
<font color="#000000">6:</font>       jmp START_G
<font color="#000000">7:</font> L1:   &lt;code after call&gt;
<font color="#000000">8:</font> </tt></pre>
</div>

<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> * g's body
<font color="#000000">3:</font> START_G:
<font color="#000000">4:</font>       ...
<font color="#000000">5:</font> RETG: &lt;###-to-be-filled-dummy-###&gt;
<font color="#000000">6:</font> </tt></pre>
</div>

instead of having a call stack, before <code>f</code> calls g, <code>f</code> modify <code>g</code>'s code at location <code>RETG</code>
into a <code>jmp</code> instruction by <code>store</code> ing the instruction <code>jmp addr(L1)</code>.
This effectively creates a 'custom' <code>g</code> that knows how  to return
control flow into <code>f</code>.
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> * g's body (after execution of L0)
<font color="#000000">3:</font> START_G:
<font color="#000000">4:</font>       ...
<font color="#000000">5:</font> RETG: jump addr(L1)
<font color="#000000">6:</font> </tt></pre>
</div>

This way, we have obviated the need for a <code>push/pop</code> sequence, by directly
modifying <code>g</code>'s code. This is really neat --- we replace the overhead of
a <code>push/pop</code> with a single <code>store</code>.
<h4><a id=why-recursion-breaks href='#why-recursion-breaks'> § </a> Why recursion breaks.</h4>
We don't actually need a call stack, as long as we don't want to write recursive functions.
We can't have recursion, or more generally "re-entrance": consider a call chain of the form:
<ul>
<li>
 <code>A -> B -> C -> B</code>.
</li>
<li>
 during <code>A -> B</code>, <code>A</code> will scribble a <code><return to A></code> into <code>B</code>.
</li>
<li>
 during  <code>B -> C</code>, <code>B</code> will scribble a <code><return to  B></code> into <code>C</code>.
</li>
<li>
 during <code>C -> B</code>, <code>C</code> will scribble <code><return to C></code> into <code>B</code>,
  <b>destroying the previous <code><return to A></code> </b>.
</li>
<li>
 This creates a cycle, where <code>C</code> will attempt to return to <code>B</code>
  and vice versa.
</li>

</ul>

<h3><a id=adjunctions-as-advice href='#adjunctions-as-advice'> § </a> <a href=#adjunctions-as-advice>
Adjunctions as advice</a>
</h3>
An adjunction <code>F |- U</code> allows us to go from <code>F a -> x</code> to <code>a -> U x</code>. We 
can look at this as shifting the "before-advice" from the <i>input</i> to an 
"after advice" of the <i>output</i>, where I'm using

Also, to remember this, we can write it as:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> F a &lt;--F--- a
<font color="#000000">3:</font> |           |
<font color="#000000">4:</font> v           v
<font color="#000000">5:</font> x ----U--&gt; U x
<font color="#000000">6:</font> </tt></pre>
</div>

Where <code>F</code> is for <code>F</code>ree and <code>U</code> is for forgetf<code>U</code>l.
Recall that if <code>F</code> is free and <code>U</code> is forgetful, then <code>U(F(x)) = x</code>, since
adding more structure through the free functor and then stripping it away gives
us the object back. We can prove that if <code>U(F(x)) = x</code> and <code>U, F</code> are functors,
then we have a function <code>fwd: (f a -> x) -> (a -> u x)</code> as:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> f      :: (f a -&gt; x) 
<font color="#000000">3:</font> fmap   :: (p   -&gt; q) -&gt; (u p     -&gt; u q)
<font color="#000000">4:</font> fmap   :: (p   -&gt; q) -&gt; (u ( p ) -&gt; u q)
<font color="#000000">5:</font> fmap f :: (f a -&gt; x) -&gt; (u (f a) -&gt; u x) 
<font color="#000000">6:</font> fmap f :: (f a -&gt; x) -&gt; (a       -&gt; u x) [using u (f a) = a]
<font color="#000000">7:</font> </tt></pre>
</div>

<h4><a id=references href='#references'> § </a> References</h4>
<ul>
<li>
 <a href=https://www.youtube.com/watch?v=l1FCXUi6Vlw>
Profunctor optics: the categorical approach, <code>33:00</code> onwards</a>

</li>

</ul>

<h3><a id=reversible-computation-as-groups-on-programs href='#reversible-computation-as-groups-on-programs'> § </a> <a href=#reversible-computation-as-groups-on-programs>
Reversible computation as groups on programs</a>
</h3>
If we consider a language like <a href=https://en.wikipedia.org/wiki/Janus_(time-reversible_computing_programming_language>
<code>Janus</code></a>

where every program is reversible, we can then get a group structure on
programs with the identity program not computing anything at all, the inverse
performing the reverse operation. 
Alternatively, one can use the trick from quantum mechanics of using anciliary
qubits to build reversible classical gates. 
The question is, do either of these approaches allow for better-than-STOKE
exploration of the program space? Ie, can we somehow exploit the 
discrete group structure (in the case of Janus) or the Lie group structure
of the unitary group (as in the QM case) to find programs in far quicker ways?
<h3><a id=blazing-fast-math-rendering-on-the-web href='#blazing-fast-math-rendering-on-the-web'> § </a> <a href=#blazing-fast-math-rendering-on-the-web>
Blazing fast math rendering on the web</a>
</h3>
So, I've shifted the blog to be static-site-generated using a
static-site-generator written by yours truly. The code clocks in at around a
thousand lines of C++:
<ul>
<li>
 <a href=https://github.com/bollu/bollu.github.io/tree/master/builder/builder.cpp>
bollu/bollu.github.io/builder/builder.cpp</a>

</li>

</ul>

What did I gain?
<ol>
<li>
 My generator is a real compiler, so I get errors on math and markdown
  malformation.
</li>
<li>
 I can write math that <i>loads</i> instantly on your browser, using no MathJax,
   KaTeX or any client side processing, <i>nor</i> the need to fetch images, which looks like this:
</li>

</ol>

<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">h</span>(<span style="font-style:italic">x</span>)&#XA0;&#X2261;&#XA0;
</td><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell">&#X23A7;<br>
&#X23AA;<br>
&#X23AA;<br>
&#X23AA;<br>
&#X23AA;<br>
&#X23A8;<br>
&#X23AA;<br>
&#X23AA;<br>
&#X23AA;<br>
&#X23AA;<br>
&#X23A9;</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">&#X222B;</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">&#X221E;</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">i</span>=0</td></tr>
</table></td><td class="dcell"><span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)&#XA0;<span style="font-style:italic">g</span>(<span style="font-style:italic">x</span>)&#XA0;<span style="font-style:italic">dx</span></td></tr>
</table></td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">x</span>&#XA0;&gt;&#XA0;0&#XA0;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X221E;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">&#X2211;</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">i</span>=0</td></tr>
</table></td><td class="dcell"><span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)&#XA0;+&#XA0;<span style="font-style:italic">g</span>(<span style="font-style:italic">x</span>)</td></tr>
</table></td><td style="text-align:left;white-space:nowrap" >otherwise
</td></tr>
</table></td></tr>
</table></td></tr>
</table></div>
<h4><a id=why href='#why'> § </a> Why?</h4>
My blog is a <a href=https://github.com/bollu/bollu.github.io/blob/master/README.md>
single 9000 line markdown file</a>
,
rendered as a <i>single HTML page</i>, so I 
<i>need it to compile fast, render fast, render beautiful</i>. 
Existing tools compromise on one or the other.
<h4><a id=no-seriously-why-a-single-markdown-file href='#no-seriously-why-a-single-markdown-file'> § </a> No seriously, why a single markdown file?</h4>
I need a single file to edit, so I can rapidly jot down new ideas. This is 
the essence of why I'm able to log most of what I study: 
<i>because it's seamless</i>.
Far more importantly, it provides <b>spatio-temporal locality</b>. I add things
in chronological order to tbe blog, as I learn thing. If I need to recall
something I had studied, go to that location in the blog 
<i>based on a sense of when</i>. 
When I do get to a location I want, the scrollbar gives me a sense of 
<i>where I am</i> in the file.  this is important to me, since it hepls me reason
spatially about what i know and what I've learnt. It's someting I love about
books, and deeply miss when navigtaing the web.I'm determined to keep this
spatio-temporal locality on my little slice of the internet.
<h4><a id=why-is-this-awful href='#why-is-this-awful'> § </a> Why is this awful?</h4>
As elegant as this model is to <i>edit</i>, it's awful for browsers to render. The
file used to take on the order of minutes for all the math to finish
rendering. MathJax (and KaTeX) painfully attempt to render each
math block. As they do, the page jumps around until everything has settled.
As this is happening, your CPU throttles, your lap or hand gets warm,
and the page is stuck. Clearly not great UX.
I still want math. What do I do?  The solution is easy: Approximate the math
rendering using ASCII/UTF-8 characters!  There are tools that do this ---
<a href=http://hevea.inria.fr/>
<code>hevea</code></a>
 is one of them. Unfortunately, there is no
markdown-based-blogging-platform that uses this, so I <i>had</i> to write my own.
<h4><a id=the-cure href='#the-cure'> § </a> The cure</h4>
The solution is easy. I wrote the tool. The page you're reading it
is rendered using the tool. All the math renders in under a second because
it's nothing crazy, it's just text and tables which browsers know how to
render. No JavaScript necessary. snappy performance. Whoo!
<h4><a id=the-details-writing-my-own-markdown-to-html-transpiler href='#the-details-writing-my-own-markdown-to-html-transpiler'> § </a> The details: Writing my own Markdown to HTML transpiler.</h4>
the final transpiler clocks in at <code>1300Loc</code> of C++,
which is very small for a feature-complete markdown-to-HTML piece of code
that's blazing fast, renders math correctly, and provides error messages.
<h4><a id=quirks-fixed-features-gained href='#quirks-fixed-features-gained'> § </a> Quirks fixed, features gained.</h4>
I got quite a bit "for free" as I wrote this, fixing mild annoyances
and larger pain points around using github + markdown for publishing on
the web:
<ul>
<li>
 I really don't want tables, but I do want the ability to write vertical bars 
  <code>|</code> freely in my text. Unfortunately, github <i>insists</i> that those are tables,
   and completely wrecks rendering.
</li>

</ul>

<ul>
<li>
 I get line numbers in code blocks now, which Github Flavoured Markdown
  did not have.
</li>

</ul>

<ul>
<li>
 I get error messages on incorrectly closed bold/italic/code blocks, using
  heuristics that prevent them from spanning across too many lines.
</li>

</ul>

<ul>
<li>
 I get error messages on broken latex, since all my latex passes through
  <code>hevea</code>. This is awesome, since I no longer need to refresh my browser,
  wait for mathjax to load, go make myself tea (remember that mathjax was slow?),
  and then come back to see the errors.
</li>

</ul>

<ul>
<li>
 I can get error messages if my internal document links are broken. To be
  fair, my tool doesn't currently give me these errors, but it can (and soon
  will).
</li>

</ul>

<ul>
<li>
 In general, I get <i>control</i>, which was something I did not have with
  rendering directly using Github, or using someone else's tool.
</li>

</ul>

<h4><a id=choice-of-language href='#choice-of-language'> § </a> Choice of language</h4>
I choose to write this in C-style-C++, primarily because I wanted the tool
to be fast, and I'd missed writing C++ for a while. I really enjoy how
stupid-simple C style C++ turns out to be: the C++ papers over some of C's
annoyances (like formatted output for custom types), while still preserving the
KISS feeling of writing C++.
<b>Why not Rust?</b> I freely admit that rust might have been a sane choice as
well.  unfortunately, asking rust to treat UTF-8 string as a "ball of bytes" is
hard, when it's stupidly easy with C. Plus, I wanted to use arena-style-allocation
where I make <i>huge</i> allocations in one go and then don't think about memory,
something that I don't have control over in Rust. I don't have any segfaults
(yet, perhaps), thanks to UBSAN and ASAN. I find Rust to have more impedance
than C on small applications, and this was indeed small.
<h4><a id=performance href='#performance'> § </a> Performance</h4>
Everything <i>except</i> the latex to HTML is blazing fast. Unfortunately,
calling <code>hevea</code> is slow, so I implemented a caching mechanism to make using
<code>hevea</code> not-slow. <code>hevea</code> does not have an API, so I need to <code>fork</code> and
talk to its process which is understandably flow. I built a "key-value-store"
(read: serialize data into a file) with the stupidly-simple approach of writing
an append-only log into a file. <code>hevea</code> is a pure function conceptally,
since on providing the same latex input it's going to produce the same HTML
output, so it's perfectly safe to cache it:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> <b><u><font color="#000000">const</font></u></b> <b><font color="#000000">char</font></b> DB_PATH[]=<font color="#808080">"./blogcache.txt"</font>;
<font color="#000000">03:</font> unordered_map&lt;ll, const char *&gt; G_DB;
<font color="#000000">04:</font> <b><font color="#000000">void</font></b> loadDB() {
<font color="#000000">05:</font>     G_DB = {};
<font color="#000000">06:</font>     FILE *f = fopen(DB_PATH, <font color="#808080">"rb"</font>);
<font color="#000000">07:</font>     ...
<font color="#000000">08:</font>     <b><u><font color="#000000">while</font></u></b> (!feof(f)) {
<font color="#000000">09:</font>         ll k, len;
<font color="#000000">10:</font>         fread(&amp;k, <b><u><font color="#000000">sizeof</font></u></b>(ll), <font color="#000000">1</font>, f); <b><u><font color="#000000">if</font></u></b> (feof(f)) <b><u><font color="#000000">break</font></u></b>;
<font color="#000000">11:</font>         fread(&amp;len, <b><u><font color="#000000">sizeof</font></u></b>(ll), <font color="#000000">1</font>, f);
<font color="#000000">12:</font>         ...
<font color="#000000">13:</font>         <b><font color="#000000">char</font></b> *buf = (<b><font color="#000000">char</font></b> *)calloc(<b><u><font color="#000000">sizeof</font></u></b>(<b><font color="#000000">char</font></b>), len + <font color="#000000">2</font>);
<font color="#000000">14:</font>         fread(buf, <b><u><font color="#000000">sizeof</font></u></b>(<b><font color="#000000">char</font></b>), len, f);
<font color="#000000">15:</font>         ...
<font color="#000000">16:</font>     }
<font color="#000000">17:</font>     fclose(f);
<font color="#000000">18:</font> };
<font color="#000000">19:</font> 
<font color="#000000">20:</font> <b><u><font color="#000000">const</font></u></b> <b><font color="#000000">char</font></b> *lookup_key(ll k) {
<font color="#000000">21:</font>     unordered_map&lt;ll, <b><u><font color="#000000">const</font></u></b> <b><font color="#000000">char</font></b> *&gt;::iterator it = G_DB.find(k);
<font color="#000000">22:</font>     <b><u><font color="#000000">if</font></u></b> (it == G_DB.end()) { <b><u><font color="#000000">return</font></u></b> nullptr; } <b><u><font color="#000000">return</font></u></b> it-&gt;second;
<font color="#000000">23:</font> };
<font color="#000000">24:</font> 
<font color="#000000">25:</font> <b><font color="#000000">void</font></b> store_key_value(<b><u><font color="#000000">const</font></u></b> ll k, KEEP const <b><font color="#000000">char</font></b> *v, <b><u><font color="#000000">const</font></u></b> ll len) {
<font color="#000000">26:</font>     assert(G_DB.count(k) == <font color="#000000">0</font>);
<font color="#000000">27:</font>     G_DB.insert(make_pair(k, strdup(v)));
<font color="#000000">28:</font> 
<font color="#000000">29:</font>     FILE *f = fopen(DB_PATH, <font color="#808080">"ab"</font>);
<font color="#000000">30:</font>     assert(f != nullptr &amp;&amp; <font color="#808080">"unable to open DB file"</font>);
<font color="#000000">31:</font>     fwrite(&amp;k, <b><u><font color="#000000">sizeof</font></u></b>(ll), <font color="#000000">1</font>, f);
<font color="#000000">32:</font>     fwrite(&amp;len, <b><u><font color="#000000">sizeof</font></u></b>(ll), <font color="#000000">1</font>, f);
<font color="#000000">33:</font>     fwrite(v, <b><u><font color="#000000">sizeof</font></u></b>(<b><font color="#000000">char</font></b>), len, f);
<font color="#000000">34:</font>     fclose(f);
<font color="#000000">35:</font> }
<font color="#000000">36:</font> </tt></pre>
</div>

<h4><a id=for-the-future href='#for-the-future'> § </a> For the future</h4>
I plan to rip out <code>hevea</code> and write my own <code>latex -> HTML</code> converter for
the <i>subset of LaTeX I actually use</i>. <code>hevea</code>'s strength is its downfall:
It can handle all of LaTeX, which means it's really slow. If I can concentrate
on a small subset, I don't need to play caching tricks, and I can likely
optimise the layout further for my use-cases.
I also want colored error messages, because who doesn't?
I'll probably gradually improve my static site generator over time. Once it's
at a level of polish where I'm happy with it, I'll spin it out as a separate
project.
<h4><a id=conclusions href='#conclusions'> § </a> Conclusions</h4>
Am I glad I did it? Yes, purely because my chunk of the internet aligns with
how I want it to be, and that makes me <span class='latexinline'>
&#X454;</span> more happy.
I think of it as an investment into future me, since I can extend the
markdown and the transpiler in the way <i>I</i> want it to be.
<h3><a id=vc-dimension href='#vc-dimension'> § </a> <a href=#vc-dimension>
VC dimension</a>
</h3>
Consider a ground set <span class='latexinline'>
<span style="font-style:italic">X</span></span>. Let the space of all possible binary classifications
be the function space <span class='latexinline'>
<span style="font-style:italic">C</span> &#X2261; { <span style="font-style:italic">f</span> &#X2223; <span style="font-style:italic">f</span> : <span style="font-style:italic">X</span> &#X2192; &#XB1; 1 }</span>.
Now, a hypothesis class <span class='latexinline'>
<span style="font-style:italic">H</span></span> is a subset of <span class='latexinline'>
<span style="font-style:italic">C</span></span>. For example, some model
such as "return <span class='latexinline'>
+1</span> if a point is inside a region, <span class='latexinline'>
&#X2212;1</span> otherwise" is a subset
of the full class <span class='latexinline'>
<span style="font-style:italic">C</span></span>.
The VC dimension of <span class='latexinline'>
<span style="font-style:italic">H</span></span> measures how good <span class='latexinline'>
<span style="font-style:italic">H</span></span> is generating different classification.
We first need the notion of shattering to define this.
A subset <span class='latexinline'>
<span style="font-style:italic">S</span> &#X2286; <span style="font-style:italic">X</span></span> of the ground set shatters a hypothesis class <span class='latexinline'>
<span style="font-style:italic">H</span></span>
if the function <span class='latexinline'>
<span style="font-style:italic">act</span><sub><span style="font-style:italic">S</span></sub></span> has full range, where <span class='latexinline'>
<span style="font-style:italic">act</span><sub><span style="font-style:italic">S</span></sub></span> is defined as:
<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">act</span><sub><span style="font-style:italic">S</span></sub>:&#XA0;<span style="font-style:italic">H</span>&#XA0;&#X2192;&#XA0;|<span style="font-style:italic">S</span>|<sup>{0,&#XA0;1}</sup>
<span style="font-style:italic">act</span><sub><span style="font-style:italic">S</span></sub>(<span style="font-style:italic">h</span>)&#XA0;=&#XA0;(<span style="font-style:italic">h</span>(<span style="font-style:italic">s</span><sub>0</sub>),&#XA0;<span style="font-style:italic">h</span>(<span style="font-style:italic">s</span><sub>1</sub>),&#XA0;<span style="font-style:italic">h</span>(<span style="font-style:italic">s</span><sub>2</sub>),&#XA0;&#X2026;,&#XA0;<span style="font-style:italic">h</span>(<span style="font-style:italic">s</span><sub><span style="font-style:italic">n</span></sub>))
</td></tr>
</table></div>
That is, the hypothesis class <span class='latexinline'>
<span style="font-style:italic">H</span></span> can classify all the subsets of <span class='latexinline'>
<span style="font-style:italic">S</span></span>.
Now the <b>VC dimension of the hypothesis class <span class='latexinline'>
<span style="font-style:italic">H</span></span> of a ground set <span class='latexinline'>
<span style="font-style:italic">X</span></span></b> is
the size of <b>largest possible <span class='latexinline'>
<span style="font-style:italic">S</span> &#X2286; <span style="font-style:italic">X</span></span></b> such that <span class='latexinline'>
<span style="font-style:italic">S</span></span> is shattered
by <span class='latexinline'>
<span style="font-style:italic">H</span></span>.
<h4><a id=correct-interpretation href='#correct-interpretation'> § </a> Correct interpretation</h4>
<ul>
<li>
 We need <i>just one set</i> <span class='latexinline'>
<span style="font-style:italic">S</span></span> of size <span class='latexinline'>
<span style="font-style:italic">n</span></span> to be shattered by <span class='latexinline'>
<span style="font-style:italic">H</span></span>. We get
  to pick the set <span class='latexinline'>
<span style="font-style:italic">S</span></span>.
</li>

</ul>

<h4><a id=subtletly-1 href='#subtletly-1'> § </a> Subtletly 1:</h4>
<ul>
<li>
 We do not need <i>all sets</i> of size <span class='latexinline'>
<span style="font-style:italic">n</span></span> to be shattered by <span class='latexinline'>
<span style="font-style:italic">H</span></span>.
</li>

</ul>

We <b>can</b> have the case where:
<ul>
<li>
 All sets of size 3 are shattered by H
</li>
<li>
 Only one set of size 4 is shattered by H. All other sets of size 4 are not.
</li>
<li>
 Only one size of size 5 is shattered by H. All other sets of size 5 are not.
</li>
<li>
 No set of size 6 is shattered by H.
</li>

</ul>

In this case, the VC dimension of <span class='latexinline'>
<span style="font-style:italic">H</span></span> is <b>5, not 3</b>.
<h4><a id=subtletly-2 href='#subtletly-2'> § </a> Subtletly 2:</h4>
We <b>cannot</b> have the case where:
<ul>
<li>
 All sets of size 3 are shattered by H
</li>
<li>
 No set of size 4 is shattered by H
</li>
<li>
 Some set of size 5 is shattered by H
</li>

</ul>

For contradiction, let <span class='latexinline'>
<span style="font-style:italic">S</span></span> be the set of size <span class='latexinline'>
5</span> that is shattered by <span class='latexinline'>
<span style="font-style:italic">H</span></span>.
Let <span class='latexinline'>
<span style="font-style:italic">T</span>  <span style="font-style:italic">S</span></span>, <span class='latexinline'>
|<span style="font-style:italic">T</span>| = 4</span>. Now, <span class='latexinline'>
<span style="font-style:italic">H</span></span> shatters <span class='latexinline'>
<span style="font-style:italic">T</span></span> since <span class='latexinline'>
<span style="font-style:italic">H</span></span> shatters <span class='latexinline'>
<span style="font-style:italic">S</span></span>.
Hence, Some set of size 4 has been shattered. Contradiction, since we assumed
that no set of size 4 is shattered by <span class='latexinline'>
<span style="font-style:italic">H</span></span>.
So, to prove that sets of size <span class='latexinline'>
(&#X2265; <span style="font-style:italic">n</span>)</span> cannot be shattered, it suffices
to prove that sets of size equal to <span class='latexinline'>
<span style="font-style:italic">n</span></span> cannot be shattered.
<h4><a id=for-a-fixed-mber-of-sets-shattered-in- href='#for-a-fixed-mber-of-sets-shattered-in-'> § </a> Growth of number of sets shattered in <span class='latexinline'>
|<span style="font-style:italic">S</span>|</span> for <span class='latexinline'>
<span style="font-style:italic">S</span> &#X2286; <span style="font-style:italic">X</span></span> for a fixed <span class='latexinline'>
<span style="font-style:italic">H</span></span>.</h4>
If we fix a hypothesis class <span class='latexinline'>
<span style="font-style:italic">H</span></span> for <span class='latexinline'>
<span style="font-style:italic">X</span></span>, and we want to understand how <span class='latexinline'>
<span style="font-style:italic">H</span></span>
varies over subsets of <span class='latexinline'>
<span style="font-style:italic">X</span></span>, the idea is this:
Let <span class='latexinline'>
<span style="font-style:italic">S</span></span> be a set that is the maximum sized set that is shattered by <span class='latexinline'>
<span style="font-style:italic">X</span></span>. ie,
<span class='latexinline'>
|<span style="font-style:italic">S</span>| = <span style="font-style:italic">Vcdim</span>(<span style="font-style:italic">H</span>)</span> and <span class='latexinline'>
<span style="font-style:italic">H</span></span> shatters <span class='latexinline'>
<span style="font-style:italic">S</span></span>.
Now, the idea is this:
<ul>
<li>
 For subsets <span class='latexinline'>
<span style="font-style:italic">T</span> &#X2286; <span style="font-style:italic">S</span></span>, <span class='latexinline'>
|<span style="font-style:italic">act</span><sub><span style="font-style:italic">T</span></sub>(<span style="font-style:italic">H</span>)| = 2<sup>|<span style="font-style:italic">T</span>|</sup></span> -- exponential.
</li>
<li>
 For subpersets <span class='latexinline'>
<span style="font-style:italic">S</span>  <span style="font-style:italic">Sup</span></span>, <span class='latexinline'>
|<span style="font-style:italic">act</span><sub><span style="font-style:italic">Sup</span></sub>(<span style="font-style:italic">H</span>) = <span style="font-style:italic">Comb</span>(|<span style="font-style:italic">Sup</span>|, |<span style="font-style:italic">S</span>)</span> -- polynomial.
</li>

</ul>

We can show that this exponential/polynomial behaviour happens in general
for <span class='latexinline'>
<span style="font-style:italic">S</span> &#X2286; <span style="font-style:italic">X</span></span>. 
<h2><a id=symplectic-version-of-classical-mechanics href='#symplectic-version-of-classical-mechanics'> § </a><a href=#symplectic-version-of-classical-mechanics>
Symplectic version of classical mechanics</a>
</h2>
<h4><a id=omegas-symplectic-mechanics-as-inverting- href='#omegas-symplectic-mechanics-as-inverting-'> § </a> Basics, symplectic mechanics as inverting <span class='latexinline'>
&#X3C9;</span>:</h4>
I've never seen this kind of "inverting <span class='latexinline'>
&#X3C9;</span>" perspective written down
anywhere.  Most of them start by using the inteior product <span class='latexinline'>
<span style="font-style:italic">i</span><sub><span style="font-style:italic">X</span></sub> &#X3C9;</span> without
ever showing where the thing came from. This is my personal interpretation of
how the symplectic version of classical mecanics comes to be.
If we have a non-degenerate, closed 
two-form <span class='latexinline'>
&#X3C9;: <span style="font-style:italic">T</span><sub><span style="font-style:italic">p</span></sub><span style="font-style:italic">M</span> &#XD7; <span style="font-style:italic">T</span><sub><span style="font-style:italic">p</span></sub><span style="font-style:italic">M</span> &#X2192; &#X211D;</span>.
Now, given a hamiltonian <span class='latexinline'>
<span style="font-style:italic">H</span>: <span style="font-style:italic">M</span> &#X2192; &#X211D;</span>, we can construct a
vector field <span class='latexinline'>
<span style="font-style:italic">X</span><sub><span style="font-style:italic">H</span></sub>: <span style="font-style:italic">M</span> &#X2192; <span style="font-style:italic">TM</span></span> under the definition:
<div class='latexblock'><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >partially apply &#X3C9; to see &#X3C9; as a mapping from <span style="font-style:italic">T</span><sub><span style="font-style:italic">p</span></sub> to <span style="font-style:italic">T</span><sub><span style="font-style:italic">p</span></sub><sup>*</sup><span style="font-style:italic">M</span>&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&#X3C9;2:&#XA0;<span style="font-style:italic">T</span><sub><span style="font-style:italic">p</span></sub>&#XA0;<span style="font-style:italic">M</span>&#XA0;&#X2192;&#XA0;<span style="font-style:italic">T</span><sub><span style="font-style:italic">p</span></sub>*<span style="font-style:italic">M</span>&#XA0;&#X2261;&#XA0;&#X3BB;&#XA0;(<span style="font-style:italic">v</span>:&#XA0;<span style="font-style:italic">T</span><sub><span style="font-style:italic">p</span></sub>&#XA0;<span style="font-style:italic">M</span>).&#XA0;&#X3BB;&#XA0;(<span style="font-style:italic">w</span>:&#XA0;<span style="font-style:italic">T</span><sub><span style="font-style:italic">p</span></sub>&#XA0;<span style="font-style:italic">M</span>)&#XA0;.&#XA0;&#X3C9;(<span style="font-style:italic">v</span>,&#XA0;<span style="font-style:italic">w</span>)&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&#X3C9;2<sup>&#X2212;1</sup>:&#XA0;<span style="font-style:italic">T</span><sub><span style="font-style:italic">p</span></sub><sup>*</sup><span style="font-style:italic">M</span>&#XA0;&#X2192;&#XA0;<span style="font-style:italic">T</span><sub><span style="font-style:italic">p</span></sub>&#XA0;<span style="font-style:italic">M</span>;&#XA0;<span style="font-style:italic">dH</span>:&#XA0;<span style="font-style:italic">M</span>&#XA0;&#X2192;&#XA0;<span style="font-style:italic">T</span><sub><span style="font-style:italic">p</span></sub>*&#XA0;<span style="font-style:italic">M</span>&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">X</span><sub><span style="font-style:italic">H</span></sub>&#XA0;&#X2261;&#XA0;&#X3BB;&#XA0;(<span style="font-style:italic">p</span>:&#XA0;<span style="font-style:italic">M</span>)&#XA0;&#X2192;&#XA0;&#X3C9;2<sup>&#X2212;1</sup>&#XA0;(<span style="font-style:italic">dH</span>(<span style="font-style:italic">p</span>))&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">(<span style="font-style:italic">p</span>:&#XA0;<span style="font-style:italic">M</span>)&#XA0;</td><td class="dcell"><table class="display" style="width:100%;"><tr><td class="dcell"  colspan="2"  style="font-size:smaller;;text-align:center">&#XA0;&#XA0;<span style="font-style:italic">dH</span>&#XA0;&#XA0;</td></tr>
<tr><td class="dcell"   style="width:99%;;text-align:center"><hr class="hbar"></td><td class="dcell"   style="width:1%;;text-align:center">&#X25B8;</td></tr>
<tr><td class="dcell"  colspan="2"  style="font-size:smaller;;text-align:center">&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;</td></tr>
</table></td><td class="dcell"><span style="font-style:italic">dH</span>(<span style="font-style:italic">p</span>)&#XA0;:&#XA0;<span style="font-style:italic">T</span><sub><span style="font-style:italic">p</span></sub>*<span style="font-style:italic">M</span>&#XA0;</td><td class="dcell"><table class="display" style="width:100%;"><tr><td class="dcell"  colspan="2"  style="font-size:smaller;;text-align:center">&#XA0;&#XA0;&#X3C9;2<sup>&#X2212;1</sup>&#XA0;&#XA0;</td></tr>
<tr><td class="dcell"   style="width:99%;;text-align:center"><hr class="hbar"></td><td class="dcell"   style="width:1%;;text-align:center">&#X25B8;</td></tr>
<tr><td class="dcell"  colspan="2"  style="font-size:smaller;;text-align:center">&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;</td></tr>
</table></td><td class="dcell">&#X3C9;2<sup>&#X2212;1</sup>(<span style="font-style:italic">dH</span>(<span style="font-style:italic">p</span>)):&#XA0;<span style="font-style:italic">T</span><sub><span style="font-style:italic">p</span></sub><span style="font-style:italic">M</span>&#XA0;</td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">X</span><sub><span style="font-style:italic">H</span></sub>&#XA0;=&#XA0;&#X3C9;2<sup>&#X2212;1</sup>&#XA0;&#X2218;&#XA0;<span style="font-style:italic">dH</span>
</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table>
</div>
This way, given a hamiltonian <span class='latexinline'>
<span style="font-style:italic">H</span>: <span style="font-style:italic">M</span> &#X2192; &#X211D;</span>, we can construct
an associated vector field <span class='latexinline'>
<span style="font-style:italic">X</span><sub><span style="font-style:italic">H</span></sub></span>, in a pretty natural way.
We can also go the other way. Given the <span class='latexinline'>
<span style="font-style:italic">X</span></span>, we can build the <span class='latexinline'>
<span style="font-style:italic">dH</span></span>
under the equivalence:
<div class='latexblock'><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&#X3C9;2<sup>&#X2212;1</sup>&#XA0;&#X2218;&#XA0;<span style="font-style:italic">dH</span>&#XA0;&#XA0;=&#XA0;<span style="font-style:italic">X</span><sub><span style="font-style:italic">H</span></sub></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">dH</span>&#XA0;=&#XA0;&#X3C9;2(<span style="font-style:italic">X</span><sub><span style="font-style:italic">H</span></sub>)&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">&#X222B;</span></td><td class="dcell"><span style="font-style:italic">dH</span>&#XA0;&#XA0;=&#XA0;</td><td class="dcell"><span style="font-size:xx-large">&#X222B;</span></td><td class="dcell">&#X3C9;2(<span style="font-style:italic">X</span><sub><span style="font-style:italic">H</span></sub>)&#XA0;&#XA0;</td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">H</span>&#XA0;=&#XA0;</td><td class="dcell"><span style="font-size:xx-large">&#X222B;</span></td><td class="dcell">&#X3C9;2(<span style="font-style:italic">X</span><sub><span style="font-style:italic">H</span></sub>)&#XA0;
</td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table>
</div>
This needs some demands, like the one-form <span class='latexinline'>
<span style="font-style:italic">dH</span></span> being integrable. But this
works, and gives us a bijection between <span class='latexinline'>
<span style="font-style:italic">X</span><sub><span style="font-style:italic">H</span></sub></span> and <span class='latexinline'>
<span style="font-style:italic">H</span></span> as we wanted.
We can also analyze the definition we got from the previous manipulation:
<div class='latexblock'><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&#X3C9;2(<span style="font-style:italic">X</span><sub><span style="font-style:italic">H</span></sub>)&#XA0;=&#XA0;&#XA0;<span style="font-style:italic">dH</span>&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&#X3BB;&#XA0;(<span style="font-style:italic">w</span>:&#XA0;<span style="font-style:italic">T</span><sub><span style="font-style:italic">p</span></sub>&#XA0;<span style="font-style:italic">M</span>)&#XA0;&#X3C9;(<span style="font-style:italic">X</span><sub><span style="font-style:italic">H</span></sub>,&#XA0;<span style="font-style:italic">w</span>)&#XA0;=&#XA0;<span style="font-style:italic">dH</span>&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&#X3C9;(<span style="font-style:italic">X</span><sub><span style="font-style:italic">H</span></sub>,&#XA0;&#XB7;)&#XA0;=&#XA0;<span style="font-style:italic">dH</span>&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table>
</div>
We can take this as a <i>relationship</i> between <span class='latexinline'>
<span style="font-style:italic">X</span><sub><span style="font-style:italic">H</span></sub></span> and <span class='latexinline'>
<span style="font-style:italic">dH</span></span>. Exploiting
this, we can notice that <span class='latexinline'>
<span style="font-style:italic">dH</span>(<span style="font-style:italic">X</span><sub><span style="font-style:italic">H</span></sub>) = 0</span>. That is, moving along <span class='latexinline'>
<span style="font-style:italic">X</span><sub><span style="font-style:italic">H</span></sub></span> does
not modify <span class='latexinline'>
<span style="font-style:italic">dH</span></span>:
<div class='latexblock'><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&#X3C9;2(<span style="font-style:italic">X</span><sub><span style="font-style:italic">H</span></sub>)&#XA0;=&#XA0;&#XA0;<span style="font-style:italic">dH</span>&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&#X3BB;&#XA0;(<span style="font-style:italic">w</span>:&#XA0;<span style="font-style:italic">T</span><sub><span style="font-style:italic">p</span></sub>&#XA0;<span style="font-style:italic">M</span>)&#XA0;&#X3C9;(<span style="font-style:italic">X</span><sub><span style="font-style:italic">H</span></sub>,&#XA0;<span style="font-style:italic">w</span>)&#XA0;=&#XA0;<span style="font-style:italic">dH</span>&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">dH</span>(<span style="font-style:italic">X</span><sub><span style="font-style:italic">H</span></sub>)&#XA0;=&#XA0;&#X3C9;(<span style="font-style:italic">X</span><sub><span style="font-style:italic">H</span></sub>,&#XA0;<span style="font-style:italic">X</span><sub><span style="font-style:italic">H</span></sub>)&#XA0;=&#XA0;0&#XA0;&#XA0;&#XA0;&#X3C9; is anti-symmetric
</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table>
</div>
<h4><a id=omegarvation-of- href='#omegarvation-of-'> § </a> Preservation of <span class='latexinline'>
&#X3C9;</span></h4>
We wish to show that <span class='latexinline'>
<span style="font-style:italic">X</span><sub><span style="font-style:italic">H</span></sub><sup>*</sup>(&#X3C9;) = &#X3C9;</span>. That is, pushing forward
<span class='latexinline'>
&#X3C9;</span> along the vector field <span class='latexinline'>
<span style="font-style:italic">X</span><sub><span style="font-style:italic">H</span></sub></span> preserves <span class='latexinline'>
&#X3C9;</span>.
TODO.
<h4><a id=moment-map href='#moment-map'> § </a> Moment Map</h4>
Now that we have a method of going from a vector field <span class='latexinline'>
<span style="font-style:italic">X</span><sub><span style="font-style:italic">H</span></sub></span> to a Hamiltonian
<span class='latexinline'>
<span style="font-style:italic">H</span></span>, we can go crazier with this. We can <i>generate vector fields</i> using
Lie group actions on the manifold, and then look for hamiltonians corresponding
to this lie group. This lets us perform "inverse Noether", where for a given
choice of symmetry, we can find the Hamiltonian that possesses this symmetry.
We can create a map from the Lie algebra <span class='latexinline'>
<span style="font-style:italic">g</span> &#X2208; <span style="font-style:italic">G</span></span> to
a vector field <span class='latexinline'>
<span style="font-style:italic">X</span><sub> <span style="font-style:italic">g</span></sub></span>, performing:
<div class='latexblock'><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">t</span>&#XA0;:&#XA0;&#X211D;&#XA0;&#X21A6;&#XA0;<span style="font-style:italic">e</span><sup><span style="font-style:italic">t</span>&#XA0;<span style="font-style:italic">g</span></sup>&#XA0;:&#XA0;<span style="font-style:italic">G</span>&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">t</span>&#XA0;:&#XA0;&#X211D;&#XA0;&#X21A6;&#XA0;&#X3C6;(<span style="font-style:italic">e</span><sup><span style="font-style:italic">t</span>&#XA0;<span style="font-style:italic">g</span></sup>)&#XA0;:&#XA0;<span style="font-style:italic">M</span>&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">X</span><sub>&#XA0;<span style="font-style:italic">g</span></sub>&#XA0;&#X2261;&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell">(&#X3C6;(<span style="font-style:italic">e</span><sup><span style="font-style:italic">t</span>&#XA0;<span style="font-style:italic">g</span></sup>))|<sub><span style="font-style:italic">t</span>&#XA0;=&#XA0;0</sub>:&#XA0;<span style="font-style:italic">TM</span>
</td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table>
</div>
We can then attempt to recover a hamiltonian <span class='latexinline'>
<span style="font-style:italic">H</span><sub> <span style="font-style:italic">g</span></sub></span> from
<span class='latexinline'>
<span style="font-style:italic">X</span><sub> <span style="font-style:italic">g</span></sub></span>. If we get a hamiltonian from this process, then it
will have the right symmetries.
<h3><a id=theorems-for-free href='#theorems-for-free'> § </a> <a href=#theorems-for-free>
Theorems for free</a>
</h3>
These are personal notes I made of a custom notation for denoting the relations
from the theorems for free paper. I developed the notation since I wanted
to keep track of what types are floating around and what the relations are doing.
We interpret types as sets.  If elements belong to the relation, ie, if <code>(a, a') ∈ R ⊂ AxA</code>,
we will denote this as <code>a[A -R- A']a'</code>. We will now write down some inference
rules:
<ol>
<li>
 We define <code>ReflB</code> as <code>a[Bool ReflB Bool]a</code>
</li>
<li>
 We define <code>ReflI</code> as <code>i[Int ReflI Int]i</code>
</li>
<li>
 The product of two relations <code>[A R B]</code>, <code>[X S Y]</code> is called as <code>RxS</code>,
   and is defined as: <code>(a,x)[AxX RxS BxY](b,y)</code> iff: <code>∀ abxy, a[A R B]b ∧ x[X S Y]y</code>.
</li>
<li>
 The list space of a <code>[A R B]</code> is called <code>[A* [A R B] B*]</code>, 
   and is defined as: <code>la[A* [A R B] B*]lb</code> iff:
   <code>∀ la lb, |la| = |lb| ∧ (∀ i, la[i][A R B]lb[i])</code>
</li>
<li>
 The function space of two relations<code>[A R B]</code>, <code>[X S Y]</code> is called <code>[A->X R->S B->Y]</code>,
   and is defined as: <code>f[A->X R->S B->Y]g</code> iff: <code>∀ a b, a[A R B]b => f(a)[X S Y]g(b)</code>.
</li>
<li>
 The type family space of two relations is a function that takes
   a relation <code>[A R B]</code> and produces a new relation: 
   <code>g[FA | [A R B] | FB]h</code>. The relation takes as parameter a relation <code>[A R B]</code>
    for each choice.
</li>
<li>
 The space of relations of <code>∀X.F(X)</code> is a relation defined by:
   <code>g[A->FA | ∀X.F(X) [FA [A R B] FB]| B->FB]h</code>
    <code>∀ A B R, (g A)[FA | [A R B] |  FB](h B)</code>.
</li>

</ol>

<h4><a id=parametricity-theorem href='#parametricity-theorem'> § </a> Parametricity theorem</h4>
The parametricity thm states that for all terms <code>(r: R)</code>, we can deduce
<code>r[R rel(R) R]r</code> where <code>rel(R)</code> is the relation that fits the type, and is
derived from the above rules.
<h4><a id=parametricity-for-lists-when-the-relation-is-a-function href='#parametricity-for-lists-when-the-relation-is-a-function'> § </a> Parametricity for lists when the relation is a function:</h4>
The list space of a <code>[A R B]</code> is called <code>[A* [A R B] B*]</code>, 
and is defined as: <code>la[A* [A R B] B*]lb</code> iff:
<ul>
<li>
 <code>∀ la lb, |la| = |lb| ∧ (∀ i, la[i][A R B]lb[i])</code>
</li>

</ul>

Now, let us take a special case where <code>[A R B]</code> is a function <code>δ: A -> B</code>. That is:
<ul>
<li>
 <code>a[A R B]b</code> iff <code>δ(a) = b</code>.
</li>

</ul>

If this is the case, then we can simplify the math to be:
<ul>
<li>
 <code>la[A* [A R B] B*]lb <=> ∀ la lb, |la| = |lb| ∧ (∀ i, la[i][A R B]lb[i])</code>
</li>
<li>
 <code>la[A* [A R B] B*]lb <=> ∀ la lb, |la| = |lb| ∧ (∀ i, δ(la[i]) = lb[i]</code>
</li>
<li>
 <code>la[A* [A R B] B*]lb <=> ∀ la lb, map δ la = lb</code>
</li>

</ul>

<h4><a id=parametricity-to-prove-rearrangements href='#parametricity-to-prove-rearrangements'> § </a> Parametricity to prove rearrangements</h4>
<ul>
<li>
 <code>r[∀ X. X* -> X*]r</code>
</li>
<li>
 <code>(r A)[A*->A*  | [A*->A* [A R B] B*->B*] |  B*->B*](r B)</code>
</li>
<li>
 <code>as[A* [A R B]  B*]bs => (r A as)[A* [A R B] B*](r B bs)</code>
</li>
<li>
 Pick <code>[A R B]</code> to be a <i>function</i> <code>δ: A -> B</code>. Ie, <code>a[A R B]b</code> iff <code>δ(a) = b</code>.
</li>
<li>
 This lets us convert all occrences of <code>α[A R B]ω</code> into <code>ω = δ(α)</code>.
</li>
<li>
 Hence, <code>as[A* [A R B]  B*]bs</code> becomes <code>map δ as = bs</code>.
</li>
<li>
 Hence, <code>(r A as)[A* [A R B] B*](r B bs)</code> becomes <code>map δ (r A as) = (r B bs)</code>
</li>
<li>
 In toto, this let us replace <code>bs</code> with <code>map δ as</code>. We derive:
</li>
<li>
 <code>map δ (r A as) = (r B bs)</code>
</li>
<li>
 <code>map δ (r A as) = (r B (map δ as)</code>
</li>
<li>
 <code>map δ . (r A) = (r B) . map δ</code>
</li>
<li>
 Replace <code>bs[i]</code> with <code>δ(as[i])</code>to get result:
   <code>δ(r A as[i]) = r B δ(as[i])</code>, which was indeed what we were looking for.
</li>

</ul>

<h4><a id=references href='#references'> § </a> References</h4>
<ul>
<li>
 <a href=https://ecee.colorado.edu/ecen5533/fall11/reading/free.pdf>
Theorems for free by Phil Wadler</a>

</li>

</ul>

<h3><a id=how-to-reason-with-half-open-intervals href='#how-to-reason-with-half-open-intervals'> § </a> <a href=#how-to-reason-with-half-open-intervals>
How to reason with half-open intervals</a>
</h3>
I've always found code that uses half-open intervals far harder to write
than using closed intervals. For example, when performing string processing,
I prefer to write <code>closed</code> over <code>halfopen</code> since I find it easier
to think about:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> <b><font color="#000000">void</font></b> closed(<b><font color="#000000">int</font></b> begin, <b><font color="#000000">int</font></b> end, <b><font color="#000000">char</font></b> *c) { <i><font color="#222222">//easier</font></i>
<font color="#000000">3:</font>   <b><u><font color="#000000">for</font></u></b>(<b><font color="#000000">int</font></b> i = begin; i &lt;= end; ++i) {... }
<font color="#000000">4:</font> }
<font color="#000000">5:</font> 
<font color="#000000">6:</font> <b><font color="#000000">void</font></b> open(<b><font color="#000000">int</font></b> begin, <b><font color="#000000">int</font></b> len, <b><font color="#000000">char</font></b> *c) { <i><font color="#222222">//harder</font></i>
<font color="#000000">7:</font>   <b><u><font color="#000000">for</font></u></b>(<b><font color="#000000">int</font></b> i = begin; i &lt; begin + len; ++i) { ... }
<font color="#000000">8:</font> }
<font color="#000000">9:</font> </tt></pre>
</div>

However, I realised that by changing how I think about this to:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> <b><font color="#000000">void</font></b> open(<b><font color="#000000">int</font></b> begin, <b><font color="#000000">int</font></b> len, <b><font color="#000000">char</font></b> *c) { <i><font color="#222222">//harder</font></i>
<font color="#000000">3:</font>   <b><u><font color="#000000">for</font></u></b>(<b><font color="#000000">int</font></b> i = begin; i != begin + len; ++i)
<font color="#000000">4:</font> }
<font color="#000000">5:</font> </tt></pre>
</div>

It somehow made it way easier to grok.
<ul>
<li>
 I had problems with <code><</code> since I would
  mentally shift from <code>i < begin + len</code> to <code>i <= begin + len - 1</code>. Making
  this move would then make <i>all other reasoning</i> harder, since I had
  keep switching between the <code><</code> and <code><=</code> point of view.
</li>

</ul>

<ul>
<li>
 On the other hand, when using <code>i != begin + len</code>, there was a single location
  to focus on: the point <code>begin + len</code>, and what happens when <code>i</code> reaches it.
</li>

</ul>

Of course, this is old had to anyone who performs loop optimisatison: LLVM
internally converts most comparisons into the <code>a != b</code> form, because it's
easier to analyse. It took me this long it's easier for me to <i>think</i>
in this viewpoint as well.
<h3><a id=how-does-one-build-a-fusion-bomb href='#how-does-one-build-a-fusion-bomb'> § </a> <a href=#how-does-one-build-a-fusion-bomb>
How does one build a fusion bomb?</a>
</h3>
I haven't found anything on the internet that describes how to build
a fusion bomb; it's almost as if this information has been supressed
by governments. However, I'm curious --- would a physics grad student
studying nuclear physics or explosives have the theoretical know-how to
precisely build one, given the raw materials? Or is there some
"secret sauce" that's necessary?
I read on wikipedia that most countries classify the details:
<blockquote> Detailed knowledge of fission and fusion weapons is classified to some degree in virtually every industrialized nation. In the United States, such knowledge can by default be classified as "Restricted Data", even if it is created by persons who are not government employees or associated with weapons programs, in a legal doctrine known as "born secret".</blockquote>
<h3><a id=christoffel-symbols-geometrically href='#christoffel-symbols-geometrically'> § </a> <a href=#christoffel-symbols-geometrically>
Christoffel symbols, geometrically</a>
</h3>
Suppose we have a manifold <span class='latexinline'>
<span style="font-style:italic">M</span></span>. of dimension <span class='latexinline'>
<span style="font-style:italic">d</span></span> that has been embedded isometrically
into <span class='latexinline'>
&#X211D;<sup><span style="font-style:italic">n</span></sup></span>. So we have a function <span class='latexinline'>
<span style="font-style:italic">e</span>: &#X211D;<sup><span style="font-style:italic">d</span></sup> &#X2192; &#X211D;<sup><span style="font-style:italic">n</span></sup></span>
which is the embedding. We will identify <span class='latexinline'>
<span style="font-style:italic">M</span></span> to be the subspace <span class='latexinline'>
<span style="font-style:italic">Im</span>(<span style="font-style:italic">e</span>)</span>.
Recall that <span class='latexinline'>
&#X2202;<sub><span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub></sub> <span style="font-style:italic">e</span> : &#X211D;<sup><span style="font-style:italic">d</span></sup> &#X2192; &#X211D;<sup><span style="font-style:italic">n</span></sup></span>
is defined as:
<div class='latexblock'><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&#X2202;<sub><span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub></sub><span style="font-style:italic">e</span>&#XA0;:&#XA0;&#X211D;<sup><span style="font-style:italic">d</span></sup>&#XA0;&#X2192;&#XA0;&#X211D;<sup><span style="font-style:italic">n</span></sup>&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">[&#X2202;&#XA0;<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub><span style="font-style:italic">e</span>](<span style="font-style:italic">p</span>)&#XA0;&#X2261;
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center">lim</td></tr>
<tr><td class="dcell" style="text-align:center">&#X3B4;&#XA0;<span style="font-style:italic">x</span>&#XA0;&#X2192;&#XA0;0</td></tr>
</table></td><td class="dcell">&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">e</span>(<span style="font-style:italic">p</span>&#XA0;+&#XA0;(0:0,&#XA0;1:0&#X2026;,&#XA0;<span style="font-style:italic">i</span>:&#X3B4;<sub><span style="font-style:italic">x</span></sub>,&#XA0;&#X2026;,&#XA0;<span style="font-style:italic">n</span>:0))&#XA0;&#X2212;&#XA0;<span style="font-style:italic">e</span>(<span style="font-style:italic">p</span>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X3B4;&#XA0;<span style="font-style:italic">x</span></td></tr>
</table></td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table>
</div>
Note that it is a function of type <span class='latexinline'>
&#X211D;<sup><span style="font-style:italic">d</span></sup> &#X2192; &#X211D;<sup><span style="font-style:italic">n</span></sup></span>.
<ul>
<li>
 The tangent space at point <span class='latexinline'>
<span style="font-style:italic">p</span> &#X2208; <span style="font-style:italic">Image</span>(<span style="font-style:italic">e</span>)</span> is going to be spanned by
  the basis <span class='latexinline'>
{ &#X2202;<sub><span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub></sub><span style="font-style:italic">e</span> |<sub><span style="font-style:italic">p</span></sub> : &#X211D;<sup><span style="font-style:italic">n</span></sup> }</span>.
</li>
<li>
 The metric tensor of <span class='latexinline'>
<span style="font-style:italic">M</span></span>,
 <span class='latexinline'>
<span style="font-style:italic">g</span><sub><span style="font-style:italic">ij</span></sub> &#X2261; &#X27E8; &#X2202; <span style="font-style:italic">e</span>/&#X2202; <span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub> | &#X2202; <span style="font-style:italic">e</span>/&#X2202; <span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub> &#X27E9;</span>.
 That is, the metric tensor "agrees" with the dot product of the
 ambient space <span class='latexinline'>
&#X211D;<sup><span style="font-style:italic">n</span></sup></span>.
</li>
<li>
 A vector field <span class='latexinline'>
<span style="font-style:italic">V</span></span> on the manifold <span class='latexinline'>
<span style="font-style:italic">M</span></span> is by definition a combination of
  the tangent vector fields. <span class='latexinline'>
<span style="font-style:italic">V</span>(<span style="font-style:italic">p</span><sub>0</sub>) &#X2261; <span style="font-style:italic">v</span><sup><span style="font-style:italic">j</span></sup>(<span style="font-style:italic">p</span><sub>0</sub>) &#X2202;<sub><span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub></sub> <span style="font-style:italic">e</span>(<span style="font-style:italic">p</span><sub>0</sub>)</span>
</li>

</ul>

We can calculate the derivaive of this vector field as follows:
<div class='latexblock'><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">V</span>(<span style="font-style:italic">p</span>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">x</span><sup><span style="font-style:italic">i</span></sup></td></tr>
</table></td><td class="dcell">&#XA0;</td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">=&#XA0;&#X2202;<sub><span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub></sub>&#XA0;</td><td class="dcell">&#X23A1;<br>
&#X23A3;</td><td class="dcell"><span style="font-style:italic">v</span><sub><span style="font-style:italic">j</span></sub>(<span style="font-style:italic">p</span>)&#XA0;&#X2202;<sub><span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub></sub>&#XA0;<span style="font-style:italic">e</span>&#XA0;</td><td class="dcell">&#X23A4;<br>
&#X23A6;</td><td class="dcell">&#XA0;&#XA0;&#XA0;&#XA0;</td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >=&#XA0;<span style="font-style:italic">v</span><sup><span style="font-style:italic">j</span></sup>&#XA0;&#XB7;&#XA0;&#X2202;<sub><span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub></sub>&#XA0;&#X2202;<sub><span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub></sub>&#XA0;<span style="font-style:italic">e</span>&#XA0;+&#XA0;&#X2202;<sub><span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub></sub><span style="font-style:italic">e</span>&#XA0;&#XB7;&#XA0;&#X2202;<sub><span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub></sub>&#XA0;<span style="font-style:italic">v</span><sup><span style="font-style:italic">j</span></sup>
</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table>
</div>
We choose to rewrite the second degree term in terms of the tangent
space, and some component that is normal to us that we have no
control over.
<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(&#X2202;<sub><span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub></sub>&#XA0;&#X2202;<sub><span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub></sub>&#XA0;<span style="font-style:italic">e</span>&#XA0;)(<span style="font-style:italic">p</span>)&#XA0;&#X2261;&#XA0;&#X393;<sub><span style="font-style:italic">ij</span></sub><sup><span style="font-style:italic">k</span></sup>&#XA0;&#X2202;<sub><span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub></sub>&#XA0;<span style="font-style:italic">e</span>&#XA0;+&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2192;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
</table></td></tr>
</table></div>
This gives us the Christoffel symbols as "variation of second derivative <i>along</i>
the manifold.
<h4><a id=relationship-to-the-levi-cevita-connection href='#relationship-to-the-levi-cevita-connection'> § </a> Relationship to the Levi-Cevita connection</h4>
The covariant derivative defined by the Levi-Cevita connection is the derivative
that contains the projection of the full derivative in <span class='latexinline'>
&#X211D;<sup><span style="font-style:italic">n</span></sup></span> onto
the tangent space <span class='latexinline'>
<span style="font-style:italic">T</span><sub><span style="font-style:italic">p</span></sub> <span style="font-style:italic">M</span></span>. This is defined by the equations:
<div class='latexblock'><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">&#X2207;<sub><span style="font-style:italic">e</span><sub><span style="font-style:italic">i</span></sub></sub>&#XA0;<span style="font-style:italic">V</span>&#XA0;&#X2261;&#XA0;&#X2202;<sub><span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub></sub>&#XA0;<span style="font-style:italic">V</span>&#XA0;&#X2212;&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2192;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
</table></td><td class="dcell">&#XA0;&#XA0;</td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">=&#XA0;&#X3A0;</td><td class="dcell"><table class="display"><tr><td class="dcell">&nbsp;</td></tr>
<tr><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2192;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
</table></td><td class="dcell"><sup>&#X22A5;</sup></td></tr>
</table></td></tr>
</table></td><td class="dcell">&#XA0;</td><td class="dcell">&#X23A1;<br>
&#X23A3;</td><td class="dcell"><span style="font-style:italic">v</span><sup><span style="font-style:italic">j</span></sup>&#XA0;&#XB7;&#XA0;&#X2202;<sub><span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub></sub>&#XA0;&#X2202;<sub><span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub></sub>&#XA0;<span style="font-style:italic">e</span>&#XA0;+&#XA0;&#X2202;<sub><span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub></sub><span style="font-style:italic">e</span>&#XA0;&#XB7;&#XA0;&#X2202;<sub><span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub></sub>&#XA0;<span style="font-style:italic">v</span><sup><span style="font-style:italic">j</span></sup>&#XA0;</td><td class="dcell">&#X23A4;<br>
&#X23A6;</td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">=&#XA0;&#X3A0;</td><td class="dcell"><table class="display"><tr><td class="dcell">&nbsp;</td></tr>
<tr><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2192;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
</table></td><td class="dcell"><sup>&#X22A5;</sup></td></tr>
</table></td></tr>
</table></td><td class="dcell">&#XA0;</td><td class="dcell">&#X23A1;<br>
&#X23A2;<br>
&#X23A2;<br>
&#X23A3;</td><td class="dcell"><span style="font-style:italic">v</span><sup><span style="font-style:italic">j</span></sup>&#XA0;&#XB7;&#XA0;(&#X393;<sub><span style="font-style:italic">ij</span></sub><sup><span style="font-style:italic">k</span></sup>&#XA0;&#X2202;<sub><span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub></sub>&#XA0;<span style="font-style:italic">e</span>&#XA0;+&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2192;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
</table></td><td class="dcell">)+&#XA0;&#X2202;<sub><span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub></sub><span style="font-style:italic">e</span>&#XA0;&#XB7;&#XA0;&#X2202;<sub><span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub></sub>&#XA0;<span style="font-style:italic">v</span><sup><span style="font-style:italic">j</span></sup>&#XA0;</td><td class="dcell">&#X23A4;<br>
&#X23A5;<br>
&#X23A5;<br>
&#X23A6;</td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">=&#XA0;<span style="font-style:italic">v</span><sup><span style="font-style:italic">j</span></sup>&#XA0;&#XB7;&#XA0;(&#X393;<sub><span style="font-style:italic">ij</span></sub><sup><span style="font-style:italic">k</span></sup>&#XA0;&#X2202;<sub><span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub></sub>&#XA0;<span style="font-style:italic">e</span>&#XA0;+&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2192;</td></tr>
<tr><td class="dcell" style="text-align:center">0</td></tr>
<tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
</table></td><td class="dcell">)&#XA0;+&#XA0;&#X2202;<sub><span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub></sub><span style="font-style:italic">e</span>&#XA0;&#XB7;&#XA0;&#X2202;<sub><span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub></sub>&#XA0;<span style="font-style:italic">v</span><sup><span style="font-style:italic">j</span></sup>&#XA0;</td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">=&#XA0;<span style="font-style:italic">v</span><sup><span style="font-style:italic">j</span></sup>&#XA0;&#XB7;&#XA0;(&#X393;<sub><span style="font-style:italic">ij</span></sub><sup><span style="font-style:italic">k</span></sup>&#XA0;&#X2202;<sub><span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub></sub>&#XA0;<span style="font-style:italic">e</span>&#XA0;+&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2192;</td></tr>
<tr><td class="dcell" style="text-align:center">0</td></tr>
<tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
</table></td><td class="dcell">)&#XA0;+&#XA0;&#X2202;<sub><span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub></sub><span style="font-style:italic">e</span>&#XA0;&#XB7;&#XA0;&#X2202;<sub><span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub></sub>&#XA0;<span style="font-style:italic">v</span><sup><span style="font-style:italic">k</span></sup>&#XA0;</td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >=&#XA0;<span style="font-style:italic">v</span><sup><span style="font-style:italic">j</span></sup>&#XA0;&#XB7;&#XA0;&#X393;<sub><span style="font-style:italic">ij</span></sub><sup><span style="font-style:italic">k</span></sup>&#XA0;&#X2202;<sub><span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub></sub>&#XA0;<span style="font-style:italic">e</span>&#XA0;&#XA0;+&#XA0;&#X2202;<sub><span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub></sub><span style="font-style:italic">e</span>&#XA0;&#XB7;&#XA0;&#X2202;<sub><span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub></sub>&#XA0;<span style="font-style:italic">v</span><sup><span style="font-style:italic">k</span></sup>&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">=&#XA0;&#X2202;<sub><span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub></sub>&#XA0;<span style="font-style:italic">e</span>&#XA0;</td><td class="dcell">&#X239B;<br>
&#X239D;</td><td class="dcell"><span style="font-style:italic">v</span><sup><span style="font-style:italic">j</span></sup>&#XA0;&#XB7;&#XA0;&#X393;<sub><span style="font-style:italic">ij</span></sub><sup><span style="font-style:italic">k</span></sup>&#XA0;&#XA0;+&#XA0;&#X2202;<sub><span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub></sub>&#XA0;<span style="font-style:italic">v</span><sup><span style="font-style:italic">k</span></sup>&#XA0;</td><td class="dcell">&#X239E;<br>
&#X23A0;</td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table>
</div>
<h4><a id=references href='#references'> § </a> References</h4>
<ul>
<li>
 <a href=https://en.wikipedia.org/wiki/Covariant_derivative#Informal_definition_using_an_embedding_into_Euclidean_space>
The wikipedia page on Covariant derivative</a>

</li>

</ul>

<h3><a id=a-natural-vector-space-without-an-explicit-basis href='#a-natural-vector-space-without-an-explicit-basis'> § </a> <a href=#a-natural-vector-space-without-an-explicit-basis>
A natural vector space without an explicit basis</a>
</h3>
On learning about infinite dimensional vector spaces, one learns that
we need to use the axiom of choice to assert that every such vector space
has a basis; indeed, it's equivalent to the AoC to assert this. However,
I had not known any "natural" examples of such a vector space till I studied
the proof of the barvinok algorithm. I produce the example here.
Consider a space such as <span class='latexinline'>
<span style="font-style:italic">S</span> &#X2261; &#X211D;<sup>3</sup></span>. Now, consider the vector
space spanned by the indicator functions of polyhedra in <span class='latexinline'>
<span style="font-style:italic">S</span></span>. that's a mouthful,
so let's break it down.
A polyhedra is defined as a set of points that is defined by linear
inequalities: <span class='latexinline'>
<span style="font-style:italic">P</span> &#X2261; { <span style="font-style:italic">x</span> &#X2208; <span style="font-style:italic">S</span> : <span style="font-style:italic">a</span><sub><span style="font-style:italic">i</span></sub> &#XB7; <span style="font-style:italic">x</span> &#X2264; <span style="font-style:italic">b</span><sub><span style="font-style:italic">i</span></sub>, <span style="font-style:italic">i</span> &#X2208; [1&#X2026; <span style="font-style:italic">n</span>] }</span>,
for all <span class='latexinline'>
<span style="font-style:italic">a</span><sub><span style="font-style:italic">i</span></sub> &#X2208; <span style="font-style:italic">S</span></span>, <span class='latexinline'>
<span style="font-style:italic">b</span> &#X2208; &#X211D;</span>.
The indicator functions are of the form:
<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">[<span style="font-style:italic">poly</span>]:&#XA0;<span style="font-style:italic">S</span>&#XA0;&#X2192;&#XA0;&#X211D;;
[<span style="font-style:italic">poly</span>](<span style="font-style:italic">x</span>)&#XA0;&#X2261;
</td><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell">&#X23A7;<br>
&#X23A8;<br>
&#X23A9;</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >1</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">x</span>&#XA0;&#X2208;&#XA0;<span style="font-style:italic">poly</span>&#XA0;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >0</td><td style="text-align:left;white-space:nowrap" >otherwise&#XA0;</td></tr>
</table></td></tr>
</table></td></tr>
</table></div>
we can define a vector space of these functions over <span class='latexinline'>
&#X211D;</span>, using
the "scaling" action as the action of <span class='latexinline'>
&#X211D;</span> on these functions:
The vector space <span class='latexinline'>
<span style="font-style:italic">V</span></span> is <b>defined</b> as the span of the indicator functions
of all polyhedra. It's clearly a vector space, and a hopefully intuitive
one. However, note that the set we generated this from (indicators of polyhedra)
don't form a basis since they have many linear dependencies between them.
For example, one can write the equation:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> *---*   *-*   *-*   *
<font color="#000000">3:</font> |###|   |#|   |#|   |
<font color="#000000">4:</font> |###| = |#| + |#| - |
<font color="#000000">5:</font> |###|   |#|   |#|   |
<font color="#000000">6:</font> *---*   *-*   *-*   *
<font color="#000000">7:</font> </tt></pre>
</div>

<h3><a id=cache-oblivious-b-trees href='#cache-oblivious-b-trees'> § </a> <a href=#cache-oblivious-b-trees>
Cache oblivious B trees</a>
</h3>
Central idea: assume a memory model where computation is free, only cost
is pulling data from cache into memory. Cache has total size <span class='latexinline'>
<span style="font-style:italic">M</span></span>, can hold
blocks of size <span class='latexinline'>
<span style="font-style:italic">B</span></span>. So it can hold <span class='latexinline'>
<span style="font-style:italic">M</span>/<span style="font-style:italic">B</span></span> blocks of main memory. Memory memory
has infinite size. Cost is number of transfers.
We assume that the algorithm <i>does not know M or B</i>. We assume that the cache
replacement strategy is optimal (kick out block that is going to be used
farthest in the future). This is an OK assumption to make since an LRU cache
using <i>twice</i> the memory of a "oracular" cache performs equally well (citation?)
These data structures are cool since they essentially "Adapt" to varying cache
hierarchies and even multiple level cache hierarchies.
We study how to build cache-oblivious B-trees.
<h4><a id=building-optimal-cache-oblivious-b-trees-to-solve-search href='#building-optimal-cache-oblivious-b-trees-to-solve-search'> § </a> Building optimal cache-oblivious B trees to solve search</h4>
<ul>
<li>
 We use a balanced BST. We want to find an order to store nodes in memory
  such that when we search for an element, we minimize number of blocks
  we need to pull in.
</li>
<li>
 All standard orders such as level order, pre-order, post-order fail.
</li>
<li>
 Corrrect order is "VEB (Van Em De Boas) order": carve a tree at the middle
  level of its edges. Layout a "triangle" or smaller collection
  of nodes linearly. Then Recursively layout the trees, linearly in memory.
</li>
<li>
 Supposedly if the number of nodes is <span class='latexinline'>
<span style="font-style:italic">N</span></span>, we wil have roughly <span class='latexinline'>
&#X221A;<span style="text-decoration:overline">(</span><span style="font-style:italic">N</span>)</span>
  nodes on the top, and then <span class='latexinline'>
&#X221A;<span style="text-decoration:overline">(</span><span style="font-style:italic">N</span>)</span> <i>triangles</i> at the bottom.
</li>

</ul>

<h4><a id=for-any-search-queryeed-to-pull- href='#for-any-search-queryeed-to-pull-'> § </a> Analysis Claim: we need to pull <span class='latexinline'>
<span style="font-style:italic">O</span>(log<sub><span style="font-style:italic">B</span></sub> <span style="font-style:italic">N</span>)</span> blocks for any <span class='latexinline'>
<span style="font-style:italic">B</span></span> for any search query</h4>
<span class='latexinline'>
<span style="font-style:italic">N</span></span> is the number of nodes in the BST. Note that in the analysis, <i>we know what B is</i>,
even though the <i>algorithm does not</i>.
<ul>
<li>
 We look at a particuar level of recursion. We will call it a "level of detail"
  straddling B.
</li>
<li>
 We will have large triangles of size <span class='latexinline'>
&#X2265; <span style="font-style:italic">B</span></span>, inside which there are smaller
  triangles of size <span class='latexinline'>
&#X2264; <span style="font-style:italic">B</span></span> (reminds me of sierpinski).
</li>
<li>
 We know that the algorithm recursively lays it out, and triangle stores
  everything "inside" it <i>in a contiguous region</i>. So we stop at the
  requisite size where we know that the tree's triangles themselves
  contain triangles which fit into the block size.
</li>
<li>
 A little triangle of size less than B can live in at most two memory blocks
  by straddling a block boundary: by eg. having <span class='latexinline'>
(<span style="font-style:italic">B</span>&#X2212;1)</span> bits in one block
  and a single bit in another block.
</li>

</ul>

<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> 1 2 3 4 5 6 7 8 &lt;- index
<font color="#000000">3:</font> |     |       | &lt;- boundary
<font color="#000000">4:</font> |-xxxxxxx-----| &lt;-  data
<font color="#000000">5:</font> </tt></pre>
</div>

<ul>
<li>
 The question is that on a root-to-leaf bpath, how many such triangles do
  we need to visit. Since we repeatedly divide the nodes in half 
  <i>with respect to height</i> until the little triangle has number of nodes less
  than <span class='latexinline'>
<span style="font-style:italic">B</span></span>, the height is going to be <span class='latexinline'>
<span style="font-style:italic">O</span>(log<span style="font-style:italic">B</span>)</span> since it's still a binary tree.
</li>
<li>
 total height in <span class='latexinline'>
<span style="font-style:italic">O</span>(log<span style="font-style:italic">N</span>)</span>.
</li>
<li>
 so height of "chunked tree" where we view each triangle as a single node
  is <span class='latexinline'>
log<span style="font-style:italic">N</span> / log<span style="font-style:italic">B</span> = log<sub><span style="font-style:italic">B</span></sub> <span style="font-style:italic">n</span></span>.
</li>
<li>
 <b>insight</b>: ou data structure construction in some sense permits us to
  "binary search on <span class='latexinline'>
<span style="font-style:italic">B</span></span>" since we divide the data structure into levels
  based on <span class='latexinline'>
<span style="font-style:italic">B</span></span>. if <span class='latexinline'>
<span style="font-style:italic">B</span> = <span style="font-style:italic">N</span></span>, then the full data structure fits into memory
  and we're good.
</li>

</ul>

<h4><a id=black-box-ordered-file-maintainince href='#black-box-ordered-file-maintainince'> § </a> Black box: ordered file maintainince</h4>
We need a black box: ordered file maintainance (linked list for arrays)
<ul>
<li>
 Store <span class='latexinline'>
<span style="font-style:italic">n</span></span> elements in specified order in an array of linear size <span class='latexinline'>
<span style="font-style:italic">O</span>(<span style="font-style:italic">N</span>)</span>.
  Array permits gaps.
</li>
<li>
 updates: delete element, insert elements between 2 elements.
</li>
<li>
 cannot do this in linear time, but we can move elements in an interval of
  size <span class='latexinline'>
log<sup>2</sup>(<span style="font-style:italic">N</span>)</span> amortized.
</li>
<li>
 We need <span class='latexinline'>
<span style="font-style:italic">O</span>(1)</span> scans for the data structure.
</li>

</ul>

<h4><a id=bst-inserts-and-deletes-layout href='#bst-inserts-and-deletes-layout'> § </a> Next: <i>dynamic</i> BST (inserts and deletes): layout</h4>
we take a VEB static tree on top of an ordered file. Tree is a segtree
that has max of nodes. Leaves are the members of the ordered file.
<h4><a id=updates href='#updates'> § </a> Updates</h4>
<ul>
<li>
 search for node.
</li>
<li>
 update ordered file.
</li>
<li>
 propogate updates into the tree. This will have to be done in post-order
  because we need the leaves to be fixed before we can update the parent
  <code>max</code>.
</li>

</ul>

<h4><a id=updates-analysis href='#updates-analysis'> § </a> Updates: analysis.</h4>
<ul>
<li>
 look at level of detail that straddles <span class='latexinline'>
<span style="font-style:italic">B</span></span>.
</li>
<li>
 Let us look at the bottom 2 levels.
</li>
<li>
 Note that when we perform post-order inside a triangle that has 3 triangles
  of size <span class='latexinline'>
&#X2264; <span style="font-style:italic">B</span></span>, we need to alternate between parent triangle and child triangle.
  Since the parent triangle is of size <span class='latexinline'>
&#X2264; <span style="font-style:italic">B</span></span> and can therefore take
  at most <span class='latexinline'>
2<span style="font-style:italic">B</span></span> blocks of memory, similarly the child can take at most <span class='latexinline'>
2<span style="font-style:italic">B</span></span>
  blocks of memory.
</li>
<li>
 So if our cache can hold <span class='latexinline'>
4</span> blocks of memory, we're done.
  We won't need to kick anything out when performing the post-order
  traversal.
</li>
<li>
 For levels that are above the bottom 2 levels, we're still OK. there
  are not many triangles! / not many nodes! (<code>1:16:00</code> in the video)
</li>

</ul>

<h4><a id=references href='#references'> § </a> References</h4>
<ul>
<li>
 <a href=https://courses.csail.mit.edu/6.851/fall17/lectures/L07.html?notes=5>
Erik demaine, advanced data structures, lecture 7: Memory hiearchy: models, cache oblivious B trees</a>

</li>

</ul>

<h3><a id=krohn-rhodes-decomposition href='#krohn-rhodes-decomposition'> § </a> <a href=#krohn-rhodes-decomposition>
Krohn-Rhodes decomposition</a>
</h3>
We denote partial functions with <span class='latexinline'>
<span style="font-style:italic">X</span> &#X21C0; <span style="font-style:italic">Y</span></span> and total functions
with <span class='latexinline'>
<span style="font-style:italic">X</span> &#X2192; <span style="font-style:italic">Y</span></span>.
A set <span class='latexinline'>
<span style="font-style:italic">X</span></span> equipped with a binary operator
<span class='latexinline'>
&#X22C6;: <span style="font-style:italic">X</span> &#XD7; <span style="font-style:italic">X</span> &#X2192; <span style="font-style:italic">X</span></span> which is closed and associative
is a semigroup.
<h4><a id=partial-function-semigroup href='#partial-function-semigroup'> § </a> Partial function semigroup</h4>
For a ground set <span class='latexinline'>
<span style="font-style:italic">X</span></span>, the set of partial functions <span class='latexinline'>
<span style="font-style:italic">Pf</span>(<span style="font-style:italic">X</span>) &#X2261; { <span style="font-style:italic">f</span>: <span style="font-style:italic">X</span> &#X21C0; <span style="font-style:italic">X</span> }</span>
along with function composition forms a semigroup. This is in fact stronger
than a semigroup. There exists:
<ul>
<li>
 An identify function <span class='latexinline'>
<span style="font-style:italic">e</span><sub><span style="font-style:italic">x</span></sub>: <span style="font-style:italic">X</span> &#X2192; <span style="font-style:italic">X</span>; <span style="font-style:italic">e</span><sub><span style="font-style:italic">X</span></sub>(<span style="font-style:italic">x</span>) = <span style="font-style:italic">x</span></span>
</li>
<li>
 A zero function <span class='latexinline'>
&#X3B8;<sub><span style="font-style:italic">x</span></sub>: <span style="font-style:italic">X</span> &#X21C0; <span style="font-style:italic">X</span>; &#X3B8;<sub><span style="font-style:italic">x</span></sub>(<span style="font-style:italic">x</span>) = <span style="font-style:italic">undef</span></span>, where by
  <span class='latexinline'>
<span style="font-style:italic">undef</span></span> we mean that it is <i>undefined</i>.
</li>

</ul>

<h4><a id=transformation-semigroupts href='#transformation-semigroupts'> § </a> Transformation semigroup(TS)</h4>
Let <span class='latexinline'>
<span style="font-style:italic">Q</span></span> be a set. Let <span class='latexinline'>
<span style="font-style:italic">S</span> &#X2286; <span style="font-style:italic">Pf</span>(<span style="font-style:italic">Q</span>)</span> be a sub-semigroup of <span class='latexinline'>
<span style="font-style:italic">Pf</span>(<span style="font-style:italic">Q</span>)</span>.
Then the semigroup <span class='latexinline'>
<span style="font-style:italic">X</span> &#X2261; (<span style="font-style:italic">Q</span>, <span style="font-style:italic">S</span>)</span> is called as the
 <i>transformation semigroup</i>(X) of states <span class='latexinline'>
<span style="font-style:italic">Q</span></span>.
<ul>
<li>
 The elements of <span class='latexinline'>
<span style="font-style:italic">Q</span></span> are called states of <span class='latexinline'>
<span style="font-style:italic">X</span></span>
</li>
<li>
 while  the elements of <span class='latexinline'>
<span style="font-style:italic">S</span></span> are called  <i>actions</i> of <span class='latexinline'>
<span style="font-style:italic">X</span></span>.
</li>
<li>
 The set <span class='latexinline'>
<span style="font-style:italic">Q</span></span> itself is called as the <i>underlying set</i> of <span class='latexinline'>
<span style="font-style:italic">X</span></span>.
</li>
<li>
 For a fixed transformation semigroup <span class='latexinline'>
<span style="font-style:italic">X</span></span>, we will write <span class='latexinline'>
<span style="font-style:italic">Q</span><sub><span style="font-style:italic">X</span></sub></span> and <span class='latexinline'>
<span style="font-style:italic">S</span><sub><span style="font-style:italic">X</span></sub></span>
  to refer to its states and actions.
</li>

</ul>

We call <span class='latexinline'>
<span style="font-style:italic">X</span> &#X2261; (<span style="font-style:italic">Q</span>, <span style="font-style:italic">S</span>)</span> as a <i>transformation monoid</i> if <span class='latexinline'>
<span style="font-style:italic">S</span></span> contains <span class='latexinline'>
1<sub><span style="font-style:italic">Q</span></sub>(<span style="font-style:italic">q</span>) = <span style="font-style:italic">q</span></span>.
<h4><a id=subtlety-of-being-at-transformation-monoid href='#subtlety-of-being-at-transformation-monoid'> § </a> Subtlety of being at transformation monoid.</h4>
There is some subttlety here. Just because <span class='latexinline'>
<span style="font-style:italic">S</span></span> is a monoid does not mean that
it that is a <i>transformation monoid</i>. It must have the identity element of
<span class='latexinline'>
<span style="font-style:italic">Pf</span>(<span style="font-style:italic">Q</span>)</span> to be called a transformation monoid. For example, consider the
set <span class='latexinline'>
<span style="font-style:italic">Q</span> &#X2261; <br>
 <span style="font-style:italic">a</span>, <span style="font-style:italic">b</span> <br>
</span> and the transformation semigroup <span class='latexinline'>
<span style="font-style:italic">S</span> &#X2261; <br>
 <span style="font-style:italic">f</span> &#X2261; &#X3B1; &#X21A6; <span style="font-style:italic">b</span> <br>
</span>.
Now the set <span class='latexinline'>
<span style="font-style:italic">S</span></span> is indeed a monoid with identity element as <span class='latexinline'>
<span style="font-style:italic">f</span>: <span style="font-style:italic">Q</span> &#X2192; <span style="font-style:italic">Q</span></span>.
however, <span class='latexinline'>
<span style="font-style:italic">f</span> &#X2260; 1<sub><span style="font-style:italic">Q</span></sub></span> , andh ence, <span class='latexinline'>
<span style="font-style:italic">S</span></span> is a not a <i>transformation monoid</i>.
<h4><a id=examples-of-transformation-semigroups href='#examples-of-transformation-semigroups'> § </a> Examples of transformation semigroups</h4>
<ol>
<li>
 <span class='latexinline'>
(<span style="font-style:italic">X</span>, { &#X3B8;(<span style="font-style:italic">x</span>) = <span style="font-style:italic">undef</span> })</span>. The semigroup with the empty transformation.
</li>
<li>
 <span class='latexinline'>
(<span style="font-style:italic">X</span>, &#X2205;)</span>, the semigroup with <i>no</i> transformations.
</li>

</ol>

<h4><a id=semigroup-action href='#semigroup-action'> § </a> Semigroup action</h4>
We sometimes wish to represent a semigroup using an action/transformation semigroup
on a ground set <span class='latexinline'>
<span style="font-style:italic">X</span></span>. So, given some semigroup <span class='latexinline'>
(<span style="font-style:italic">T</span>, &#XD7;)</span> that needs to be represented,
if we can find a morphism <span class='latexinline'>
<span style="font-style:italic">r</span>: <span style="font-style:italic">T</span> &#X2192; <span style="font-style:italic">Pf</span>(<span style="font-style:italic">X</span>)</span> (<span class='latexinline'>
<span style="font-style:italic">r</span></span> for representation)
such that:
<ul>
<li>
 <span class='latexinline'>
 <span style="font-style:italic">r</span>(<span style="font-style:italic">t</span><sub>1</sub> + <span style="font-style:italic">t</span><sub>2</sub>) = <span style="font-style:italic">r</span>(<span style="font-style:italic">t</span><sub>1</sub>) &#X2218; <span style="font-style:italic">r</span>(<span style="font-style:italic">t</span><sub>2</sub>)</span>. [<span class='latexinline'>
<span style="font-style:italic">r</span></span> is a semigroup morphism].
</li>
<li>
 <span class='latexinline'>
<span style="font-style:italic">t</span><sub>1</sub> &#X2260; <span style="font-style:italic">t</span><sub>2</sub>  &#X2203; <span style="font-style:italic">x</span> &#X2208; <span style="font-style:italic">X</span></span> such that <span class='latexinline'>
<span style="font-style:italic">r</span>(<span style="font-style:italic">t</span><sub>1</sub>)(<span style="font-style:italic">x</span>) &#X2260; <span style="font-style:italic">r</span>(<span style="font-style:italic">t</span><sub>2</sub>)(<span style="font-style:italic">x</span>)</span>.
  [Faithfulness].
</li>

</ul>

Put more simply, <span class='latexinline'>
<span style="font-style:italic">t</span><sub>1</sub> &#X2260; <span style="font-style:italic">t</span><sub>2</sub>  <span style="font-style:italic">r</span>(<span style="font-style:italic">t</span><sub>1</sub>) &#X2260; <span style="font-style:italic">r</span>(<span style="font-style:italic">t</span><sub>2</sub>)</span> where we define
function equality extensionally: <span class='latexinline'>
<span style="font-style:italic">f</span> = <span style="font-style:italic">g</span> &#X2261; &#X2200; <span style="font-style:italic">x</span>, <span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>) = <span style="font-style:italic">g</span>(<span style="font-style:italic">x</span>)</span>.
<h4><a id=embedding-actions-into-the-transformation-semigroup href='#embedding-actions-into-the-transformation-semigroup'> § </a> Embedding actions into the transformation semigroup</h4>
We often wish to represent some semigroup <span class='latexinline'>
<span style="font-style:italic">S</span></span> as the transformation semigroup
of some set of states <span class='latexinline'>
<span style="font-style:italic">Q</span></span>. We can achieve this by proving a morphism:
<ul>
<li>
 <span class='latexinline'>
<span style="font-style:italic">r</span>: <span style="font-style:italic">S</span> &#X2192; <span style="font-style:italic">Pf</span>(<span style="font-style:italic">Q</span>)</span> that is faithful.
</li>

</ul>

Then, we can treat elements of <span class='latexinline'>
<span style="font-style:italic">S</span></span> as elements of <span class='latexinline'>
<span style="font-style:italic">Pf</span>(<span style="font-style:italic">Q</span>)</span>.
<h4><a id=completion-of-a-transformation-semigroup href='#completion-of-a-transformation-semigroup'> § </a> Completion of a transformation semigroup</h4>
Given a transformation semigroup <span class='latexinline'>
<span style="font-style:italic">X</span> &#X2261; (<span style="font-style:italic">Q</span>, <span style="font-style:italic">S</span>)</span> we can <i>complete</i> it
by adding a new sink state <span class='latexinline'>
&#X22A5;</span>, and then converting all partial
functions in <span class='latexinline'>
<span style="font-style:italic">S</span></span> to total functions that transition to <span class='latexinline'>
&#X22A5;</span>. We have that
<span class='latexinline'>
&#X22A5; &#XB7; <span style="font-style:italic">s</span> = <span style="font-style:italic">s</span> &#XB7; &#X22A5; &#XA0; &#X2200; <span style="font-style:italic">s</span> &#X2208; <span style="font-style:italic">S</span></span>.
We denote the completion as <span class='latexinline'>
<span style="font-style:italic">X</span><sup><span style="font-style:italic">c</span></sup> &#X2261; (<span style="font-style:italic">Q</span><sup><span style="font-style:italic">c</span></sup>, <span style="font-style:italic">S</span><sup><span style="font-style:italic">c</span></sup>)</span>.
<h4><a id=coverings href='#coverings'> § </a> Coverings</h4>
Let <span class='latexinline'>
<span style="font-style:italic">X</span> &#X2261; (<span style="font-style:italic">Q</span><sub><span style="font-style:italic">X</span></sub>, <span style="font-style:italic">S</span><sub><span style="font-style:italic">X</span></sub>)</span> and <span class='latexinline'>
<span style="font-style:italic">Y</span> &#X2261; (<span style="font-style:italic">Q</span><sub><span style="font-style:italic">Y</span></sub>, <span style="font-style:italic">S</span><sub><span style="font-style:italic">Y</span></sub>)</span> be transformation
semigroups. Let <span class='latexinline'>
&#X3C6; &#X2286; <span style="font-style:italic">Q</span><sub><span style="font-style:italic">Y</span></sub> &#XD7; <span style="font-style:italic">Q</span><sub><span style="font-style:italic">X</span></sub></span> be a relation. Let <span class='latexinline'>
<span style="font-style:italic">s</span><sub><span style="font-style:italic">x</span></sub> &#X2208; <span style="font-style:italic">S</span><sub><span style="font-style:italic">X</span></sub></span>
and <span class='latexinline'>
<span style="font-style:italic">s</span><sub><span style="font-style:italic">y</span></sub> &#X2208; <span style="font-style:italic">S</span><sub><span style="font-style:italic">Y</span></sub></span>. Then, if the following diagram commutes:
<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">a</span></td><td style="text-align:center;white-space:nowrap" >&#X2192;</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">b</span>&#XA0;</td></tr>
<tr><td style="text-align:center;white-space:nowrap" >&#X2193;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&#X2193;&#XA0;</td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">x</span></td><td style="text-align:center;white-space:nowrap" >&#X2192;</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">y</span>&#XA0;</td></tr>
</table></td></tr>
</table></div>
If <span class='latexinline'>
<span style="font-style:italic">s</span><sub><span style="font-style:italic">x</span></sub>(&#X3C6;(<span style="font-style:italic">q</span><sub><span style="font-style:italic">y</span></sub>)) = &#X3C6;(<span style="font-style:italic">t</span><sub><span style="font-style:italic">y</span></sub>(<span style="font-style:italic">q</span><sub><span style="font-style:italic">y</span></sub>))</span>, then we say that <span class='latexinline'>
<span style="font-style:italic">t</span><sub><span style="font-style:italic">y</span></sub></span> covers <span class='latexinline'>
<span style="font-style:italic">s</span><sub><span style="font-style:italic">x</span></sub></span> relative to <span class='latexinline'>
&#X3C6;</span>.
We imagine the <span class='latexinline'>
<span style="font-style:italic">t</span><sub><span style="font-style:italic">y</span></sub></span> lying above <span class='latexinline'>
<span style="font-style:italic">s</span><sub><span style="font-style:italic">x</span></sub></span>, being projected down by <span class='latexinline'>
&#X3C6;</span>.
If a fixed <span class='latexinline'>
&#X3C6;</span>, for all <span class='latexinline'>
<span style="font-style:italic">s</span><sub><span style="font-style:italic">x</span></sub> &#X2208; <span style="font-style:italic">S</span><sub><span style="font-style:italic">X</span></sub></span> there exists a <span class='latexinline'>
<span style="font-style:italic">t</span><sub><span style="font-style:italic">y</span></sub> &#X2208; <span style="font-style:italic">S</span><sub><span style="font-style:italic">Y</span></sub></span> such that
<span class='latexinline'>
<span style="font-style:italic">t</span></span> covers <span class='latexinline'>
<span style="font-style:italic">s</span></span> relative to <span class='latexinline'>
&#X3C6;</span>, then we say that <span class='latexinline'>
&#X3C6;:</span> is a 
<i>relation of automata</i>.
<ul>
<li>
 If <span class='latexinline'>
&#X3C6;: <span style="font-style:italic">Q</span><sub><span style="font-style:italic">Y</span></sub> &#X2192; <span style="font-style:italic">Q</span><sub><span style="font-style:italic">X</span></sub></span> is surjective,
  then we say that <span class='latexinline'>
&#X3C6;</span> is a <b>relational covering</b> and write:
</li>

</ul>

<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">X</span>&#XA0;&#X25C1;<sub>&#X3C6;</sub>&#XA0;<span style="font-style:italic">Y</span>
</td></tr>
</table></div>
<ul>
<li>
 If <span class='latexinline'>
&#X3C6;  <span style="font-style:italic">Q</span><sub><span style="font-style:italic">Y</span></sub> &#XD7; <span style="font-style:italic">Q</span><sub><span style="font-style:italic">X</span></sub> </span> is <i>both</i> surjective and partial,
  then we say that <span class='latexinline'>
&#X3C6;</span> is a <b>covering</b> and write:
</li>

</ul>

<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">X</span>&#XA0;&#X227A;<sub>&#X3C6;</sub><span style="font-style:italic">Y</span>
</td></tr>
</table></div>
If <span class='latexinline'>
<span style="font-style:italic">X</span> &#X227A;<sub>&#X3C6;</sub><span style="font-style:italic">Y</span></span>, we say that <span class='latexinline'>
<span style="font-style:italic">Y</span></span> dominates <span class='latexinline'>
<span style="font-style:italic">X</span></span>, or <span class='latexinline'>
<span style="font-style:italic">Y</span></span> covers <span class='latexinline'>
<span style="font-style:italic">X</span></span>, or
<span class='latexinline'>
<span style="font-style:italic">X</span></span> divides <span class='latexinline'>
<span style="font-style:italic">Y</span></span>.
<h4><a id=checking-coverings-and-generating-subsets href='#checking-coverings-and-generating-subsets'> § </a> Checking coverings and generating subsets</h4>
We note that for a given covering <span class='latexinline'>
&#X3C6;</span>, if <span class='latexinline'>
<span style="font-style:italic">s</span><sub><span style="font-style:italic">x</span></sub></span> is covered by <span class='latexinline'>
<span style="font-style:italic">t</span><sub><span style="font-style:italic">y</span></sub></span>
and <span class='latexinline'>
<span style="font-style:italic">p</span><sub><span style="font-style:italic">x</span></sub></span> is covered by <span class='latexinline'>
<span style="font-style:italic">q</span><sub><span style="font-style:italic">y</span></sub></span>, then <span class='latexinline'>
<span style="font-style:italic">s</span><sub><span style="font-style:italic">x</span></sub> &#X2218; <span style="font-style:italic">t</span><sub><span style="font-style:italic">x</span></sub></span> is covered by <span class='latexinline'>
<span style="font-style:italic">t</span><sub><span style="font-style:italic">y</span></sub> &#X2218; <span style="font-style:italic">q</span><sub><span style="font-style:italic">y</span></sub></span>.
Thus, to check if <span class='latexinline'>
<span style="font-style:italic">X</span></span> is covered by <span class='latexinline'>
<span style="font-style:italic">Y</span></span>, we simply need to check if 
<b>some generating subset of <span class='latexinline'>
<span style="font-style:italic">X</span></span> is covered by <span class='latexinline'>
<span style="font-style:italic">Y</span></span></b>.
<h4><a id=checking-coverings-of-representations href='#checking-coverings-of-representations'> § </a> Checking coverings of representations</h4>
Let us assume we have a representation of a transformation semigroup
given with a semigroup <span class='latexinline'>
&#X3A3;</span>, a transformation semigroup
<span class='latexinline'>
<span style="font-style:italic">X</span> &#X2261; (<span style="font-style:italic">Q</span><sub><span style="font-style:italic">X</span></sub>, <span style="font-style:italic">S</span><sub><span style="font-style:italic">X</span></sub>)</span>, and a representation <span class='latexinline'>
<span style="font-style:italic">r</span>: &#X3A3; &#X2192; <span style="font-style:italic">S</span><sub><span style="font-style:italic">X</span></sub></span> that is
faithful.
Now, to check that <span class='latexinline'>
<span style="font-style:italic">X</span></span> is covered by another <span class='latexinline'>
<span style="font-style:italic">Y</span></span>, it suffices to check that
there exists a <span class='latexinline'>
<span style="font-style:italic">t</span><sub><span style="font-style:italic">y</span></sub> &#X2208; <span style="font-style:italic">Y</span></span> for each <span class='latexinline'>
&#X3C3; &#X2208; <span style="font-style:italic">X</span></span> such that <span class='latexinline'>
<span style="font-style:italic">r</span>(&#X3C3;)</span> is
covered by this <span class='latexinline'>
<span style="font-style:italic">t</span><sub><span style="font-style:italic">y</span></sub></span>.
<h4><a id=companion-relation href='#companion-relation'> § </a> Companion relation</h4>
Given a relation <span class='latexinline'>
&#X3C6;: <span style="font-style:italic">Y</span> &#X2192; <span style="font-style:italic">X</span></span>, then we define:
<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">&#X3A3;&#XA0;&#X2261;&#XA0;{&#XA0;(<span style="font-style:italic">s</span>,&#XA0;<span style="font-style:italic">t</span>)&#XA0;:&#XA0;<span style="font-style:italic">t</span>&#XA0;&#X2208;&#XA0;<span style="font-style:italic">T</span><sub><span style="font-style:italic">Y</span></sub>&#XA0; covers &#XA0;<span style="font-style:italic">s</span>&#XA0;&#X2208;&#XA0;<span style="font-style:italic">S</span><sub><span style="font-style:italic">X</span></sub>&#XA0;}
</td></tr>
</table></div>
Recall compositions of elements are covered by a composition
of their coverings. Hence, if <span class='latexinline'>
(<span style="font-style:italic">s</span>, <span style="font-style:italic">t</span>), (<span style="font-style:italic">s</span>&#X2032;, <span style="font-style:italic">t</span>&#X2032;) &#X2208; &#X3A3;</span>, then
<span class='latexinline'>
(<span style="font-style:italic">ss</span>&#X2032;, <span style="font-style:italic">tt</span>&#X2032;) &#X2208; &#X3A3;</span>. thus, <span class='latexinline'>
&#X3A3;</span> is a subsemigroup of <span class='latexinline'>
<span style="font-style:italic">S</span><sub><span style="font-style:italic">X</span></sub> &#XD7; <span style="font-style:italic">S</span><sub><span style="font-style:italic">Y</span></sub></span>.
We can regard <span class='latexinline'>
&#X3A3;</span> as the graph of a relation <span class='latexinline'>
&#X3C6;&#X2032; &#X2286; <span style="font-style:italic">Q</span><sub><span style="font-style:italic">Y</span></sub> &#XD7; <span style="font-style:italic">Q</span><sub><span style="font-style:italic">X</span></sub></span>.
This will be called as <b>companion relation</b> of <span class='latexinline'>
&#X3C6;</span>.
<h4><a id=wreath-products href='#wreath-products'> § </a> Wreath products</h4>
Let <span class='latexinline'>
<span style="font-style:italic">X</span> &#X2261; (<span style="font-style:italic">Q</span><sub><span style="font-style:italic">X</span></sub>, <span style="font-style:italic">S</span><sub><span style="font-style:italic">X</span></sub>)</span> and <span class='latexinline'>
<span style="font-style:italic">Y</span> &#X2261; (<span style="font-style:italic">Q</span><sub><span style="font-style:italic">Y</span></sub>, <span style="font-style:italic">S</span><sub><span style="font-style:italic">Y</span></sub>)</span>. We're going to define a large
product <span class='latexinline'>
<span style="font-style:italic">X</span> &#X2240; <span style="font-style:italic">Y</span></span>.
We begn with the set <span class='latexinline'>
<span style="font-style:italic">W</span> &#X2261; <span style="font-style:italic">S</span><sub><span style="font-style:italic">X</span></sub><sup><span style="font-style:italic">Q</span></sup><sub><span style="font-style:italic">Y</span></sub> &#XD7; <span style="font-style:italic">S</span><sub><span style="font-style:italic">Y</span></sub></span>, where
<span class='latexinline'>
<span style="font-style:italic">S</span><sub><span style="font-style:italic">X</span></sub><sup><span style="font-style:italic">Q</span></sup><sub><span style="font-style:italic">Y</span></sub> &#X2261; { <span style="font-style:italic">f</span> : <span style="font-style:italic">Q</span><sub><span style="font-style:italic">Y</span></sub> &#X2192; <span style="font-style:italic">S</span><sub><span style="font-style:italic">X</span></sub> }</span>.
The wreath product then becomes:
<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">X</span>&#XA0;&#X2240;&#XA0;<span style="font-style:italic">Y</span>&#XA0;&#X2261;&#XA0;(<span style="font-style:italic">Q</span><sub><span style="font-style:italic">X</span></sub>&#XA0;&#XD7;&#XA0;<span style="font-style:italic">Q</span><sub><span style="font-style:italic">Y</span></sub>,&#XA0;<span style="font-style:italic">W</span>)
</td></tr>
</table></div>
with the action of <span class='latexinline'>
<span style="font-style:italic">W</span></span> on an element of <span class='latexinline'>
<span style="font-style:italic">Q</span><sub><span style="font-style:italic">X</span></sub> &#XD7; <span style="font-style:italic">Q</span><sub><span style="font-style:italic">Y</span></sub></span> being defined as:
<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(<span style="font-style:italic">f</span>&#XA0;:&#XA0;<span style="font-style:italic">Q</span><sub><span style="font-style:italic">Y</span></sub>&#XA0;&#X2192;&#XA0;<span style="font-style:italic">S</span><sub><span style="font-style:italic">X</span></sub>,&#XA0;<span style="font-style:italic">s</span><sub><span style="font-style:italic">y</span></sub>&#XA0;:&#XA0;<span style="font-style:italic">S</span><sub><span style="font-style:italic">Y</span></sub>)&#XA0;(<span style="font-style:italic">q</span><sub><span style="font-style:italic">x</span></sub>&#XA0;:&#XA0;<span style="font-style:italic">Q</span><sub><span style="font-style:italic">X</span></sub>,&#XA0;<span style="font-style:italic">q</span><sub><span style="font-style:italic">Y</span></sub>&#XA0;:&#XA0;<span style="font-style:italic">Q</span><sub><span style="font-style:italic">Y</span></sub>)&#XA0;&#X2261;&#XA0;(&#XA0;<span style="font-style:italic">f</span>(<span style="font-style:italic">q</span><sub><span style="font-style:italic">y</span></sub>)(<span style="font-style:italic">q</span><sub><span style="font-style:italic">x</span></sub>)&#XA0;,&#XA0;<span style="font-style:italic">s</span><sub><span style="font-style:italic">y</span></sub>&#XA0;(<span style="font-style:italic">q</span><sub><span style="font-style:italic">y</span></sub>))
</td></tr>
</table></div>
it's a "follow the types" sort of definition, where we edit the right component
as <span class='latexinline'>
<span style="font-style:italic">r</span><sub><span style="font-style:italic">y</span></sub> &#X21A6; <span style="font-style:italic">t</span><sub><span style="font-style:italic">y</span></sub>(<span style="font-style:italic">r</span><sub><span style="font-style:italic">y</span></sub>)</span> since that's all we can do. In the case of
the left component, we have a <span class='latexinline'>
<span style="font-style:italic">q</span><sub><span style="font-style:italic">x</span></sub></span>, and we need to produce another element
in <span class='latexinline'>
<span style="font-style:italic">Q</span><sub><span style="font-style:italic">X</span></sub></span>, so we "must use <span class='latexinline'>
<span style="font-style:italic">f</span></span>". The only way to use <span class='latexinline'>
<span style="font-style:italic">f</span></span> is to feed it
a <span class='latexinline'>
<span style="font-style:italic">t</span><sub><span style="font-style:italic">y</span></sub></span>. This forces us into the above definition.
<h4><a id=composition-of-wreath-products href='#composition-of-wreath-products'> § </a> Composition of wreath products</h4>
To show that its closed under composition, let's consider <span class='latexinline'>
(<span style="font-style:italic">f</span>, <span style="font-style:italic">s</span><sub><span style="font-style:italic">y</span></sub>), (<span style="font-style:italic">g</span>, <span style="font-style:italic">t</span><sub><span style="font-style:italic">y</span></sub>) &#X2208; <span style="font-style:italic">W</span></span>
with <span class='latexinline'>
<span style="font-style:italic">f</span>, <span style="font-style:italic">g</span>: <span style="font-style:italic">Q</span><sub><span style="font-style:italic">Y</span></sub><span style="font-style:italic">g</span> &#X2192; <span style="font-style:italic">S</span><sub><span style="font-style:italic">X</span></sub></span>, and <span class='latexinline'>
<span style="font-style:italic">s</span><sub><span style="font-style:italic">y</span></sub>, <span style="font-style:italic">t</span><sub><span style="font-style:italic">y</span></sub> &#X2208; <span style="font-style:italic">S</span><sub><span style="font-style:italic">Y</span></sub></span>. The result is
going to be:
<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(<span style="font-style:italic">f</span>,&#XA0;<span style="font-style:italic">s</span><sub><span style="font-style:italic">y</span></sub>)&#XA0;&#XA0;(<span style="font-style:italic">g</span>,&#XA0;<span style="font-style:italic">t</span><sub><span style="font-style:italic">y</span></sub>)&#XA0;=&#XA0;&#XA0;(&#X3BB;&#XA0;<span style="font-style:italic">q</span><sub><span style="font-style:italic">y</span></sub>.&#XA0;<span style="font-style:italic">f</span>(<span style="font-style:italic">q</span><sub><span style="font-style:italic">y</span></sub>)&#XA0;&#X2218;&#XA0;<span style="font-style:italic">g</span>(<span style="font-style:italic">q</span><sub><span style="font-style:italic">y</span></sub>),&#XA0;<span style="font-style:italic">t</span><sub><span style="font-style:italic">y</span></sub>&#XA0;&#X2218;&#XA0;<span style="font-style:italic">u</span><sub><span style="font-style:italic">y</span></sub>)
</td></tr>
</table></div>
<h4><a id=equivalences-of-subsets-of-states href='#equivalences-of-subsets-of-states'> § </a> Equivalences of subsets of states</h4>
Let <span class='latexinline'>
<span style="font-style:italic">X</span> = (<span style="font-style:italic">Q</span>, <span style="font-style:italic">S</span>)</span> be a transition system. Given subsets <span class='latexinline'>
(<span style="font-style:italic">a</span>, <span style="font-style:italic">b</span>, &#X2286; <span style="font-style:italic">Q</span>)</span>,
we shall write <span class='latexinline'>
<span style="font-style:italic">b</span> &#X2264; <span style="font-style:italic">a</span></span> if either <span class='latexinline'>
<span style="font-style:italic">b</span> &#X2286; <span style="font-style:italic">a</span></span> or there exists some <span class='latexinline'>
<span style="font-style:italic">s</span> &#X2208; <span style="font-style:italic">S</span></span>
such that <span class='latexinline'>
<span style="font-style:italic">b</span> &#X2286; <span style="font-style:italic">sa</span></span>, where <span class='latexinline'>
<span style="font-style:italic">s</span>(<span style="font-style:italic">a</span>) &#X2261; { <span style="font-style:italic">s</span>(<span style="font-style:italic">a</span><sub><span style="font-style:italic">i</span></sub>) : <span style="font-style:italic">a</span><sub><span style="font-style:italic">i</span></sub> &#X2208; <span style="font-style:italic">a</span>}</span>. We can
define an equivalence relation <span class='latexinline'>
<span style="font-style:italic">a</span> &#X223C; <span style="font-style:italic">b</span> &#XA0;&#X21D0;&#X21D2;&#XA0;<span style="font-style:italic">a</span> &#X2264; <span style="font-style:italic">b</span> &#X2227; <span style="font-style:italic">b</span> &#X2264; <span style="font-style:italic">a</span></span>.
<b>Note</b>: <span class='latexinline'>
 <span style="font-style:italic">b</span> &#X2264; <span style="font-style:italic">a</span>  |<span style="font-style:italic">b</span>| &#X2264; |<span style="font-style:italic">a</span>|</span>, since 
<span class='latexinline'>
<span style="font-style:italic">b</span> &#X2264; <span style="font-style:italic">a</span></span> means that <span class='latexinline'>
<span style="font-style:italic">b</span> &#X2286; <span style="font-style:italic">s</span>(<span style="font-style:italic">a</span>)</span>. Note that <span class='latexinline'>
<span style="font-style:italic">s</span></span> is actually a
function <span class='latexinline'>
<span style="font-style:italic">s</span>: <span style="font-style:italic">Q</span> &#X2192; <span style="font-style:italic">Q</span></span>, and a function mapped over a set can only
ever decrease the number of elements in a set, since a function can only
xglomp elements together; it can never break an element apart into two.
Hence, <span class='latexinline'>
<span style="font-style:italic">b</span> &#X2286; <span style="font-style:italic">sa</span> &#X2286; <span style="font-style:italic">a</span></span>, and thus <span class='latexinline'>
|<span style="font-style:italic">b</span>| &#X2264; |<span style="font-style:italic">a</span>|</span>.
Similiarly, <span class='latexinline'>
<span style="font-style:italic">a</span> &#X2264; <span style="font-style:italic">b</span>  |<span style="font-style:italic">a</span>| &#X2264; |<span style="font-style:italic">b</span>|</span>. Therefore, <span class='latexinline'>
<span style="font-style:italic">b</span> &#X223C; <span style="font-style:italic">a</span></span> means
that <span class='latexinline'>
|<span style="font-style:italic">b</span>| = |<span style="font-style:italic">a</span>|</span>.
<b>Theorem</b>: for all <span class='latexinline'>
<span style="font-style:italic">a</span>, <span style="font-style:italic">b</span> &#X2208; <span style="font-style:italic">Q</span><sub><span style="font-style:italic">X</span></sub></span> such that
<span class='latexinline'>
<span style="font-style:italic">a</span> &#XA0; <span style="font-style:italic">b</span></span> such that <span class='latexinline'>
<span style="font-style:italic">b</span> &#X2286; <span style="font-style:italic">s</span>(<span style="font-style:italic">a</span>)</span>, we show that <span class='latexinline'>
<span style="font-style:italic">b</span> = <span style="font-style:italic">s</span>(<span style="font-style:italic">a</span>)</span>, and there exists
a <span class='latexinline'>
<span style="font-style:italic">t</span> &#X2208; <span style="font-style:italic">S</span><sub><span style="font-style:italic">X</span></sub></span> such that <span class='latexinline'>
<span style="font-style:italic">a</span> = <span style="font-style:italic">t</span>(<span style="font-style:italic">b</span>)</span>.
<b>Proof</b>: Since <span class='latexinline'>
<span style="font-style:italic">b</span> &#X2286; <span style="font-style:italic">s</span>(<span style="font-style:italic">a</span>) &#X2286; <span style="font-style:italic">a</span></span> and <span class='latexinline'>
|<span style="font-style:italic">b</span>| = |<span style="font-style:italic">a</span>|</span>, <span class='latexinline'>
<span style="font-style:italic">b</span> = <span style="font-style:italic">s</span>(<span style="font-style:italic">a</span>)</span>.
Therefore <span class='latexinline'>
<span style="font-style:italic">s</span></span> is a permutation. Hence, <span class='latexinline'>
<span style="font-style:italic">s</span></span> is invertible and there exists
an inverse permutation <span class='latexinline'>
<span style="font-style:italic">t</span></span> such that <span class='latexinline'>
<span style="font-style:italic">a</span> = <span style="font-style:italic">t</span>(<span style="font-style:italic">b</span>)</span>. We now need to show that
<span class='latexinline'>
<span style="font-style:italic">t</span> &#X2208; <span style="font-style:italic">S</span><sub><span style="font-style:italic">X</span></sub></span>. To do this, first note that if the order of the permutation
<span class='latexinline'>
<span style="font-style:italic">s</span></span> is <span class='latexinline'>
<span style="font-style:italic">n</span></span>, then <span class='latexinline'>
<span style="font-style:italic">t</span> = <span style="font-style:italic">s</span><sup><span style="font-style:italic">n</span>&#X2212;1</sup></span>, since <span class='latexinline'>
<span style="font-style:italic">t</span> &#X2218; <span style="font-style:italic">s</span> = <span style="font-style:italic">s</span><sup><span style="font-style:italic">n</span>&#X2212;1</sup> &#X2218; <span style="font-style:italic">s</span> = 1<sub><span style="font-style:italic">S</span></sub></span>.
Since the semigroup <span class='latexinline'>
<span style="font-style:italic">S</span></span> is closed under composition <span class='latexinline'>
<span style="font-style:italic">t</span> = <span style="font-style:italic">s</span><sup><span style="font-style:italic">n</span>&#X2212;1</sup></span> is in <span class='latexinline'>
<span style="font-style:italic">S</span></span>,
since it is <span class='latexinline'>
<span style="font-style:italic">s</span></span> composed with itself  <span class='latexinline'>
(<span style="font-style:italic">n</span>&#X2212;1)</span> times.
<h4><a id=subset-families-of-interest href='#subset-families-of-interest'> § </a> Subset families of interest</h4>
We will be interest in a family of subsets of <span class='latexinline'>
<span style="font-style:italic">Q</span><sub><span style="font-style:italic">X</span></sub></span> called <span class='latexinline'>
<span style="font-style:italic">A</span></span>, of the form:
<ul>
<li>
 all sets of the form <span class='latexinline'>
<span style="font-style:italic">s</span>(<span style="font-style:italic">Q</span>)</span> for all <span class='latexinline'>
<span style="font-style:italic">s</span> &#X2208; <span style="font-style:italic">S</span><sub><span style="font-style:italic">X</span></sub></span>
</li>
<li>
 the set <span class='latexinline'>
<span style="font-style:italic">Q</span></span>
</li>
<li>
 the empty set <span class='latexinline'>
&#X2205;</span>
</li>
<li>
 all the singleton sets <span class='latexinline'>
{ <span style="font-style:italic">q</span> }</span> for all <span class='latexinline'>
<span style="font-style:italic">q</span> &#X2208; <span style="font-style:italic">Q</span></span>.
</li>

</ul>

In the above set, we have <span class='latexinline'>
&#X2264;</span> and <span class='latexinline'>
&#X223C;</span> as defined above.
We note that the set <span class='latexinline'>
<span style="font-style:italic">A</span></span> is <b>closed under the action of all <span class='latexinline'>
<span style="font-style:italic">s</span> &#X2208; <span style="font-style:italic">S</span><sub><span style="font-style:italic">X</span></sub></span></b>.
For example, the empty set is taken to the empty set. All singleton
sets are taken to other singleton sets. For the full set <span class='latexinline'>
<span style="font-style:italic">Q</span></span>, we add
the sets <span class='latexinline'>
<span style="font-style:italic">s</span>(<span style="font-style:italic">Q</span>)</span> for all <span class='latexinline'>
<span style="font-style:italic">s</span> &#X2208; <span style="font-style:italic">S</span><sub><span style="font-style:italic">X</span></sub></span>.
<h4><a id=height-function href='#height-function'> § </a> Height function</h4>
A height function for a transition system <span class='latexinline'>
<span style="font-style:italic">X</span> &#X2261; (<span style="font-style:italic">Q</span><sub><span style="font-style:italic">X</span></sub>, <span style="font-style:italic">S</span><sub><span style="font-style:italic">X</span></sub>)</span> is a function
<span class='latexinline'>
<span style="font-style:italic">h</span>: <span style="font-style:italic">A</span> &#X2192; &#X2124;</span> such that:
<ol>
<li>
 <span class='latexinline'>
<span style="font-style:italic">h</span>(&#X2205;) = &#X2212;1</span>.
</li>
<li>
 <span class='latexinline'>
<span style="font-style:italic">h</span>({ <span style="font-style:italic">q</span> }) = 0 &#X2200; <span style="font-style:italic">q</span> &#X2208; <span style="font-style:italic">Q</span></span>.
</li>
<li>
 <span class='latexinline'>
<span style="font-style:italic">a</span> &#X223C; <span style="font-style:italic">b</span>  <span style="font-style:italic">h</span>(<span style="font-style:italic">a</span>) = <span style="font-style:italic">h</span>(<span style="font-style:italic">b</span>)</span> for all <span class='latexinline'>
<span style="font-style:italic">a</span>, <span style="font-style:italic">b</span> &#X2208; <span style="font-style:italic">A</span></span>.
</li>
<li>
 <span class='latexinline'>
<span style="font-style:italic">b</span> &lt; <span style="font-style:italic">a</span>  <span style="font-style:italic">h</span>(<span style="font-style:italic">b</span>) &lt; <span style="font-style:italic">h</span>(<span style="font-style:italic">a</span>)</span> for all <span class='latexinline'>
<span style="font-style:italic">a</span>, <span style="font-style:italic">b</span> &#X2208; <span style="font-style:italic">A</span></span>.
</li>

</ol>

The notation <span class='latexinline'>
<span style="font-style:italic">b</span> &lt; <span style="font-style:italic">a</span> &#X2261; (<span style="font-style:italic">b</span> &#X2264; <span style="font-style:italic">a</span>) &#X2227; &#XAC; (<span style="font-style:italic">a</span> &#X2264; <span style="font-style:italic">b</span>)</span>.
(3) + (4) imply that two elements of the same height are either equivalent
or incomparable.
<h4><a id=pavings-and-bricks href='#pavings-and-bricks'> § </a> Pavings and bricks</h4>
for <span class='latexinline'>
<span style="font-style:italic">a</span> &#X2208; <span style="font-style:italic">A</span></span> such that <span class='latexinline'>
|<span style="font-style:italic">a</span>| &gt; 1</span>, we denote by <span class='latexinline'>
<span style="font-style:italic">B</span><sub><span style="font-style:italic">a</span></sub></span> the set of all <span class='latexinline'>
<span style="font-style:italic">b</span> &#X2208; <span style="font-style:italic">A</span></span>
what are maximal subsets of <span class='latexinline'>
<span style="font-style:italic">a</span></span>. That is, if <span class='latexinline'>
<span style="font-style:italic">b</span> &#X2208; <span style="font-style:italic">B</span><sub><span style="font-style:italic">a</span></sub></span> then <span class='latexinline'>
<span style="font-style:italic">b</span>  <span style="font-style:italic">a</span></span>,
and <span class='latexinline'>
&#X2204;<span style="font-style:italic">c</span>, <span style="font-style:italic">b</span>  <span style="font-style:italic">c</span>  <span style="font-style:italic">a</span></span>. Equivalently, if there
exists a <span class='latexinline'>
<span style="font-style:italic">c</span></span> such that <span class='latexinline'>
<span style="font-style:italic">b</span> &#X2286; <span style="font-style:italic">c</span> &#X2286; <span style="font-style:italic">a</span></span>, then <span class='latexinline'>
<span style="font-style:italic">b</span> = <span style="font-style:italic">c</span></span> or <span class='latexinline'>
<span style="font-style:italic">b</span> = <span style="font-style:italic">a</span></span>.
Note that we can assert that <span class='latexinline'>
<span style="font-style:italic">a</span> = &#X222A;<sub><span style="font-style:italic">b</span> &#X2208; <span style="font-style:italic">B</span><sub><span style="font-style:italic">a</span></sub></sub> <span style="font-style:italic">b</span></span>. This is because <span class='latexinline'>
<span style="font-style:italic">B</span><sub><span style="font-style:italic">a</span></sub></span>
contains all the singletons of <span class='latexinline'>
<span style="font-style:italic">Q</span><sub><span style="font-style:italic">X</span></sub></span>. so we can begin by writing <span class='latexinline'>
<span style="font-style:italic">a</span></span> as
a union of singletons, and then merging elements of <span class='latexinline'>
<span style="font-style:italic">B</span><sub><span style="font-style:italic">a</span></sub></span> into larger elements
of <span class='latexinline'>
<span style="font-style:italic">B</span></span>, terminating when we cannot merge any more elements of <span class='latexinline'>
<span style="font-style:italic">B</span><sub><span style="font-style:italic">a</span></sub></span>.
<ul>
<li>
 The set <span class='latexinline'>
<span style="font-style:italic">B</span><sub><span style="font-style:italic">a</span></sub></span> is called as the <b>paving of <span class='latexinline'>
<span style="font-style:italic">a</span></span></b>.
</li>
<li>
 The elements of <span class='latexinline'>
<span style="font-style:italic">B</span><sub><span style="font-style:italic">a</span></sub></span> are called as the <b>bricks of <span class='latexinline'>
<span style="font-style:italic">a</span></span></b>.
</li>

</ul>

<h4><a id=a-in-aof-permutations-for- href='#a-in-aof-permutations-for-'> § </a> Group of permutations for <span class='latexinline'>
<span style="font-style:italic">a</span> &#X2208; <span style="font-style:italic">A</span></span></h4>
Let us assume that there exists a <span class='latexinline'>
<span style="font-style:italic">s</span> &#X2208; <span style="font-style:italic">S</span></span> such that <span class='latexinline'>
<span style="font-style:italic">s</span>(<span style="font-style:italic">a</span>) = <span style="font-style:italic">a</span></span>. Let <span class='latexinline'>
<span style="font-style:italic">A</span><sub><span style="font-style:italic">a</span></sub></span>
be the set of all elements in <span class='latexinline'>
<span style="font-style:italic">A</span></span> contained in <span class='latexinline'>
<span style="font-style:italic">a</span></span>:
<span class='latexinline'>
<span style="font-style:italic">A</span><sub><span style="font-style:italic">a</span></sub> = { <span style="font-style:italic">A</span><sub><span style="font-style:italic">i</span></sub> : <span style="font-style:italic">A</span><sub><span style="font-style:italic">i</span></sub> &#X2208; <span style="font-style:italic">A</span>, <span style="font-style:italic">A</span><sub><span style="font-style:italic">i</span></sub> &#X2286; <span style="font-style:italic">a</span> }</span>.
Recall that the set <span class='latexinline'>
<span style="font-style:italic">A</span></span> was closed under the action of all <span class='latexinline'>
<span style="font-style:italic">s</span></span>, and hence,
since <span class='latexinline'>
<span style="font-style:italic">s</span></span> is a permutation of <span class='latexinline'>
<span style="font-style:italic">a</span></span>, this naturally extends into a
permutation of <span class='latexinline'>
<span style="font-style:italic">A</span><sub><span style="font-style:italic">a</span></sub></span>: <span class='latexinline'>
<span style="font-style:italic">s</span> <span style="font-style:italic">A</span><sub><span style="font-style:italic">a</span></sub> = <span style="font-style:italic">A</span><sub><span style="font-style:italic">a</span></sub></span>. Now note that this induces a permutation
of the set <span class='latexinline'>
<span style="font-style:italic">B</span><sub><span style="font-style:italic">a</span></sub></span>. This creates a transition system:
<div class='latexblock'><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">G</span><sub><span style="font-style:italic">a</span></sub>&#XA0;&#X2261;&#XA0;{&#XA0;<span style="font-style:italic">s</span>&#XA0;&#X2208;&#XA0;<span style="font-style:italic">S</span>&#XA0;:&#XA0;<span style="font-style:italic">s</span>&#XA0;<span style="font-style:italic">a</span>&#XA0;=&#XA0;<span style="font-style:italic">a</span>&#XA0;}&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">H</span><sub><span style="font-style:italic">a</span></sub>&#XA0;&#X2261;&#XA0;(<span style="font-style:italic">B</span><sub><span style="font-style:italic">a</span></sub>,&#XA0;<span style="font-style:italic">G</span><sub><span style="font-style:italic">a</span></sub>)&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table>
</div>
We have already shown how if <span class='latexinline'>
<span style="font-style:italic">s</span> &#X2208; <span style="font-style:italic">S</span></span> defines a permutation of some set <span class='latexinline'>
<span style="font-style:italic">X</span></span>
by its action, then its inverse also exists in <span class='latexinline'>
<span style="font-style:italic">S</span></span>. So, this means that
<span class='latexinline'>
<span style="font-style:italic">G</span><sub><span style="font-style:italic">a</span></sub></span> is in fact a transition <i>group</i> that acts on <span class='latexinline'>
<span style="font-style:italic">B</span><sub><span style="font-style:italic">a</span></sub></span>.
It might turn out that <span class='latexinline'>
<span style="font-style:italic">G</span><sub><span style="font-style:italic">a</span></sub> = &#X2205;</span>. However, if <span class='latexinline'>
<span style="font-style:italic">G</span><sub><span style="font-style:italic">a</span></sub> &#X2260; &#X2205;</span>,
then as stated above, <span class='latexinline'>
<span style="font-style:italic">G</span><sub><span style="font-style:italic">a</span></sub></span> is a group.
We will call such a transition group a <b>generalized transition group</b>, since
either <span class='latexinline'>
<span style="font-style:italic">G</span><sub><span style="font-style:italic">a</span></sub> = &#X2205;</span> or <span class='latexinline'>
<span style="font-style:italic">G</span><sub><span style="font-style:italic">a</span></sub></span> is a group.
Now, the generalized transition group <span class='latexinline'>
<span style="font-style:italic">H</span><sub><span style="font-style:italic">a</span></sub></span> is called as the
<b>holonomy transition system</b> of <span class='latexinline'>
<span style="font-style:italic">a</span></span>, and the group <span class='latexinline'>
<span style="font-style:italic">G</span><sub><span style="font-style:italic">a</span></sub></span> is called as
the <b>holonomy group</b> of <span class='latexinline'>
<span style="font-style:italic">a</span></span>.
We have that <span class='latexinline'>
<span style="font-style:italic">G</span><sub><span style="font-style:italic">a</span></sub> &#X227A; <span style="font-style:italic">S</span></span> since <span class='latexinline'>
<span style="font-style:italic">G</span><sub><span style="font-style:italic">a</span></sub></span> is a quotient of the sub-semigroup
<span class='latexinline'>
{ <span style="font-style:italic">s</span> | <span style="font-style:italic">s</span> &#X2208; <span style="font-style:italic">S</span>, <span style="font-style:italic">as</span> = <span style="font-style:italic">a</span> }</span>. (TODO: so what? why does this mean that it's <span class='latexinline'>
&#X227A;</span>?)
<b>Theorem:</b> if <span class='latexinline'>
<span style="font-style:italic">a</span> &#X223C; <span style="font-style:italic">b</span></span>, then <span class='latexinline'>
<span style="font-style:italic">H</span><sub><span style="font-style:italic">a</span></sub> &#X2243; <span style="font-style:italic">H</span><sub><span style="font-style:italic">b</span></sub></span>
  (similar subsets have isomorphic holonomy transition systems).
<b>Proof:</b> Let us assume that <span class='latexinline'>
<span style="font-style:italic">a</span> &#X2260; <span style="font-style:italic">b</span></span>. since <span class='latexinline'>
<span style="font-style:italic">a</span> &#X223C; <span style="font-style:italic">b</span></span>, we have elements
of the form <span class='latexinline'>
<span style="font-style:italic">s</span>, <span style="font-style:italic">s</span><sup>&#X2212;1</sup> &#X2208; <span style="font-style:italic">S</span></span> such that <span class='latexinline'>
<span style="font-style:italic">b</span> = <span style="font-style:italic">s</span>(<span style="font-style:italic">a</span>)</span>, <span class='latexinline'>
<span style="font-style:italic">a</span> = <span style="font-style:italic">s</span><sup>&#X2212;1</sup>(<span style="font-style:italic">b</span>)</span>.
Recall that for <span class='latexinline'>
<span style="font-style:italic">b</span><sub><span style="font-style:italic">a</span></sub> &#X2208; <span style="font-style:italic">B</span><sub><span style="font-style:italic">a</span></sub></span> is such that for a member <span class='latexinline'>
<span style="font-style:italic">g</span> &#X2208; <span style="font-style:italic">G</span><sub><span style="font-style:italic">a</span></sub></span>,
<span class='latexinline'>
<span style="font-style:italic">g</span>(<span style="font-style:italic">b</span><sub><span style="font-style:italic">a</span></sub>) = <span style="font-style:italic">b</span><sub><span style="font-style:italic">a</span></sub></span>. <span class='latexinline'>
<span style="font-style:italic">B</span><sub><span style="font-style:italic">b</span></sub></span> must have the element <span class='latexinline'>
<span style="font-style:italic">s</span>(<span style="font-style:italic">b</span><sub><span style="font-style:italic">a</span></sub>)</span>. [TODO!]
<h4><a id=holonomy-decomposition href='#holonomy-decomposition'> § </a> Holonomy decomposition</h4>
Let <span class='latexinline'>
<span style="font-style:italic">X</span> &#X2261; (<span style="font-style:italic">Q</span>, <span style="font-style:italic">S</span>)</span> be a transition system and let <span class='latexinline'>
<span style="font-style:italic">h</span></span> be a height
function for <span class='latexinline'>
<span style="font-style:italic">X</span></span>, such that <span class='latexinline'>
<span style="font-style:italic">h</span>(<span style="font-style:italic">Q</span>) &gt; 0</span>. For a fixed <span class='latexinline'>
<span style="font-style:italic">i</span></span>,
let <span class='latexinline'>
<span style="font-style:italic">a</span><sub>1</sub>, <span style="font-style:italic">a</span><sub>2</sub>, &#X2026; <span style="font-style:italic">a</span><sub><span style="font-style:italic">k</span></sub></span> be the representatives of equivalence classes of
elements of <span class='latexinline'>
<span style="font-style:italic">A</span></span> of height equal to <span class='latexinline'>
<span style="font-style:italic">i</span></span>. We define:
<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">H</span><sub><span style="font-style:italic">i</span></sub><sup>&#X2228;</sup>&#X2261;&#XA0;<span style="font-style:italic">H</span><sub><span style="font-style:italic">a</span><sub>1</sub></sub>&#XA0;&#X2228;&#XA0;<span style="font-style:italic">H</span><sub><span style="font-style:italic">a</span><sub>2</sub></sub>&#XA0;&#X2026;&#XA0;&#X2228;&#XA0;<span style="font-style:italic">H</span><sub><span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub></sub>
</td></tr>
</table></div>
<h4><a id=inductive-hypothesis-for-coverings href='#inductive-hypothesis-for-coverings'> § </a> Inductive hypothesis for coverings</h4>
We will say a relational covering <span class='latexinline'>
<span style="font-style:italic">X</span> &#X25C1;<sub>&#X3C6;</sub> <span style="font-style:italic">Y</span></span> is <b>of rank <span class='latexinline'>
<span style="font-style:italic">i</span></span></b>
with respect to a given height function <span class='latexinline'>
<span style="font-style:italic">h</span></span> if <span class='latexinline'>
&#X3C6;</span> relates states in <span class='latexinline'>
<span style="font-style:italic">Y</span></span>
to subsets of states in <span class='latexinline'>
<span style="font-style:italic">x</span></span> that are members of <span class='latexinline'>
<span style="font-style:italic">A</span></span> and have rank at most i.
Formally, for each <span class='latexinline'>
<span style="font-style:italic">p</span> &#X2208; <span style="font-style:italic">Q</span><sub><span style="font-style:italic">Y</span></sub></span>, we have that <span class='latexinline'>
&#X3C6;(<span style="font-style:italic">p</span>) &#X2208; <span style="font-style:italic">A</span></span> and<span class='latexinline'>
<span style="font-style:italic">h</span>(&#X3C6;(<span style="font-style:italic">p</span>)) &#X2264; <span style="font-style:italic">i</span></span>.
We prove that if <span class='latexinline'>
<span style="font-style:italic">X</span> &#X25C1;<sub>&#X3C6;</sub> <span style="font-style:italic">Y</span></span> is a relational covering of rank <span class='latexinline'>
<span style="font-style:italic">i</span></span>,
then <span class='latexinline'>
<span style="font-style:italic">X</span> &#X25C1;<sub>&#X3C6;</sub> <span style="font-style:italic">H</span><sub><span style="font-style:italic">i</span></sub><sup>&#X2228;</sup> &#X2240; <span style="font-style:italic">Y</span></span> is a relational covering
of rank <span class='latexinline'>
<span style="font-style:italic">i</span> &#X2212; 1</span>.
The proof is a proof by induction.
<h4><a id=base-case href='#base-case'> § </a> Base case:</h4>
Start with the relational covering with <span class='latexinline'>
<span style="font-style:italic">Q</span><sub><span style="font-style:italic">Y</span></sub> = { 0 }, <span style="font-style:italic">S</span><sub><span style="font-style:italic">Y</span></sub> = { <span style="font-style:italic">id</span> }</span>,
and the cover <span class='latexinline'>
&#X3C6;(0) = <span style="font-style:italic">Q</span><sub><span style="font-style:italic">X</span></sub></span>. Clearly, this has rank <span class='latexinline'>
<span style="font-style:italic">n</span></span> since the height
of <span class='latexinline'>
<span style="font-style:italic">Q</span><sub><span style="font-style:italic">X</span></sub></span> is <span class='latexinline'>
<span style="font-style:italic">n</span></span>, and <span class='latexinline'>
&#X3C6;</span> is inded a covering, since the only transition
that <span class='latexinline'>
<span style="font-style:italic">Y</span></span> can make (stay at the same state) is simulated by any transition
in <span class='latexinline'>
<span style="font-style:italic">S</span><sub><span style="font-style:italic">X</span></sub></span> [TODO: is this really the argument?]
For induction, assume <span class='latexinline'>
<span style="font-style:italic">X</span> &#X25C1;<sub>&#X3C6;</sub> <span style="font-style:italic">Y</span></span> is a relational covering of rank <span class='latexinline'>
<span style="font-style:italic">i</span></span>
with respect to some height function <span class='latexinline'>
<span style="font-style:italic">h</span></span>. <span class='latexinline'>
<span style="font-style:italic">X</span>&#X2261; (<span style="font-style:italic">Q</span><sub><span style="font-style:italic">X</span></sub>, <span style="font-style:italic">S</span><sub><span style="font-style:italic">X</span></sub>)</span> and
<span class='latexinline'>
<span style="font-style:italic">Y</span> &#X2261; (<span style="font-style:italic">Q</span><sub><span style="font-style:italic">Y</span></sub>, <span style="font-style:italic">S</span><sub><span style="font-style:italic">Y</span></sub>)</span>. We define
<ul>
<li>
 <span class='latexinline'>
<span style="font-style:italic">QY</span><sub><span style="font-style:italic">i</span></sub> &#X2261; { <span style="font-style:italic">q</span><sub><span style="font-style:italic">y</span></sub> : <span style="font-style:italic">q</span><sub><span style="font-style:italic">y</span></sub> &#X2208; <span style="font-style:italic">Q</span><sub><span style="font-style:italic">Y</span></sub>, <span style="font-style:italic">h</span>(&#X3C6;(<span style="font-style:italic">q</span><sub><span style="font-style:italic">y</span></sub>)) = <span style="font-style:italic">i</span> }</span>
</li>
<li>
 <span class='latexinline'>
<span style="font-style:italic">QY</span><sub>&lt;</sub> &#X2261; { <span style="font-style:italic">q</span><sub><span style="font-style:italic">y</span></sub> : <span style="font-style:italic">q</span><sub><span style="font-style:italic">y</span></sub> &#X2208; <span style="font-style:italic">Q</span><sub><span style="font-style:italic">Y</span></sub>, <span style="font-style:italic">h</span>(&#X3C6;(<span style="font-style:italic">q</span><sub><span style="font-style:italic">y</span></sub>)) &lt; <span style="font-style:italic">i</span> }</span>
</li>

</ul>

We know that <span class='latexinline'>
<span style="font-style:italic">A</span></span> contains elements of height exactly <span class='latexinline'>
<span style="font-style:italic">i</span></span>. Let <span class='latexinline'>
<span style="font-style:italic">a</span><sub>1</sub>, <span style="font-style:italic">a</span><sub>2</sub>, &#X2026; <span style="font-style:italic">a</span><sub><span style="font-style:italic">k</span></sub></span>
be representatives of sets of of height <span class='latexinline'>
<span style="font-style:italic">i</span></span> in <span class='latexinline'>
<span style="font-style:italic">A</span></span>. Thus, for each <span class='latexinline'>
<span style="font-style:italic">qy</span><sub><span style="font-style:italic">i</span></sub> &#X2208; <span style="font-style:italic">QY</span><sub><span style="font-style:italic">i</span></sub></span>,
we have that:
<ul>
<li>
 <span class='latexinline'>
&#X3C6;(<span style="font-style:italic">qy</span><sub><span style="font-style:italic">i</span></sub>) = <span style="font-style:italic">a</span><sub><span style="font-style:italic">j</span></sub></span> for a <b>unique</b> <span class='latexinline'>
1 &#X2264; <span style="font-style:italic">j</span> &#X2264; <span style="font-style:italic">k</span></span>.
</li>
<li>
 We select elements <span class='latexinline'>
<span style="font-style:italic">u</span>, <span style="text-decoration:overline"><span style="font-style:italic">u</span></span> &#X2208; <span style="font-style:italic">S</span></span> such that <span class='latexinline'>
<span style="font-style:italic">u</span>(&#X3C6;(<span style="font-style:italic">qy</span><sub><span style="font-style:italic">i</span></sub>)) = <span style="font-style:italic">a</span><sub><span style="font-style:italic">j</span></sub></span>
  and <span class='latexinline'>
<span style="text-decoration:overline"><span style="font-style:italic">u</span></span>(<span style="font-style:italic">a</span><sub><span style="font-style:italic">j</span></sub>) = &#X3C6;(<span style="font-style:italic">qy</span><sub><span style="font-style:italic">i</span></sub>)</span>.
</li>

</ul>

We will show how to establish a relational covering:
<ul>
<li>
 <span class='latexinline'>
<span style="font-style:italic">X</span> &#X25C1;<sub>&#X3C6;</sub> &#X2240; <span style="font-style:italic">H</span><sub><span style="font-style:italic">i</span></sub><sup>&#X2228;</sup> <span style="font-style:italic">Y</span></span> using a relation:
</li>
<li>
 <span class='latexinline'>
&#X3C6; &#X2286; [(<span style="font-style:italic">B</span><sub><span style="font-style:italic">a</span><sub>1</sub></sub> &#X222A; <span style="font-style:italic">B</span><sub><span style="font-style:italic">a</span><sub>2</sub></sub> &#X222A; &#X2026; <span style="font-style:italic">B</span><sub><span style="font-style:italic">a</span><sub><span style="font-style:italic">k</span></sub></sub>)&#XD7; <span style="font-style:italic">Q</span><sub><span style="font-style:italic">Y</span></sub> ] &#XD7; <span style="font-style:italic">Q</span><sub><span style="font-style:italic">X</span></sub></span>
</li>

</ul>

<h4><a id=references href='#references'> § </a> References</h4>
<ul>
<li>
 Automata, Languages and Computation by Elinberg.
</li>
<li>
 <a href=http://www-verimag.imag.fr/~maler/Papers/kr-new.pdf>
On the Krohn-Rhodes decomposition theorem by Oded Maler</a>

</li>
<li>
 <a href=http://www.egri-nagy.hu/pdf/holonomy_general.pdf>
Ideas of the Holonomy Decomposition of Finite Transformation Semigroups</a>

</li>
<li>
 <a href=http://www-groups.mcs.st-andrews.ac.uk/~alanc/pub/c_semigroups/c_semigroups_a4.pdf>
Nine chapters on the semigroup art</a>

</li>
<li>
 <a href=http://www.biomicsproject.eu/file-repository/category/CompHolonomy.pdf>
Computational holonomy decompositions of transformation semigroups</a>

</li>
<li>
 <a href=http://graspermachine.sourceforge.net/>
Algebraic Hierarchical Decomposition of finite automata: webpage with links to implementations</a>

</li>
<li>
 <a href=https://github.com/gap-packages/sgpdec>
<code>sgpdec</code> library on github</a>

</li>
<li>
 <a href=https://compsemi.wordpress.com/>
Computational semigroup theory blog</a>

</li>
<li>
 <a href=https://arxiv.org/pdf/1306.1138.pdf>
Compact notation for semigroup/automata</a>

</li>

</ul>

<h3><a id=proving-block-matmul-using-program-analysis href='#proving-block-matmul-using-program-analysis'> § </a> <a href=#proving-block-matmul-using-program-analysis>
Proving block matmul using program analysis</a>
</h3>
It's a somewhat well-known fact that given matrix multiplication: <span class='latexinline'>
<span style="font-style:italic">O</span> = <span style="font-style:italic">AB</span></span>
where <span class='latexinline'>
<span style="font-style:italic">O</span> &#X2208; &#X211D;<sup>2<span style="font-style:italic">n</span> &#XD7; 2<span style="font-style:italic">m</span></sup></span> (<span class='latexinline'>
<span style="font-style:italic">O</span></span> for output),
<span class='latexinline'>
<span style="font-style:italic">A</span> &#X2208; &#X211D;<sup>2<span style="font-style:italic">n</span> &#XD7; <span style="font-style:italic">r</span></sup>, <span style="font-style:italic">B</span> &#X2208; &#X211D;<sup><span style="font-style:italic">r</span> &#XD7; 2<span style="font-style:italic">m</span></sup></span> are matrices.
We can also write this as follows:
<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell">&#X23A1;<br>
&#X23A2;<br>
&#X23A3;</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">o</span><sub>11</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">o</span><sub>12</sub>&#XA0;</td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">o</span><sub>21</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">o</span><sub>22</sub>&#XA0;</td></tr>
</table></td><td class="dcell">&#X23A4;<br>
&#X23A5;<br>
&#X23A6;</td></tr>
</table></td><td class="dcell">=
</td><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell">&#X23A1;<br>
&#X23A2;<br>
&#X23A3;</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">a</span><sub>11</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">a</span><sub>12</sub>&#XA0;</td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">a</span><sub>21</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">a</span><sub>22</sub>&#XA0;</td></tr>
</table></td><td class="dcell">&#X23A4;<br>
&#X23A5;<br>
&#X23A6;</td></tr>
</table></td><td class="dcell">
</td><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell">&#X23A1;<br>
&#X23A2;<br>
&#X23A3;</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">b</span><sub>11</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">b</span><sub>12</sub>&#XA0;</td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">b</span><sub>21</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">b</span><sub>22</sub>&#XA0;</td></tr>
</table></td><td class="dcell">&#X23A4;<br>
&#X23A5;<br>
&#X23A6;</td></tr>
</table></td><td class="dcell">
=
</td><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell">&#X23A1;<br>
&#X23A2;<br>
&#X23A3;</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">a</span><sub>11</sub>&#XA0;<span style="font-style:italic">b</span><sub>11</sub>&#XA0;+&#XA0;<span style="font-style:italic">a</span><sub>12</sub>&#XA0;<span style="font-style:italic">b</span><sub>21</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">a</span><sub>11</sub>&#XA0;<span style="font-style:italic">b</span><sub>12</sub>&#XA0;+&#XA0;<span style="font-style:italic">a</span><sub>12</sub>&#XA0;<span style="font-style:italic">b</span><sub>22</sub>&#XA0;</td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">a</span><sub>21</sub>&#XA0;<span style="font-style:italic">b</span><sub>11</sub>+&#XA0;<span style="font-style:italic">a</span><sub>22</sub>&#XA0;<span style="font-style:italic">b</span><sub>21</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">a</span><sub>21</sub>&#XA0;<span style="font-style:italic">b</span><sub>12</sub>&#XA0;+&#XA0;<span style="font-style:italic">a</span><sub>22</sub>&#XA0;<span style="font-style:italic">b</span><sub>22</sub>
</td></tr>
</table></td><td class="dcell">&#X23A4;<br>
&#X23A5;<br>
&#X23A6;</td></tr>
</table></td></tr>
</table></div>
When written as code, the original matrix multiplication is:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> <i><font color="#222222">// a:[2N][2Z] b:[2Z][2M] -&gt; out:[2N][2M]</font></i>
<font color="#000000">3:</font> <b><font color="#000000">int</font></b> matmul(<b><font color="#000000">int</font></b> N, <b><font color="#000000">int</font></b> Z, <b><font color="#000000">int</font></b> M, <b><font color="#000000">int</font></b> a[N][Z], <b><font color="#000000">int</font></b> b[Z][M], <b><font color="#000000">int</font></b> out[N][M]) {
<font color="#000000">4:</font>   <b><u><font color="#000000">for</font></u></b>(<b><font color="#000000">int</font></b> i = <font color="#000000">0</font>; i &lt; <font color="#000000">2</font>*N; ++i) {
<font color="#000000">5:</font>     <b><u><font color="#000000">for</font></u></b>(<b><font color="#000000">int</font></b> j = <font color="#000000">0</font>; j &lt; <font color="#000000">2</font>*M; ++j) {
<font color="#000000">6:</font>       <b><u><font color="#000000">for</font></u></b>(<b><font color="#000000">int</font></b> k = <font color="#000000">0</font>; k &lt; 2Z; ++k) out[i][j] += a[i][k] * b[k][j]
<font color="#000000">7:</font>     }
<font color="#000000">8:</font>   }
<font color="#000000">9:</font> }
<font color="#000000">10:</font> </tt></pre>
</div>

and the block-based matrix multiplication is:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> <i><font color="#222222">// a:[2N][2Z] b:[2Z][2M] -&gt; out:[2N][2M]</font></i>
<font color="#000000">03:</font> <b><font color="#000000">int</font></b> matmulBlock(<b><font color="#000000">int</font></b> N, <b><font color="#000000">int</font></b> Z, <b><font color="#000000">int</font></b> M, <b><font color="#000000">int</font></b> a[N][Z], <b><font color="#000000">int</font></b> b[Z][M], <b><font color="#000000">int</font></b> out[N][M]) {
<font color="#000000">04:</font>   <b><u><font color="#000000">for</font></u></b> (<b><font color="#000000">int</font></b> BI = <font color="#000000">0</font>; BI &lt; <font color="#000000">2</font>; ++BI) {
<font color="#000000">05:</font>     <b><u><font color="#000000">for</font></u></b> (<b><font color="#000000">int</font></b> BJ = <font color="#000000">0</font>; BJ &lt; <font color="#000000">2</font>; ++BJ) {
<font color="#000000">06:</font>       <b><u><font color="#000000">for</font></u></b>(<b><font color="#000000">int</font></b> i = BI*N; i &lt; BI*N+N; ++i) {
<font color="#000000">07:</font>         <b><u><font color="#000000">for</font></u></b>(<b><font color="#000000">int</font></b> j = BJ*M; j &lt; BJ*M+M; ++j) {
<font color="#000000">08:</font>           <b><u><font color="#000000">for</font></u></b>(<b><font color="#000000">int</font></b> k = <font color="#000000">0</font>; k &lt; 2Z; ++k) { out[i][j] += a[i][k] * b[k][j] }
<font color="#000000">09:</font>         }
<font color="#000000">10:</font>       }
<font color="#000000">11:</font>     }
<font color="#000000">12:</font>   }
<font color="#000000">13:</font> }
<font color="#000000">14:</font> </tt></pre>
</div>

we wish to show that both of these programs have the <i>same semantics</i>.
We will do this by appealing to ideas from program analysis.
<h4><a id=the-key-idea href='#the-key-idea'> § </a> The key idea</h4>
We will consider the statement:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> out[i][j] += a[i][k] * b[k][j]
<font color="#000000">3:</font> </tt></pre>
</div>

as occuring at an abstract "point in time" <span class='latexinline'>
(<span style="font-style:italic">i</span>, <span style="font-style:italic">j</span>, <span style="font-style:italic">k</span>)</span> in the <code>matmul</code> function.
I also occurs at an abstract "point in time" <span class='latexinline'>
(<span style="font-style:italic">BI</span>, <span style="font-style:italic">BJ</span>, <span style="font-style:italic">i</span>&#X2032;, <span style="font-style:italic">j</span>&#X2032;, <span style="font-style:italic">k</span>&#X2032;)</span> in
the <code>matmulBlock</code> function.
We will then show that the loops <code>for(i...) for(j...) for(k...)</code> are fully
parallel, and hence we can reorder the loops any way we want.
Then, we will show that the ordering imposed by <span class='latexinline'>
(<span style="font-style:italic">BI</span>, <span style="font-style:italic">BJ</span>, <span style="font-style:italic">i</span>&#X2032;, <span style="font-style:italic">j</span>&#X2032;, <span style="font-style:italic">k</span>&#X2032;)</span>
is a reordering of the original <span class='latexinline'>
(<span style="font-style:italic">i</span>, <span style="font-style:italic">j</span>, <span style="font-style:italic">k</span>)</span> ordering. We do this by
showing that there is a bijection:
<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(<span style="font-style:italic">i</span>=<span style="font-style:italic">i</span><sub>0</sub>,&#XA0;<span style="font-style:italic">j</span>=<span style="font-style:italic">j</span><sub>0</sub>,&#XA0;<span style="font-style:italic">k</span>=<span style="font-style:italic">k</span><sub>0</sub>)&#XA0;&#X2192;&#XA0;(<span style="font-style:italic">BI</span>=<span style="font-style:italic">i</span><sub>0</sub>/<span style="font-style:italic">N</span>,&#XA0;<span style="font-style:italic">BJ</span>=<span style="font-style:italic">j</span><sub>0</sub>/<span style="font-style:italic">N</span>,&#XA0;<span style="font-style:italic">i</span>=<span style="font-style:italic">i</span><sub>0</sub>%<span style="font-style:italic">N</span>,&#XA0;<span style="font-style:italic">j</span>=<span style="font-style:italic">j</span><sub>0</sub>%<span style="font-style:italic">N</span>,&#XA0;<span style="font-style:italic">k</span>=<span style="font-style:italic">k</span><sub>0</sub>)
</td></tr>
</table></div>
Thus, this bijection executes all loops, and does so without affecting the
program semantics.
<h4><a id=schedules href='#schedules'> § </a> Schedules</h4>
We'll zoom out a little, to consider some simple programs and understan
how to represent parallelism.
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> <b><font color="#000000">void</font></b> eg1(<b><font color="#000000">int</font></b> N, <b><font color="#000000">int</font></b> M, <b><font color="#000000">int</font></b> out[N][M]) {
<font color="#000000">3:</font> <b><u><font color="#000000">for</font></u></b>(<b><font color="#000000">int</font></b> i = <font color="#000000">0</font>; i &lt; N; ++i) {
<font color="#000000">4:</font>   <b><u><font color="#000000">for</font></u></b>(<b><font color="#000000">int</font></b> j = <font color="#000000">1</font>; j &lt; M; ++j) {
<font color="#000000">5:</font>     out[i][j] = out[i][j-<font color="#000000">1</font>];
<font color="#000000">6:</font>   }
<font color="#000000">7:</font> }
<font color="#000000">8:</font> </tt></pre>
</div>

Notice that this program is equivalent to the program with the <span class='latexinline'>
<span style="font-style:italic">i</span></span> loop
reversed:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> <b><font color="#000000">void</font></b> eg1rev(<b><font color="#000000">int</font></b> N, <b><font color="#000000">int</font></b> M, <b><font color="#000000">int</font></b> out[N][M]) {
<font color="#000000">3:</font> <b><u><font color="#000000">for</font></u></b>(<b><font color="#000000">int</font></b> i = N-<font color="#000000">1</font>; i &gt;=<font color="#000000">0</font>; --i) {
<font color="#000000">4:</font>   <b><u><font color="#000000">for</font></u></b>(<b><font color="#000000">int</font></b> j = <font color="#000000">1</font>; j &lt; M; ++j) {
<font color="#000000">5:</font>     out[i][j] = out[i][j-<font color="#000000">1</font>];
<font color="#000000">6:</font>   }
<font color="#000000">7:</font> }
<font color="#000000">8:</font> </tt></pre>
</div>

What's actually <i>stopping</i> us from reversing the loop <code>for(j...)</code>? it's
the fact that the value of, say, <code>out[i=0][j=1]</code> <i>depends</i> on
<code>out[i=0][j=0]</code>. We can see that in general, <code>out[i=i_0][j=j_0]</code> <i>depends</i>
on <code>out[i=i_0][j=j_0-1]</code>. We can represent this by considering a
<i>dependence set</i>:
<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">{&#XA0;<span style="font-family:monospace">write</span>:(<span style="font-style:italic">i</span><sub>0</sub>,&#XA0;<span style="font-style:italic">j</span><sub>0</sub>&#X2212;1)&#XA0;&#X2192;&#XA0;<span style="font-family:monospace">write</span>:(<span style="font-style:italic">i</span><sub>0</sub>,&#XA0;<span style="font-style:italic">j</span><sub>0</sub>)&#XA0;}
</td></tr>
</table></div>
in general, we can reorder statements as long as we do not change
the <i>directions</i> of the arrows in the dependence set.
<h4><a id=atmuldence-structure-of- href='#atmuldence-structure-of-'> § </a> Dependence structure of <code>matmul</code>.</h4>
<h4><a id=fully-parallel-reordering href='#fully-parallel-reordering'> § </a> Fully parallel, reordering</h4>
<h4><a id=references href='#references'> § </a> References</h4>
<ul>
<li>
 Optimizing Compilers for Modern Architectures: A Dependence-based Approach
</li>
<li>
 <a href=http://polyhedral.info/>
Polyhedral compilation</a>

</li>

</ul>

<h3><a id=why-i-like-algebra-over-analysis href='#why-i-like-algebra-over-analysis'> § </a> <a href=#why-i-like-algebra-over-analysis>
Why I like algebra over analysis</a>
</h3>
Midnight discussions with my room-mate
<a href=https://researchweb.iiit.ac.in/~arjun.p/>
Arjun P</a>
.
This tries to explore what it is about algebra that I find appealing.
I think the fundamental difference to me comes down to flavour ---
analysis and combinatorial objects feel very "algorithm", while Algebra feels
"data structure".
To expand on the analogy, a proof technique is like an algorithm, while an
algebraic object is like a data structure. The existence of an algebraic object
allows us to "meditate" on the proof technique as a separate object that does
not move through time. This allows us to "get to know" the algebraic object,
independent of how it's used. So, at least for me, I have a richness of
feeling when it comes to algebra that just doesn't shine through with analysis.
The one exception maybe reading something like "by compactness", which has
been hammered into me by exercises from Munkres :)
Meditating on a proof technique is much harder, since the proof technique
is necessarily intertwined with the problem, unlike a data structure which
to some degree has an independent existence.
This reminds me of the quote: "“Art is how we decorate space;
Music is how we decorate time.”. I'm not sure how to draw out the
tenuous connection I feel, but it's there.
Arjun comes from a background of combinatorics, and my understanding of his
perspective is that each proof is a technique unto itself. Or, perhaps
instantiating the technique for each proof is difficult enough that abstracting
it out is not useful enough in the first place.
A good example of a proof technique that got studied on its own right in
combinatorics is the probabilistic method. A more reasonable example is that of
the Pigeonhole principle, which still requires insight to instantiate in
practise.
Not that this does not occur in algebra either, but there is something in
algebra about how just meditating on the definitions. For example,
Whitney trick that got pulled out of the proof of the Whitney embedding
theorem.
To draw an analogy for the haskellers, it's the same joy of being able to write
down the type of a haskell function and know exactly what it does, enough that
a program can automatically derive the function (djinn). The fact that we know
the object well enough that just writing the type down allows us to infer the
<i>program</i>, makes it beautiful. There's something very elegant about the
<i>minimality</i> that algebra demands. Indeed, this calls back to another quote:
"perfection is achieved not when there is nothing more to add, but when there
is nothing left to take away".
I'm really glad that this 2 AM discussion allowed me to finally pin down
why I like algebra.
<h3><a id=for-cleaner-function-type-typedefs href='#for-cleaner-function-type-typedefs'> § </a> <a href=#using-for-cleaner-function-type-typedefs>
<code>using</code> for cleaner function type typedefs</a>
</h3>
I've always struggled with remembering the syntax for function type typedefs:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> <b><u><font color="#000000">typedef</font></u></b> RETTY (*FNTYNAME)(ARGTY1, ARGTY2, ..., ARGTYn);
<font color="#000000">3:</font> </tt></pre>
</div>

we can now use <code>using</code> for a far more pleasant syntax:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> <b><u><font color="#000000">using</font></u></b> FNTYNAME = RETTY(ARGTY1, ARGTY2, ..., ARGTYn);
<font color="#000000">3:</font> </tt></pre>
</div>

which is also intuitive. You write down the "type"
on the right hand side, and give it a name on the left.
This is not strictly the same, since the <code>typedef</code>
<code>typedefs</code> <code>FNTYNAME</code> to a <i>function pointer type</i>, while
the C++ version typedefs the <i>function type</i>. I prefer
the latter at any rate, since I dislike the fact
that the usual typedef tends to hide the fact that a
function pointer is some pointer-like-thing.
<h3><a id=a-walkway-of-lanterns href='#a-walkway-of-lanterns'> § </a> <a href=#a-walkway-of-lanterns>
A walkway of lanterns</a>
</h3>
<h4><a id=semidirect-products href='#semidirect-products'> § </a> Semidirect products</h4>
<ul>
<li>
 <span class='latexinline'>
(&#X3B1; &#X2261; { <span style="font-style:italic">a</span>, <span style="font-style:italic">b</span>, &#X2026;}, +, 0)</span>
</li>
<li>
 <span class='latexinline'>
(&#X3C9; &#X2261; { <span style="font-style:italic">X</span>, <span style="font-style:italic">Y</span>, &#X2026;}, &#XD7;, 1)</span>
</li>
<li>
 <span class='latexinline'>
&#XB7; &#XA0;: &#XA0;&#X3C9; &#X2192; <span style="font-style:italic">Automorphisms</span>(&#X3B1;)</span>
</li>

</ul>

<ul>
<li>
 <a href=https://www.cse.iitk.ac.in/users/ppk/research/publication/Conference/2016-09-22-How-to-twist-pointers.pdf>
How to twist pointers without breaking them</a>

</li>

</ul>

<ul>
<li>
 rotations: <span class='latexinline'>
&#X2124; 5</span>
</li>
<li>
 reflection: <span class='latexinline'>
&#X2124; 2</span>
</li>

</ul>

<ul>
<li>
 <span class='latexinline'>
<span style="font-style:italic">D</span><sub>5</sub> = &#X2124;5  &#X2124;2</span>
</li>

</ul>

<div class='latexblock'><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell">&#X23A1;<br>
&#X23A2;<br>
&#X23A3;</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >0&#XA0;</td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">a</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">X</span>
</td></tr>
</table></td><td class="dcell">&#X23A4;<br>
&#X23A5;<br>
&#X23A6;</td></tr>
</table></td><td class="dcell">
</td><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell">&#X23A1;<br>
&#X23A2;<br>
&#X23A3;</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >0&#XA0;</td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">b</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">Y</span>
</td></tr>
</table></td><td class="dcell">&#X23A4;<br>
&#X23A5;<br>
&#X23A6;</td></tr>
</table></td><td class="dcell">
=&#XA0;&#XA0;</td><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell">&#X23A1;<br>
&#X23A2;<br>
&#X23A3;</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >0&#XA0;</td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">a</span>&#XA0;+&#XA0;<span style="font-style:italic">X</span>&#XA0;&#XB7;&#XA0;<span style="font-style:italic">b</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">XY</span>
</td></tr>
</table></td><td class="dcell">&#X23A4;<br>
&#X23A5;<br>
&#X23A6;</td></tr>
</table></td></tr>
</table></td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table>
</div>
<ul>
<li>
 <span class='latexinline'>
(<span style="font-style:italic">Y</span> &#X21A6; <span style="font-style:italic">b</span>) &#X2192;<sup><span style="font-style:italic">act</span></sup> (<span style="font-style:italic">X</span> &#X21A6; <span style="font-style:italic">a</span>)</span>
</li>

</ul>

<ul>
<li>
 <span class='latexinline'>
<span style="font-style:italic">XY</span> &#X21A6; <span style="font-style:italic">a</span> + <span style="font-style:italic">X</span> &#XB7; <span style="font-style:italic">b</span></span>
</li>

</ul>

<h4><a id=a-walkway-of-lanterns href='#a-walkway-of-lanterns'> § </a> A walkway of lanterns</h4>
<ul>
<li>
 Imagine <span class='latexinline'>
&#X2124;</span> as a long walkway. you start at 0. You are but a poor lamp lighter.
</li>
<li>
 Where are the lamps? At each <span class='latexinline'>
<span style="font-style:italic">i</span> &#X2208; &#X2124;</span>, you have a lamp that is either on, or off. So you have <span class='latexinline'>
&#X2124;2</span>.
</li>

</ul>

<ul>
<li>
 <span class='latexinline'>
<span style="font-style:italic">L</span> &#X2261; &#X2124; &#X2192; &#X2124;2</span> is our space of lanterns. You can act on this space by either moving using <span class='latexinline'>
&#X2124;</span>, or toggling a lamp using <span class='latexinline'>
&#X2124;2</span>. <span class='latexinline'>
&#X2124;2<sup>&#X2124;</sup>  &#X2124;</span>
</li>

</ul>

<ul>
<li>
 <span class='latexinline'>
<span style="font-style:italic">g</span> = (<span style="font-style:italic">lights</span>:&#X27E8;&#X2212;1, 0, 1&#X27E9;, <span style="font-style:italic">loc</span>:10)</span>
</li>
<li>
 <span class='latexinline'>
<span style="font-style:italic">move</span><sub>3</sub>: (<span style="font-style:italic">lights</span>: &#X27E8; &#X27E9;, <span style="font-style:italic">loc</span>: 3)</span>
</li>
<li>
 <span class='latexinline'>
<span style="font-style:italic">move</span><sub>3</sub> &#XB7; <span style="font-style:italic">g</span> = (<span style="font-style:italic">lights</span>:&#X27E8;&#X2212;1, 0, 1&#X27E9;, <span style="font-style:italic">loc</span>:13)</span>
</li>
<li>
 <span class='latexinline'>
<span style="font-style:italic">togglex</span> = (<span style="font-style:italic">lights</span>:&#X27E8; 0, 2 &#X27E9;, <span style="font-style:italic">loc</span>: 0)</span>
</li>
<li>
 <span class='latexinline'>
<span style="font-style:italic">togglex</span> &#XB7; <span style="font-style:italic">g</span> = (<span style="font-style:italic">lights</span>: &#X27E8; &#X2212;1, 0, 1, 13, 15 &#X27E9;, <span style="font-style:italic">loc</span>:13)</span>
</li>
<li>
 <span class='latexinline'>
<span style="font-style:italic">toggley</span> = (<span style="font-style:italic">lights</span>: &#X27E8; &#X2212;13, &#X2212;12 &#X27E9;, <span style="font-style:italic">loc</span>:0)</span>
</li>
<li>
 <span class='latexinline'>
<span style="font-style:italic">toggley</span>&#XB7; <span style="font-style:italic">g</span>= (<span style="font-style:italic">lights</span>:&#X27E8; &#X2212;1 &#X27E9;, <span style="font-style:italic">loc</span>:13)</span>
</li>

</ul>

<h4><a id=krohn-rhodes-aka-how-to-model-freudian-psychoanalysis-using-lagrangians-over-semigroups href='#krohn-rhodes-aka-how-to-model-freudian-psychoanalysis-using-lagrangians-over-semigroups'> § </a> Krohn-rhodes, AKA how to model Freudian psychoanalysis using Lagrangians over semigroups.</h4>
<h3><a id=natural-transformations href='#natural-transformations'> § </a> <a href=#natural-transformations>
Natural transformations</a>
</h3>
<img width=400  src="./static/natural-transformation.png">
I don't find people who draw "all three parts" of the natural transformation:
the catories <span class='latexinline'>
<span style="font-style:italic">C</span></span>, <span class='latexinline'>
<span style="font-style:italic">FC</span></span>, and <span class='latexinline'>
<span style="font-style:italic">GC</span></span>, and then show the relationship between
them, so I made this for my own reference.
<h3><a id=the-hilarious-commentary-by-dinosaure-in-ocaml-git href='#the-hilarious-commentary-by-dinosaure-in-ocaml-git'> § </a> <a href=#the-hilarious-commentary-by-dinosaure-in-ocaml-git>
The hilarious commentary by dinosaure in OCaml git</a>
</h3>
the <a href=https://github.com/mirage/ocaml-git/>
Ocaml-git</a>
 project is a
re-implementation of <code>git</code> in <code>OCaml</code>. It's well-written, and I was
walking through the codebase, when I found absolutely amazing, hilarious,
and deep comments from <code>dinosaure</code>. I really enjoyed reading through the
codebase, and the existence of these comments made it more humane to read.
I don't know who <code>dinosaure</code> is, but I'm really glad they wrote the comments
they did, it really made my day.
<h4><a id=the-one-that-takes-a-stab-at-haskell-for-fun href='#the-one-that-takes-a-stab-at-haskell-for-fun'> § </a> The one that takes a stab at Haskell for fun</h4>
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> (* XXX(dinosaure): ...we can fix this detail but
<font color="#000000">3:</font> I'm lazy like haskell. TODO! *)
<font color="#000000">4:</font> </tt></pre>
</div>

<h4><a id=the-academic-one-that-broken-links-to-a-paper href='#the-academic-one-that-broken-links-to-a-paper'> § </a> The academic one that broken-links to a paper</h4>
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> (* XXX(dinosaure): see this paper
<font color="#000000">3:</font> https://github.com/ocamllabs/papers/blob/master/irmin/2014.08.matthieu/rapport.pdf *)
<font color="#000000">4:</font> </tt></pre>
</div>

<h4><a id=the-one-about-the-frustrations-of-bug-hunting href='#the-one-about-the-frustrations-of-bug-hunting'> § </a> The one about the frustrations of bug-hunting</h4>
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> (* XXX(dinosaure): [~chunked:false] is mandatory, I don't want to explain
<font color="#000000">3:</font> why (I lost one day to find this bug) but believe me. *)
<font color="#000000">4:</font> </tt></pre>
</div>

<h4><a id=the-one-about-a-potential-heisenbug href='#the-one-about-a-potential-heisenbug'> § </a> The one about a potential heisenbug</h4>
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> (* XXX(dinosaure): if, one day, we find a bug about the serialization of the
<font color="#000000">3:</font> IDX file, may be it's about this function (stable/unstable sort). *)
<font color="#000000">4:</font> </tt></pre>
</div>

<h4><a id=the-requisite-comment-in-french-for-an-ocaml-project href='#the-requisite-comment-in-french-for-an-ocaml-project'> § </a> The requisite comment in french for an OCaml project</h4>
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> (* XXX(dinosaure): bon ici, c'est une note compliqué, j'ai mis 2 jours
<font color="#000000">03:</font> à fixer le bug. Donc je l'explique en français, c'est plus simple.
<font color="#000000">04:</font> En gros, [Helper.MakeDecoder] utilise ce buffer comme buffer interne
<font color="#000000">05:</font> pour gérer les alterations. Ce qui ce passe, c'est que dans la
<font color="#000000">06:</font> fonction [refill], il s'agit de compléter à partir d'un [input]
<font color="#000000">07:</font> (typiquement [zl]) le buffer interne. C'est finalement un
<font color="#000000">08:</font> __mauvais__ jeu entre un [Cstruct.t] et un [Bigarray].
<font color="#000000">09:</font> Il s'agit de connaître la véritable taille du [Bigarray] et de
<font color="#000000">10:</font> rajouter avec [blit] le contenu de l'[input] si la taille du
<font color="#000000">11:</font> [Bigarray] (et pas du [Cstruct]) est suffisante.
<font color="#000000">12:</font> Avant, cette modification, [zl], [de] et [io] partagaient le même
<font color="#000000">13:</font> [Bigarray] découpé (avec [Cstruct]) en 3. Donc, dans le
<font color="#000000">14:</font> [MakeDecoder], [refill] considérait (pour des gros fichiers faisant
<font color="#000000">15:</font> plus de 0x8000 bytes) que après [de], nous avions encore de la
<font color="#000000">16:</font> place - et dans ce cas, nous avions [io].
<font color="#000000">17:</font> Ainsi, on [blit]ait [zl] dans [de+sizeof(de) == io], et finalement,
<font color="#000000">18:</font> on se retrouvait à essayer de décompresser ce que nous avions
<font color="#000000">19:</font> décompressé. (YOLO).
<font color="#000000">20:</font> Donc, on considère maintenant [de] comme un [Cstruct.t] et un
<font color="#000000">21:</font> [Bigarray] physiquement différent pour éviter ce problème.
<font color="#000000">22:</font> Cependant, il faudrait continuer à introspecter car j'ai
<font color="#000000">23:</font> l'intuition que pour un fichier plus gros que [2 * 0x8000], on
<font color="#000000">24:</font> devrait avoir un problème. Donc TODO. *)
<font color="#000000">25:</font> </tt></pre>
</div>

<h4><a id=the-deep-one href='#the-deep-one'> § </a> The deep one</h4>
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> (* XXX(dinosaure): at the end, we don't care if we lost something. *)
<font color="#000000">3:</font> </tt></pre>
</div>

<h3><a id=how-to-link-against-mlir-with-cmake href='#how-to-link-against-mlir-with-cmake'> § </a> <a href=#how-to-link-against-mlir-with-cmake>
How to link against MLIR with CMake</a>
</h3>
Since <code>MLIR</code> hasn't setup the nice tooling that LLVM has around <code>CMake</code>
as far as I can tell, one needs to actually <i>know</i> <code>CMake</code> to link against
<code>MLIR</code>. However, as is well known, <code>CMake</code> incantations are handed down
by preists who spend the better part of their lives studying the tome
that is the CMake manual. I, an unlucky soul had to go on this adventure,
and I hope to spare you the trouble.
I wished to link against a static library build of MLIR. The secret
lies in the <code>find_library</code> call:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> #If the variable has been set by -DMLIR_INCLUDE_PATH, then keep it.
<font color="#000000">03:</font> #Otherwise fallback to the environment variable $MLIR_INCLUDE_PATH.
<font color="#000000">04:</font> #if neither, then *shrug*.
<font color="#000000">05:</font> IF(NOT MLIR_INCLUDE_PATH)
<font color="#000000">06:</font>     set (MLIR_INCLUDE_PATH $ENV{MLIR_INCLUDE_PATH})
<font color="#000000">07:</font> endif()
<font color="#000000">08:</font> 
<font color="#000000">09:</font> #Resolve for:
<font color="#000000">10:</font> #- a library target called `MLIRAnalysis`
<font color="#000000">11:</font> #- asking to link against `libMLIAnalysis.a`
<font color="#000000">12:</font> #- using the variable MLIR_INCLUDE_PATH which as we saw before
<font color="#000000">13:</font> ##  is either an environment variable or a cmake option
<font color="#000000">14:</font> target_include_directories(languagemodels PRIVATE ${MLIR_INCLUDE_PATH})
<font color="#000000">15:</font> </tt></pre>
</div>

I cribbed the actual things to link against from the path
<a href=https://github.com/llvm/llvm-project/blob/master/mlir/examples/toy/Ch2/CMakeLists.txt>
<code>mlir/examples/Toy/Ch2/CMakeLists.txt</code></a>

which helpfully lists MLIR things it needs to link against.
The full <code>CMakeLists</code> is here:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> cmake_minimum_required(VERSION 3.5)
<font color="#000000">03:</font> project(languagemodels)
<font color="#000000">04:</font> 
<font color="#000000">05:</font> set(CMAKE_CXX_STANDARD 14)
<font color="#000000">06:</font> 
<font color="#000000">07:</font> ## I don't want to use find_package since I want proper control over where my LLVM comes from.
<font color="#000000">08:</font> ## find_package(LLVM REQUIRED)
<font color="#000000">09:</font> 
<font color="#000000">10:</font> add_executable(languagemodels
<font color="#000000">11:</font>         rnn.cpp codegenc.h lang.h codegenmlir.h)
<font color="#000000">12:</font> 
<font color="#000000">13:</font> ## Attempt to take these as command line arguments. IF that fails,
<font color="#000000">14:</font> ## lookup environment.
<font color="#000000">15:</font> IF(NOT MLIR_INCLUDE_PATH)
<font color="#000000">16:</font>     set (MLIR_INCLUDE_PATH $ENV{MLIR_INCLUDE_PATH})
<font color="#000000">17:</font> endif()
<font color="#000000">18:</font> 
<font color="#000000">19:</font> IF(NOT MLIR_LIBRARY_PATH)
<font color="#000000">20:</font>     set (MLIR_LIBRARY_PATH $ENV{MLIR_LIBRARY_PATH})
<font color="#000000">21:</font> endif()
<font color="#000000">22:</font> 
<font color="#000000">23:</font> target_include_directories(languagemodels PRIVATE ${MLIR_INCLUDE_PATH})
<font color="#000000">24:</font> find_library(MLIRAnalysis MLIRAnalysis ${MLIR_LIBRARY_PATH})
<font color="#000000">25:</font> find_library(MLIRIR MLIRIR ${MLIR_LIBRARY_PATH})
<font color="#000000">26:</font> find_library(MLIRParser MLIRParser ${MLIR_LIBRARY_PATH})
<font color="#000000">27:</font> find_library(MLIRSideEffects MLIRSideEffects ${MLIR_LIBRARY_PATH})
<font color="#000000">28:</font> find_library(MLIRTransforms MLIRTransforms ${MLIR_LIBRARY_PATH})
<font color="#000000">29:</font> find_library(LLVMCore LLVMCore ${MLIR_LIBRARY_PATH})
<font color="#000000">30:</font> find_library(LLVMSupport LLVMSupport ${MLIR_LIBRARY_PATH})
<font color="#000000">31:</font> 
<font color="#000000">32:</font> ## debugging to check if it's been set properly
<font color="#000000">33:</font> message(MLIR_INCLUDE_PATH ${MLIR_INCLUDE_PATH})
<font color="#000000">34:</font> message(MLIR_LIBRARY_PATH ${MLIR_LIBRARY_PATH})
<font color="#000000">35:</font> message(MLIRAnalysis ${MLIRAnalysis})
<font color="#000000">36:</font> 
<font color="#000000">37:</font> target_link_libraries(languagemodels
<font color="#000000">38:</font>         ${MLIRAnalysis}
<font color="#000000">39:</font>         ${MLIRIR}
<font color="#000000">40:</font>         ${MLIRParser}
<font color="#000000">41:</font>         ${MLIRSideEffects}
<font color="#000000">42:</font>         ${MLIRTransforms}
<font color="#000000">43:</font>         ${LLVMCore}
<font color="#000000">44:</font>         ${LLVMSupport})
<font color="#000000">45:</font> </tt></pre>
</div>

<h3><a id=energy-as-triangulaizing-state-space href='#energy-as-triangulaizing-state-space'> § </a> <a href=#energy-as-triangulaizing-state-space>
Energy as triangulaizing state space</a>
</h3>
This comes from The wild book by John Rhodes, which I anticipate I'll be posting more of in the coming weeks.
<h4><a id=experiments href='#experiments'> § </a> Experiments</h4>
Let an experiment be a tuple of the phase space <span class='latexinline'>
<span style="font-style:italic">X</span></span>, action space <span class='latexinline'>
<span style="font-style:italic">A</span></span>,
and an action of the actions onto the phase space
<span class='latexinline'>
: <span style="font-style:italic">A</span> &#XD7; <span style="font-style:italic">X</span> &#X2192; <span style="font-style:italic">X</span></span>. We will write
<span class='latexinline'>
<span style="font-style:italic">x</span>&#X2032; = <span style="font-style:italic">a</span>  <span style="font-style:italic">x</span></span> to denote the new state of the system
<span class='latexinline'>
<span style="font-style:italic">x</span></span>. So the experiment <span class='latexinline'>
<span style="font-style:italic">E</span></span> is the data
<span class='latexinline'>
<span style="font-style:italic">E</span> &#X2261; (<span style="font-style:italic">X</span>, <span style="font-style:italic">A</span>,  : <span style="font-style:italic">A</span> &#XD7; <span style="font-style:italic">X</span> &#X2192; <span style="font-style:italic">X</span>)</span>.
<h4><a id=coordinate-systems href='#coordinate-systems'> § </a> Coordinate systems.</h4>
The existence of the action <span class='latexinline'>
</span> allows us to
write the evolution of the system recursively:
<span class='latexinline'>
<span style="font-style:italic">x</span><sub><span style="font-style:italic">t</span>+1</sub> = <span style="font-style:italic">a</span> &#X2192; <span style="font-style:italic">x</span><sub><span style="font-style:italic">t</span></sub></span>.
However, to understand the final state <span class='latexinline'>
<span style="font-style:italic">x</span><sub><span style="font-style:italic">t</span>+1</sub></span>, we need to essentially
"run the recursion", which does not permit us to 
<i>understand the experiment</i>.
What we really need is the ability to "unroll" the loop. To quote:
<blockquote> Informally, understanding an experiment <span class='latexinline'>
<span style="font-style:italic">E</span></span> means introducing coordinates into phase space of <span class='latexinline'>
<span style="font-style:italic">E</span></span> which are in triangular form under the action of the inputs of <span class='latexinline'>
<span style="font-style:italic">E</span></span>.</blockquote>
<h4><a id=conservation-laws-as-triangular-form href='#conservation-laws-as-triangular-form'> § </a> Conservation laws as triangular form</h4>
We identify certain interesting invariants of a system by two criteria:
<ol>
<li>
 The parameter <span class='latexinline'>
<span style="font-style:italic">Q</span>(<span style="font-style:italic">t</span>)</span> determines some obviously important aspects of
   the system. That is, there is a deterministic function <span class='latexinline'>
<span style="font-style:italic">M</span>(<span style="font-style:italic">Q</span>(<span style="font-style:italic">t</span>))</span> which
   maps <span class='latexinline'>
<span style="font-style:italic">Q</span>(<span style="font-style:italic">t</span>)</span> to "measure" some internal state of the system.
</li>
<li>
 If the values of such a  parameter <span class='latexinline'>
<span style="font-style:italic">Q</span></span> is known at time <span class='latexinline'>
<span style="font-style:italic">t</span><sub>0</sub></span> (denoted <span class='latexinline'>
<span style="font-style:italic">Q</span>(<span style="font-style:italic">t</span><sub>0</sub>)</span>)
    and it is also known what inputs are presented to the
    system from time <span class='latexinline'>
<span style="font-style:italic">t</span></span> to time <span class='latexinline'>
<span style="font-style:italic">t</span> + &#X454;</span>
    (denoted <span class='latexinline'>
<span style="font-style:italic">I</span>[<span style="font-style:italic">t</span><sub>0</sub>, <span style="font-style:italic">t</span><sub>0</sub> + &#X454;]</span>), then the new value of <span class='latexinline'>
<span style="font-style:italic">Q</span></span> is a
    deterministic function of <span class='latexinline'>
<span style="font-style:italic">Q</span>(<span style="font-style:italic">t</span><sub>0</sub>)</span> and <span class='latexinline'>
<span style="font-style:italic">I</span>[<span style="font-style:italic">t</span><sub>0</sub>, <span style="font-style:italic">t</span><sub>0</sub>+ &#X454;]</span>.
</li>

</ol>

Such parameters allow us to understand a system, since they are deterministic
parameters of the evolution of the system, while also provding a way to
measure some internal state of the system using <span class='latexinline'>
<span style="font-style:italic">M</span></span>.
For example, consider a system <span class='latexinline'>
<span style="font-style:italic">x</span></span> with an energy function <span class='latexinline'>
<span style="font-style:italic">e</span>(<span style="font-style:italic">x</span>)</span>. If we
perform an action <span class='latexinline'>
<span style="font-style:italic">a</span></span> on the system <span class='latexinline'>
<span style="font-style:italic">x</span></span>, then we can predict the action
<span class='latexinline'>
<span style="font-style:italic">e</span>(<span style="font-style:italic">x</span>&#X2032; = <span style="font-style:italic">a</span>  <span style="font-style:italic">x</span>)</span> given just <span class='latexinline'>
<span style="font-style:italic">e</span>(<span style="font-style:italic">x</span>)</span> and <span class='latexinline'>
<span style="font-style:italic">a</span></span> --- here,
<span class='latexinline'>
(<span style="font-style:italic">x</span>&#X2032; = <span style="font-style:italic">a</span>  <span style="font-style:italic">x</span>)</span> is the action of the system <span class='latexinline'>
<span style="font-style:italic">a</span></span> on <span class='latexinline'>
<span style="font-style:italic">x</span></span>.
<blockquote> In general, conservation principles give a first coordinate of a triangularization. In the main a large part of physics can be viewed as discovering and introducing functions <span class='latexinline'>
<span style="font-style:italic">e</span></span> of the states <span class='latexinline'>
<span style="font-style:italic">q</span></span> of the system such that under action <span class='latexinline'>
<span style="font-style:italic">a</span></span>, <span class='latexinline'>
<span style="font-style:italic">e</span>(<span style="font-style:italic">a</span>  <span style="font-style:italic">q</span>)</span> depends only on <span class='latexinline'>
<span style="font-style:italic">e</span>(<span style="font-style:italic">q</span>)</span> and <span class='latexinline'>
<span style="font-style:italic">a</span></span>, and <b>not</b> on <span class='latexinline'>
<span style="font-style:italic">q</span></span>.</blockquote>
<h4><a id=theory-semidirect-and-wreath-products href='#theory-semidirect-and-wreath-products'> § </a> Theory: semidirect and wreath products</h4>
<ul>
<li>
 For semidirect products, I refer you to
    <a href=#the-cutest-way-to-write-semidirect-products>
the cutest way to write semidirect products</a>

    <a href=#line-of-investigation-to-build-physical-intuition-for-semidirect-products>
Line of investigation to build physical intuition for semidirect products</a>
.
</li>

</ul>

<h4><a id=symmetries-as-triangular-form href='#symmetries-as-triangular-form'> § </a> Symmetries as triangular form</h4>
<blockquote> We first heuristically indicate the construction involved in going from the group of symmetries to the triangularization, and then precisely write it out in all pedantic detail.</blockquote>
Let an experiment be <span class='latexinline'>
<span style="font-style:italic">E</span> &#X2261; (<span style="font-style:italic">X</span>, <span style="font-style:italic">A</span>, )</span>. Then we define <span class='latexinline'>
&#X3A0;</span>
is a <i>symmetry</i> of <span class='latexinline'>
<span style="font-style:italic">E</span></span> iff:
<ol>
<li>
 <span class='latexinline'>
&#X3A0;: <span style="font-style:italic">X</span> &#X2192; <span style="font-style:italic">X</span></span> is a permutation of <span class='latexinline'>
<span style="font-style:italic">X</span></span>.
</li>
<li>
 <span class='latexinline'>
&#X3A0;</span> commutes with the action of each <span class='latexinline'>
<span style="font-style:italic">a</span></span>:
       <span class='latexinline'>
 &#X3A0;(<span style="font-style:italic">a</span>  <span style="font-style:italic">x</span>) = <span style="font-style:italic">a</span>  &#X3A0;(<span style="font-style:italic">x</span>) </span>.
</li>

</ol>

We say that the theory <span class='latexinline'>
<span style="font-style:italic">E</span></span> is <i>transitive</i> (in the action sense) if for
all <span class='latexinline'>
<span style="font-style:italic">x</span><sub>1</sub>, <span style="font-style:italic">x</span><sub>2</sub> &#X2208; <span style="font-style:italic">X</span>, <span style="font-style:italic">x</span><sub>1</sub> &#X2260; <span style="font-style:italic">x</span><sub>2</sub></span>, there exists <span class='latexinline'>
<span style="font-style:italic">a</span><sub>1</sub>, <span style="font-style:italic">a</span><sub>2</sub>, &#X2026; <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub></span>
such that <span class='latexinline'>
 <span style="font-style:italic">x</span><sub>2</sub> = <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>  &#X2026; (<span style="font-style:italic">a</span><sub>1</sub>  <span style="font-style:italic">x</span><sub>1</sub>) </span>.
Facts of the symmetries of a system:
<ol>
<li>
 We know that the symmetries of a theory <span class='latexinline'>
<span style="font-style:italic">E</span></span> form a group.
</li>
<li>
 If <span class='latexinline'>
<span style="font-style:italic">E</span></span> is transitive, then each symmetry <span class='latexinline'>
&#X3A0;</span> is a regular permutation
   --- If there exists an <span class='latexinline'>
<span style="font-style:italic">x</span></span> such that <span class='latexinline'>
&#X3A0;(<span style="font-style:italic">x</span><sub><span style="font-style:italic">f</span></sub>) = <span style="font-style:italic">x</span><sub><span style="font-style:italic">f</span></sub></span> (a fixed point), then
   this implies that <span class='latexinline'>
&#X3A0;(<span style="font-style:italic">x</span>) = <span style="font-style:italic">x</span></span> for <i>all</i> <span class='latexinline'>
<span style="font-style:italic">x</span></span>.
</li>
<li>
 Let the action split <span class='latexinline'>
<span style="font-style:italic">X</span></span> into disjoint orbits <span class='latexinline'>
<span style="font-style:italic">O</span><sub>1</sub>, <span style="font-style:italic">O</span><sub>2</sub>, &#X2026; <span style="font-style:italic">O</span><sub><span style="font-style:italic">k</span></sub></span> from whom
   we choose representatives <span class='latexinline'>
<span style="font-style:italic">x</span><sub>1</sub> &#X2208; <span style="font-style:italic">O</span><sub>1</sub>, <span style="font-style:italic">x</span><sub>2</sub> &#X2208; <span style="font-style:italic">O</span><sub>2</sub>, &#X2026; <span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub> &#X2208; <span style="font-style:italic">O</span><sub><span style="font-style:italic">k</span></sub></span>.
   Then, if <span class='latexinline'>
<span style="font-style:italic">E</span></span> is transitive, there is <i>exactly one</i> action that sends a
   particular <span class='latexinline'>
<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub></span> to a particular <span class='latexinline'>
<span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub></span>. So, on fixing <i>one component</i>
   of an action, we fix <i>all components</i>.
</li>

</ol>

To show that this gives rise to a triangulation, we first construct
a semigroup of the actions of the experiment:
<span class='latexinline'>
<span style="font-style:italic">S</span>(<span style="font-style:italic">E</span>) &#X2261; { <span style="font-style:italic">a</span><sub>1</sub> &#X2026; <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub> : <span style="font-style:italic">n</span> &#X2265; 1 &#XA0;and&#XA0; <span style="font-style:italic">a</span><sub><span style="font-style:italic">i</span></sub> &#X2208; <span style="font-style:italic">A</span> }</span>.
Now, let <span class='latexinline'>
<span style="font-style:italic">G</span> = <span style="font-style:italic">Sym</span>(<span style="font-style:italic">E</span>)</span>, the full symmetry group of <span class='latexinline'>
<span style="font-style:italic">E</span></span>. One can apparently
express the symmetry group in terms of:
<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(<span style="font-style:italic">X</span>,&#XA0;<span style="font-style:italic">S</span>)&#XA0;&#X2264;&#XA0;(<span style="font-style:italic">G</span>,&#XA0;<span style="font-style:italic">G</span>)&#XA0;&#XA0;&#X2240;&#XA0;({&#XA0;<span style="font-style:italic">O</span><sub>1</sub>,&#XA0;<span style="font-style:italic">O</span><sub>2</sub>,&#XA0;&#X2026;&#XA0;<span style="font-style:italic">O</span><sub><span style="font-style:italic">k</span></sub>},&#XA0;<span style="font-style:italic">T</span>)</td></tr>
</table></div>
<h3><a id=the-cutest-way-to-write-semidirect-products href='#the-cutest-way-to-write-semidirect-products'> § </a> <a href=#the-cutest-way-to-write-semidirect-products>
The cutest way to write semidirect products</a>
</h3>
Given two monoids <span class='latexinline'>
(<span style="font-style:italic">M</span>, +, 0<sub><span style="font-style:italic">M</span></sub>)</span> and <span class='latexinline'>
(<span style="font-style:italic">N</span>, &#XD7;, 1<sub><span style="font-style:italic">N</span></sub>)</span>, and a
homomorphism <span class='latexinline'>
&#X3C6;: <span style="font-style:italic">N</span> &#X2192; <span style="font-style:italic">End</span>(<span style="font-style:italic">M</span>)</span>, where <span class='latexinline'>
<span style="font-style:italic">End</span>(<span style="font-style:italic">M</span>)</span>
is the endomorphism group of <span class='latexinline'>
<span style="font-style:italic">M</span></span>. We will notate <span class='latexinline'>
&#X3C6;(<span style="font-style:italic">n</span>)(<span style="font-style:italic">m</span>)</span> as <span class='latexinline'>
<span style="font-style:italic">n</span> &#XB7; <span style="font-style:italic">m</span> &#X2208; <span style="font-style:italic">M</span></span>.
Now the semidirect product <span class='latexinline'>
<span style="font-style:italic">M</span> <sub>&#X3C6;</sub><span style="font-style:italic">N</span></span> is the set <span class='latexinline'>
<span style="font-style:italic">M</span> &#XD7; <span style="font-style:italic">N</span></span> equipped
with the multiplication rule:
<ul>
<li>
 <span class='latexinline'>
(<span style="font-style:italic">m</span>, <span style="font-style:italic">n</span>) (<span style="font-style:italic">m</span>&#X2032;, <span style="font-style:italic">n</span>&#X2032;) = (<span style="font-style:italic">m</span> + <span style="font-style:italic">n</span> &#XB7; <span style="font-style:italic">m</span>&#X2032;, <span style="font-style:italic">nn</span>&#X2032;)</span>
</li>

</ul>

This can also be written down as:
<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell">&#X23A1;<br>
&#X23A2;<br>
&#X23A3;</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >0&#XA0;</td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">m</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">n</span>
</td></tr>
</table></td><td class="dcell">&#X23A4;<br>
&#X23A5;<br>
&#X23A6;</td></tr>
</table></td><td class="dcell">
</td><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell">&#X23A1;<br>
&#X23A2;<br>
&#X23A3;</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >0&#XA0;</td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">m</span>&#X2032;</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">n</span>&#X2032;
</td></tr>
</table></td><td class="dcell">&#X23A4;<br>
&#X23A5;<br>
&#X23A6;</td></tr>
</table></td><td class="dcell">=
</td><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell">&#X23A1;<br>
&#X23A2;<br>
&#X23A3;</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >0&#XA0;</td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">m</span>&#XA0;+&#XA0;<span style="font-style:italic">n</span>&#XA0;&#XB7;&#XA0;<span style="font-style:italic">m</span>&#X2032;</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">n</span>&#XA0;&#XD7;&#XA0;<span style="font-style:italic">n</span>&#X2032;
</td></tr>
</table></td><td class="dcell">&#X23A4;<br>
&#X23A5;<br>
&#X23A6;</td></tr>
</table></td></tr>
</table></div>
This way of writing down semidirect products as matrices makes many things
immediately clear:
<ul>
<li>
 The semidirect product is some kind of "shear" transform, since that's
  what a shear transformation looks like, matrix-wise.
</li>
<li>
 The resulting monoid <span class='latexinline'>
<span style="font-style:italic">M</span> <sub>&#X3C6;</sub> <span style="font-style:italic">N</span></span> has identity <span class='latexinline'>
(0<sub><span style="font-style:italic">M</span></sub>, 1<sub><span style="font-style:italic">N</span></sub>)</span>,
  since for the matrix to be identity, we need the 2nd row to be <span class='latexinline'>
(0, 1)</span>.
</li>
<li>
 The inverse operation if <span class='latexinline'>
(<span style="font-style:italic">M</span>, <span style="font-style:italic">N</span>)</span> were groups would have to be such that
</li>

</ul>

<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell">&#X23A1;<br>
&#X23A2;<br>
&#X23A3;</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >0&#XA0;</td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">m</span>&#XA0;+&#XA0;<span style="font-style:italic">n</span>&#XA0;&#XB7;&#XA0;<span style="font-style:italic">m</span>&#X2032;</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">n</span>&#XA0;&#XD7;&#XA0;<span style="font-style:italic">n</span>&#X2032;&#XA0;</td></tr>
</table></td><td class="dcell">&#X23A4;<br>
&#X23A5;<br>
&#X23A6;</td></tr>
</table></td><td class="dcell">=
</td><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell">&#X23A1;<br>
&#X23A2;<br>
&#X23A3;</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >0&#XA0;</td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >1&#XA0;</td></tr>
</table></td><td class="dcell">&#X23A4;<br>
&#X23A5;<br>
&#X23A6;</td></tr>
</table></td></tr>
</table></div>
Hence:
<ul>
<li>
 <span class='latexinline'>
<span style="font-style:italic">nn</span>&#X2032; = 1</span> implies that <span class='latexinline'>
<span style="font-style:italic">n</span>&#X2032; = 1/<span style="font-style:italic">n</span></span>.
</li>
<li>
 <span class='latexinline'>
<span style="font-style:italic">m</span> + <span style="font-style:italic">n</span> <span style="font-style:italic">m</span>&#X2032; = 0</span> implies that <span class='latexinline'>
<span style="font-style:italic">m</span>&#X2032; = &#X2212;<span style="font-style:italic">m</span>/<span style="font-style:italic">n</span></span>.
</li>

</ul>

which is indeed the right expression for the inverse.
<h3><a id=my-favourite-aplisms href='#my-favourite-aplisms'> § </a> <a href=#my-favourite-aplisms>
My Favourite APLisms</a>
</h3>
<h4><a id=identity-matrix href='#identity-matrix'> § </a> identity matrix</h4>
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> n←3 ⋄ id ← n n ⍴(1,n⍴0) ⋄ id
<font color="#000000">3:</font> </tt></pre>
</div>

This relies heavily on <code>⍴</code> replicating its arguments.
<h4><a id=histogram href='#histogram'> § </a> histogram</h4>
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> xs←(1 1 3 3 3 6) ⋄ n←(⌈/xs)⍴0 ⋄ n[xs]+←1 ⋄ n
<font color="#000000">3:</font> </tt></pre>
</div>

The use of <code>n[x] +←1</code> will stably write <code>+1</code> as many times as there are repeated
indexes in <code>xs</code>.
<h4><a id=ring-matching-parity-as-fold- href='#ring-matching-parity-as-fold-'> § </a> String matching / parity as fold <code>≠</code>:</h4>
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> ]disp str ← (1 0 0 1 0 0 0 0 1 0 1 0 0 0) ⋄ 2 1 ⍴ ((⊂ str) ⍪ ⊂((≠\str)))
<font color="#000000">3:</font> ┌→──────────────────────────┐
<font color="#000000">4:</font> ↓1 0 0 1 0 0 0 0 1 0 1 0 0 0│
<font color="#000000">5:</font> ├~─────────────────────────→┤
<font color="#000000">6:</font> │1 1 1 0 0 0 0 0 1 1 0 0 0 0│
<font color="#000000">7:</font> └~─────────────────────────→┘
<font color="#000000">8:</font> </tt></pre>
</div>

<h3><a id=proof-of-chinese-remainder-theorem-on-rings href='#proof-of-chinese-remainder-theorem-on-rings'> § </a> <a href=#proof-of-chinese-remainder-theorem-on-rings>
Proof of chinese remainder theorem on rings</a>
</h3>
<h4><a id=general-operations-on-ideals href='#general-operations-on-ideals'> § </a> General operations on ideals</h4>
We have at our hands a commutative ring <span class='latexinline'>
<span style="font-style:italic">R</span></span>, and we wish to study the ideal
structure on the ring. In particular, we can combine ideals in the following
ways:
<ol>
<li>
 <span class='latexinline'>
<span style="font-style:italic">I</span> + <span style="font-style:italic">J</span> &#X2261; { <span style="font-style:italic">i</span> + <span style="font-style:italic">j</span> : &#X2200; <span style="font-style:italic">i</span> &#X2208; <span style="font-style:italic">I</span>, <span style="font-style:italic">j</span> &#X2208; <span style="font-style:italic">J</span> }</span>
</li>
<li>
 <span class='latexinline'>
<span style="font-style:italic">I</span> &#X2229; <span style="font-style:italic">J</span> &#X2261; { <span style="font-style:italic">x</span> : &#X2200; <span style="font-style:italic">x</span> &#X2208; <span style="font-style:italic">I</span> &#X2227; <span style="font-style:italic">x</span> &#X2208; <span style="font-style:italic">J</span> }</span>
</li>
<li>
 <span class='latexinline'>
<span style="font-style:italic">IJ</span> &#X2261; { <span style="font-style:italic">ij</span> : &#X2200; <span style="font-style:italic">i</span> &#X2208; <span style="font-style:italic">I</span> &#X2227; <span style="font-style:italic">j</span> &#X2208; <span style="font-style:italic">J</span> }</span> (<b>wrong!</b>)
</li>

</ol>

Is the third one really right? How do we prove that:
<span class='latexinline'>
&#X2200; <span style="font-style:italic">i</span><sub>1</sub>, <span style="font-style:italic">i</span><sub>2</sub> &#X2208; <span style="font-style:italic">I</span>, <span style="font-style:italic">j</span><sub>1</sub>, <span style="font-style:italic">j</span><sub>2</sub> &#X2208; <span style="font-style:italic">J</span>, &#X2203; <span style="font-style:italic">i</span><sub>3</sub> &#X2208; <span style="font-style:italic">I</span>, <span style="font-style:italic">j</span><sub>3</sub> &#X2208; <span style="font-style:italic">J</span></span> such that
<span class='latexinline'>
<span style="font-style:italic">i</span><sub>1</sub> <span style="font-style:italic">j</span><sub>2</sub> + <span style="font-style:italic">i</span><sub>2</sub> <span style="font-style:italic">j</span><sub>2</sub> = <span style="font-style:italic">i</span><sub>3</sub> <span style="font-style:italic">j</span><sub>3</sub></span>?
Indeed, we can't do so in general! For
a quick counter-example, consider the ring <span class='latexinline'>
&#X2124;[<span style="font-style:italic">X</span>, <span style="font-style:italic">Y</span>]</span> and the ideals
<span class='latexinline'>
<span style="font-style:italic">I</span> &#X2261; &#X27E8; <span style="font-style:italic">X</span> &#X27E9;</span>, <span class='latexinline'>
<span style="font-style:italic">J</span> &#X2261; &#X27E8; <span style="font-style:italic">Y</span> &#X27E9;</span>. Now, note
that <span class='latexinline'>
<span style="font-style:italic">XY</span> + <span style="font-style:italic">X</span><sup>2</sup><span style="font-style:italic">Y</span><sup>2</sup></span> cannot be written as the product of a power of <span class='latexinline'>
<span style="font-style:italic">X</span></span>
and a power of <span class='latexinline'>
<span style="font-style:italic">Y</span></span>.
So, the <i>correct definition</i> is to in fact <i>generate an ideal</i> from all
elements of the form <span class='latexinline'>
<span style="font-style:italic">ij</span></span>. So #3 should be:
<ul>
<li>
 <span class='latexinline'>
<span style="font-style:italic">IJ</span> &#X2261; { &#X2211;<sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">i</span><sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">j</span><sub><span style="font-style:italic">k</span></sub> : &#X2200; <span style="font-style:italic">i</span><sub><span style="font-style:italic">k</span></sub> &#X2208; <span style="font-style:italic">I</span> &#X2227; <span style="font-style:italic">j</span><sub><span style="font-style:italic">k</span></sub> &#X2208; <span style="font-style:italic">J</span> }</span> (<b>right!</b>)
</li>

</ul>

<h4><a id=mathbb-zzing-ideal-operations-to- href='#mathbb-zzing-ideal-operations-to-'> § </a> Specializing ideal operations to <span class='latexinline'>
&#X2124;</span></h4>
Let <span class='latexinline'>
<span style="font-style:italic">I</span> &#X2261; &#X27E8; 12 &#X27E9;, <span style="font-style:italic">J</span> &#X2261; &#X27E8; 20 &#X27E9;</span>.
<ul>
<li>
 <span class='latexinline'>
<span style="font-style:italic">I</span> + <span style="font-style:italic">J</span> &#X2261; { 12<span style="font-style:italic">k</span> + 20<span style="font-style:italic">l</span> : <span style="font-style:italic">k</span>, <span style="font-style:italic">l</span> &#X2208; &#X2124;} = &#X27E8; <span style="font-style:italic">gcd</span>(12, 20) &#X27E9; = &#X27E8; 4 &#X27E9;</span>
</li>
<li>
 <span class='latexinline'>
<span style="font-style:italic">IJ</span> &#X2261; &#X27E8;{ (12 <span style="font-style:italic">k</span>)(20 <span style="font-style:italic">l</span>) : <span style="font-style:italic">k</span>, <span style="font-style:italic">l</span> &#X2208; &#X2124; }&#X27E9; = </span>
</li>
<li>
 <span class='latexinline'>
<span style="font-style:italic">I</span> &#X2229; <span style="font-style:italic">J</span> &#X2261; ??</span>
</li>

</ul>

Great. Now, one can conjecture the relation:
<ul>
<li>
 <span class='latexinline'>
(<span style="font-style:italic">I</span> + <span style="font-style:italic">J</span>)(<span style="font-style:italic">I</span> &#X2229; <span style="font-style:italic">J</span>) = <span style="font-style:italic">IJ</span></span>
</li>

</ul>

by the following chain of inference:
<ul>
<li>
 <span class='latexinline'>
(<span style="font-style:italic">I</span> + <span style="font-style:italic">J</span>)(<span style="font-style:italic">I</span> &#X2229; <span style="font-style:italic">J</span>) = <span style="font-style:italic">I</span>(<span style="font-style:italic">I</span> &#X2229; <span style="font-style:italic">J</span>) + <span style="font-style:italic">J</span>(<span style="font-style:italic">I</span> &#X2229; <span style="font-style:italic">J</span>) &#X2286; <span style="font-style:italic">IJ</span> + <span style="font-style:italic">JI</span> = <span style="font-style:italic">IJ</span></span>.
</li>

</ul>

<h4><a id=references href='#references'> § </a> References</h4>
<ul>
<li>
 <a href=https://www.youtube.com/watch?v=YxyxP894MLk>
I learnt the material from this course on commutative algebra from IIT bombay</a>
.
</li>

</ul>

<h3><a id=monic-and-epic-arrows href='#monic-and-epic-arrows'> § </a> <a href=#monic-and-epic-arrows>
monic and epic arrows</a>
</h3>
This is trivial, I'm surprised it took me <i>this long</i> to internalize this fact.
When we convert a poset <span class='latexinline'>
(<span style="font-style:italic">X</span>, &#X2264;)</span> into a category, we stipulate that
<span class='latexinline'>
<span style="font-style:italic">x</span> &#X2192; <span style="font-style:italic">y</span> &#XA0;&#X21D0;&#X21D2;&#XA0;<span style="font-style:italic">x</span> &#X2264; <span style="font-style:italic">y</span></span>.
If we now consider the category <span class='latexinline'>
<span style="font-style:italic">Set</span></span> of sets and functions between sets,
and arrow <span class='latexinline'>
<span style="font-style:italic">A</span> &#X2192;<sup><span style="font-style:italic">f</span></sup> <span style="font-style:italic">B</span></span> is a function from <span class='latexinline'>
<span style="font-style:italic">A</span></span> to <span class='latexinline'>
<span style="font-style:italic">B</span></span>. If <span class='latexinline'>
<span style="font-style:italic">f</span></span> is
monic, then we know that <span class='latexinline'>
|<span style="font-style:italic">A</span>| = |<span style="font-style:italic">Im</span>(<span style="font-style:italic">f</span>)| &#X2264; |<span style="font-style:italic">B</span>|</span>. That is, a monic arrow
behaves a lot like a poset arrow!
Similarly, an epic arrow behaves a lot like the arrow in the inverse poset.
I wonder if quite a lot of category theoretic diagrams are clarified by thinking
of monic and epic directly in terms of controlling sizes.
<h3><a id=the-geometry-of-lagrange-multipliers href='#the-geometry-of-lagrange-multipliers'> § </a> <a href=#the-geometry-of-lagrange-multipliers>
The geometry of Lagrange multipliers</a>
</h3>
If we want to minise a function <span class='latexinline'>
<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)</span> subject to the constraints <span class='latexinline'>
<span style="font-style:italic">g</span>(<span style="font-style:italic">x</span>) = <span style="font-style:italic">c</span></span>,
one uses the method of lagrange multipliers. The idea is to consider a new
function <span class='latexinline'>
<span style="font-style:italic">L</span>(<span style="font-style:italic">x</span>, &#X3BB;) = <span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>) + &#X3BB; (<span style="font-style:italic">c</span> &#X2212; <span style="font-style:italic">g</span>(<span style="font-style:italic">x</span>))</span>. Now, if one has a local maxima
<span class='latexinline'>
(<span style="font-style:italic">x</span><sup>&#X22C6;</sup>, <span style="font-style:italic">y</span><sup>&#X22C6;</sup>)</span>, then the conditions:
<ol>
<li>
 <span class='latexinline'>
&#X2202; <span style="font-style:italic">L</span>/&#X2202; <span style="font-style:italic">x</span> = 0</span>: <span class='latexinline'>
<span style="font-style:italic">f</span>&#X2032;(<span style="font-style:italic">x</span><sup>&#X22C6;</sup>) &#X2212; &#X3BB; <span style="font-style:italic">g</span>&#X2032;(<span style="font-style:italic">x</span><sup>&#X22C6;</sup>) = 0</span>.
</li>
<li>
 <span class='latexinline'>
&#X2202; <span style="font-style:italic">L</span>/&#X2202; &#X3BB; = 0</span>: <span class='latexinline'>
<span style="font-style:italic">g</span>(<span style="font-style:italic">x</span><sup>&#X22C6;</sup>) = <span style="font-style:italic">c</span></span>.
</li>

</ol>

Equation (2) is sensible: we want our optima to satisfy the constraint that
we had originally imposed. What is Equation (1) trying to say?
Geometrically, it's asking us to keep <span class='latexinline'>
<span style="font-style:italic">f</span>&#X2032;(<span style="font-style:italic">x</span><sup>&#X22C6;</sup>)</span> parallel to <span class='latexinline'>
<span style="font-style:italic">g</span>&#X2032;(<span style="font-style:italic">x</span><sup>&#X22C6;</sup>)</span>.
Why is this a good ask?
Let us say that we are at an <span class='latexinline'>
(<span style="font-style:italic">x</span><sub>0</sub>)</span> which is a feasible point (<span class='latexinline'>
<span style="font-style:italic">g</span>(<span style="font-style:italic">x</span><sub>0</sub>) = <span style="font-style:italic">c</span></span>).
We are interested in wiggling
<span class='latexinline'>
(<span style="font-style:italic">x</span><sub>0</sub>) &#X2192;<sup><span style="font-style:italic">wiggle</span></sup> (<span style="font-style:italic">x</span><sub>0</sub> + &#X454;<sup>&#X2192;</sup>) &#X2261; <span style="font-style:italic">x</span><sub>1</sub></span>.
<ul>
<li>
 <span class='latexinline'>
<span style="font-style:italic">x</span><sub>1</sub></span> is still feasible: <span class='latexinline'>
<span style="font-style:italic">g</span>(<span style="font-style:italic">x</span><sub>1</sub>) = <span style="font-style:italic">c</span> = <span style="font-style:italic">g</span>(<span style="font-style:italic">x</span><sub>0</sub>)</span>.
</li>
<li>
 <span class='latexinline'>
<span style="font-style:italic">x</span><sub>1</sub></span> is an improvement: <span class='latexinline'>
<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span><sub>1</sub>) &gt; <span style="font-style:italic">f</span>(<span style="font-style:italic">x</span><sub>0</sub>)</span>.
</li>

</ul>

<ul>
<li>
 If we want <span class='latexinline'>
<span style="font-style:italic">g</span>(<span style="font-style:italic">x</span><sub>1</sub>)</span> to not change, then we need <span class='latexinline'>
<span style="font-style:italic">g</span>&#X2032;(<span style="font-style:italic">x</span><sub>0</sub>) &#XB7; &#X454;<sup>&#X2192;</sup>= 0</span>.
</li>
<li>
 If we want <span class='latexinline'>
<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span><sub>1</sub>)</span> to be larger, we need <span class='latexinline'>
<span style="font-style:italic">f</span>&#X2032;(<span style="font-style:italic">x</span><sub>0</sub>) &#XB7; &#X454;<sup>&#X2192;</sup>&gt; 0</span>.
</li>

</ul>

If <span class='latexinline'>
<span style="font-style:italic">f</span>&#X2032;(<span style="font-style:italic">x</span><sub>0</sub>)</span> and <span class='latexinline'>
<span style="font-style:italic">g</span>&#X2032;(<span style="font-style:italic">x</span><sub>0</sub>)</span> are parallel, then attempting to improve <span class='latexinline'>
<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span><sub>0</sub> + &#X454;<sup>&#X2192;</sup>)</span>
by change <span class='latexinline'>
<span style="font-style:italic">g</span>(<span style="font-style:italic">x</span><sub>0</sub> + &#X454;<sup>&#X2192;</sup>)</span>, and thereby violate the constraint
<span class='latexinline'>
<span style="font-style:italic">g</span>(<span style="font-style:italic">x</span><sub>0</sub> + ) = <span style="font-style:italic">c</span></span>.
<h3><a id=efficient-tree-transformations-on-gpus href='#efficient-tree-transformations-on-gpus'> § </a> <a href=#efficient-tree-transformations-on-gpus>
Efficient tree transformations on GPUs</a>
</h3>
All material lifted straight from <a href=https://scholarworks.iu.edu/dspace/handle/2022/24749>
Aaron Hsu's PhD thesis</a>
. I'll be converting
APL notation to C++-like notation.
<h4><a id=tree-repsentation-as-multi-dimensional-ragged-nested-arrays href='#tree-repsentation-as-multi-dimensional-ragged-nested-arrays'> § </a> Tree repsentation as multi-dimensional ragged nested arrays</h4>
We're interested in this tree:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font>       ∘
<font color="#000000">3:</font> ┌──┬──┴────┐
<font color="#000000">4:</font> a  b       c
<font color="#000000">5:</font> │ ┌┴┐  ┌───┼───┐
<font color="#000000">6:</font> p q r  s   t   u
<font color="#000000">7:</font>   │    │   |
<font color="#000000">8:</font>   │   ┌┴┐ ┌┴┐
<font color="#000000">9:</font>   v   w x y z
<font color="#000000">10:</font> </tt></pre>
</div>

I'll be writing APL commands in front of a <code>$</code> to mimic bash, and I'll
write some arrays as multi-line. To run them, collapse them into a single
line. The <code>ast</code> object is represented in memory as:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> $ ast ← ('∘'
<font color="#000000">03:</font>            ('a' ('p'))
<font color="#000000">04:</font>            ('b'
<font color="#000000">05:</font>              ('q' ('v'))
<font color="#000000">06:</font>              ('r'))
<font color="#000000">07:</font>            ('c'
<font color="#000000">08:</font>              ('s' ('w' 'x'))
<font color="#000000">09:</font>              ('t' ('y' 'z'))
<font color="#000000">10:</font>              ('u')))
<font color="#000000">11:</font> $ ]disp ast
<font color="#000000">12:</font> ┌→┬──┬────────┬───────────────────┐
<font color="#000000">13:</font> │∘│ap│┌→┬──┬─┐│┌→┬──────┬──────┬─┐│
<font color="#000000">14:</font> │ │  ││b│qv│r│││c│┌→┬──┐│┌→┬──┐│u││
<font color="#000000">15:</font> │ │  │└─┴─→┴─┘││ ││s│wx│││t│yz││ ││
<font color="#000000">16:</font> │ │  │        ││ │└─┴─→┘│└─┴─→┘│ ││
<font color="#000000">17:</font> │ │  │        │└─┴─────→┴─────→┴─┘│
<font color="#000000">18:</font> └─┴─→┴───────→┴──────────────────→┘
<font color="#000000">19:</font> </tt></pre>
</div>

Here's how read the array representation. Look at the top level of the tree.
we have a root node with three children:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font>       ∘
<font color="#000000">03:</font> ┌──┬──┴────┐
<font color="#000000">04:</font> a  b       c
<font color="#000000">05:</font> 
<font color="#000000">06:</font> ┌→┬──┬────────┬─────────────┐
<font color="#000000">07:</font> │∘│  │        │             │
<font color="#000000">08:</font> │ │ a│   b    │     c       │
<font color="#000000">09:</font> │ │  │        │             │
<font color="#000000">10:</font> └─┴─→┴───────→┴────────────→┘
<font color="#000000">11:</font> </tt></pre>
</div>

With the first <code>∘</code> being the root node, and the three adjacent cells
being the children.
Next, we look at how <code>x</code> is represented. This is predictably recursive. Let's
see the subtree under <code>x</code>:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font>       ∘
<font color="#000000">03:</font> ┌──┬──┴────┐
<font color="#000000">04:</font> a  b       c
<font color="#000000">05:</font> │
<font color="#000000">06:</font> p
<font color="#000000">07:</font> 
<font color="#000000">08:</font> ┌→┬──┬────────┬─────────────┐
<font color="#000000">09:</font> │∘│ap│        │             │
<font color="#000000">10:</font> │ │  │  b     │   c         │
<font color="#000000">11:</font> │ │  │        │             │
<font color="#000000">12:</font> └─┴─→┴───────→┴────────────→┘
<font color="#000000">13:</font> 
<font color="#000000">14:</font> </tt></pre>
</div>

Similarly for <code>y</code>:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font>       ∘
<font color="#000000">03:</font> ┌──┬──┴────┐
<font color="#000000">04:</font> a  b       c
<font color="#000000">05:</font> │ ┌┴┐
<font color="#000000">06:</font> p q r
<font color="#000000">07:</font> 
<font color="#000000">08:</font> ┌→┬──┬────────┬─────────────┐
<font color="#000000">09:</font> │∘│ap│┌→┬──┬─┐│             │
<font color="#000000">10:</font> │ │  ││b│q │r││   c         │
<font color="#000000">11:</font> │ │  │└─┴─→┴─┘│             │
<font color="#000000">12:</font> └─┴─→┴───────→┴────────────→┘
<font color="#000000">13:</font> </tt></pre>
</div>

And so on, leading to the final representation:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font>       ∘
<font color="#000000">03:</font> ┌──┬──┴────┐
<font color="#000000">04:</font> a  b       c
<font color="#000000">05:</font> │ ┌┴┐  ┌───┼───┐
<font color="#000000">06:</font> p q r  s   t   u
<font color="#000000">07:</font>   │    │   |
<font color="#000000">08:</font>   │   ┌┴┐ ┌┴┐
<font color="#000000">09:</font>   v   w x y z
<font color="#000000">10:</font> ┌→┬──┬────────┬───────────────────┐
<font color="#000000">11:</font> │∘│ap│┌→┬──┬─┐│┌→┬──────┬──────┬─┐│
<font color="#000000">12:</font> │ │  ││b│qv│r│││c│┌→┬──┐│┌→┬──┐│u││
<font color="#000000">13:</font> │ │  │└─┴─→┴─┘││ ││s│wx│││t│yz││ ││
<font color="#000000">14:</font> │ │  │        ││ │└─┴─→┘│└─┴─→┘│ ││
<font color="#000000">15:</font> │ │  │        │└─┴─────→┴─────→┴─┘│
<font color="#000000">16:</font> └─┴─→┴───────→┴──────────────────→┘
<font color="#000000">17:</font> </tt></pre>
</div>

Note that for this representation to work, we need to be able to:
<ul>
<li>
 nest arrays inside arrays.
</li>
<li>
 have subarrays of different sizes (ragged arrays)
</li>
<li>
 of different <i>nesting depths</i> --- so it's really not even an array?
</li>

</ul>

I don't understand the memory layout of this, to be honest. I feel like to
represent this in memory would still rely on pointer-chasing, since we need
to box all the arrays. This is possibly optimised by APL to not be too bad.
<h4><a id=the-depth-vector-representation href='#the-depth-vector-representation'> § </a> The depth vector representation</h4>
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font>       ∘             0
<font color="#000000">3:</font> ┌──┬──┴────┐
<font color="#000000">4:</font> a  b       c        1
<font color="#000000">5:</font> │ ┌┴┐  ┌───┼───┐
<font color="#000000">6:</font> p q r  s   t   u    2
<font color="#000000">7:</font>   │    │   |
<font color="#000000">8:</font>   │   ┌┴┐ ┌┴┐
<font color="#000000">9:</font>   v   w x y z       3
<font color="#000000">10:</font> </tt></pre>
</div>

If we visit this tree and record depths in pre-order <code>(node left right)</code>, we
arrive at the list:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> (∘:0
<font color="#000000">3:</font>   (a:1 (p:2)) (b:1 (q:2 (v:3)) (r:2))
<font color="#000000">4:</font>   (c:1 (s:2 (w:3 x:3)) (t:2 (y:3 z:3)) (u:2)))
<font color="#000000">5:</font> </tt></pre>
</div>

formatted as:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> (∘:0
<font color="#000000">03:</font>   (a:1
<font color="#000000">04:</font>     (p:2))
<font color="#000000">05:</font>   (b:1
<font color="#000000">06:</font>     (q:2 (v:3))
<font color="#000000">07:</font>     (r:2)
<font color="#000000">08:</font>   )
<font color="#000000">09:</font>   (c:1 (s:2 (w:3 x:3))
<font color="#000000">10:</font>        (t:2 (y:3 z:3))
<font color="#000000">11:</font>        (u:2))
<font color="#000000">12:</font> )
<font color="#000000">13:</font> </tt></pre>
</div>

This linearlized is the list:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font>     (∘ a p b q v r c s w x t y z u)
<font color="#000000">03:</font> d ← (0 1 2 1 2 3 2 1 2 3 3 2 3 3 2)
<font color="#000000">04:</font> 
<font color="#000000">05:</font>       ∘             0
<font color="#000000">06:</font> ┌──┬──┴────┐
<font color="#000000">07:</font> a  b       c        1
<font color="#000000">08:</font> │ ┌┴┐  ┌───┼───┐
<font color="#000000">09:</font> p q r  s   t   u    2
<font color="#000000">10:</font>   │    │   |
<font color="#000000">11:</font>   │   ┌┴┐ ┌┴┐
<font color="#000000">12:</font>   v   w x y z       3
<font color="#000000">13:</font> </tt></pre>
</div>

To convert the <code>ast</code> object into a depth vector representation, we can
use the following call:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> $ ast ← ('∘' ('a' ('p')) ('b' ('q' ('v')) ('r')) ('c' ('s' ('w' 'x')) ('t' ('y' 'z')) ('u')))
<font color="#000000">3:</font> $ d ← ∊0{(⊢,(⍺+1)∇⊣)/⌽⍺,1↓⍵}ast
<font color="#000000">4:</font> 0 1 2 1 2 3 2 1 2 3 3 2 3 3 2
<font color="#000000">5:</font> </tt></pre>
</div>

Let's break this down:
TODO
<h4><a id=inverted-tables href='#inverted-tables'> § </a> Inverted tables</h4>
We represent data associated with our nodes as follows:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> $ data ← ⍪ ¨d(15⍴'T')(↑15⍴⊂'n.')
<font color="#000000">03:</font> $ ]disp data
<font color="#000000">04:</font> ┌→┬─┬──┐
<font color="#000000">05:</font> │0│T│n.│
<font color="#000000">06:</font> │1│T│n.│
<font color="#000000">07:</font> │2│T│n.│
<font color="#000000">08:</font> │1│T│n.│
<font color="#000000">09:</font> │2│T│n.│
<font color="#000000">10:</font> │3│T│n.│
<font color="#000000">11:</font> │2│T│n.│
<font color="#000000">12:</font> │1│T│n.│
<font color="#000000">13:</font> │2│T│n.│
<font color="#000000">14:</font> │3│T│n.│
<font color="#000000">15:</font> │4│T│n.│
<font color="#000000">16:</font> │2│T│n.│
<font color="#000000">17:</font> │3│T│n.│
<font color="#000000">18:</font> │4│T│n.│
<font color="#000000">19:</font> │2↓T↓n.↓
<font color="#000000">20:</font> └→┴→┴─→┘
<font color="#000000">21:</font> </tt></pre>
</div>

This is the same thing as a
<a href=https://en.wikipedia.org/wiki/AoS_and_SoA#Structure_of_Arrays>
structure of arrays (SOA) representation</a>
,
where each array of information (eg, the depth at <code>data[1]</code>, the <code>T</code>
information at <code>data[2]</code>) are each <i>arrays</i> which can be accessed well on SIMD
instructions.
<h4><a id=ast-representation href='#ast-representation'> § </a> AST representation</h4>
TODO
<h4><a id=path-matrices href='#path-matrices'> § </a> Path matrices</h4>
We want information of how to go up and down the tree in ideally constant time.
We store this information in what is known as a <i>path matrix</i>.
For our recurring example, the path matrix is:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> ∘ a p b q v r c s w x t y z u | preorder traversal
<font color="#000000">03:</font> ──────────────────────────────────────────────────
<font color="#000000">04:</font> ∘ ∘ ∘ ∘ ∘ ∘ ∘ ∘ ∘ ∘ ∘ ∘ ∘ ∘ ∘ | depth=0
<font color="#000000">05:</font> - a a b b b b c c c c c c c c | depth=1
<font color="#000000">06:</font> - - p - q q r - s s s t t t u | depth=2
<font color="#000000">07:</font> - - - - - v - - - w x - y z - | depth=3
<font color="#000000">08:</font> 
<font color="#000000">09:</font>       ∘             0
<font color="#000000">10:</font> ┌──┬──┴────┐
<font color="#000000">11:</font> a  b       c        1
<font color="#000000">12:</font> │ ┌┴┐  ┌───┼───┐
<font color="#000000">13:</font> p q r  s   t   u    2
<font color="#000000">14:</font>   │    │   |
<font color="#000000">15:</font>   │   ┌┴┐ ┌┴┐
<font color="#000000">16:</font>   v   w x y z       3
<font color="#000000">17:</font> </tt></pre>
</div>

To efficiently compute this, we first replace every value in
our tree with its preorder traversal visit time. This changes
the tree to:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font>               ∘:0                               0
<font color="#000000">3:</font> ┌──────────┬──┴─────────────────┐
<font color="#000000">4:</font> a:1        b:3                 c:7              1
<font color="#000000">5:</font> │      ┌───┴───┐     ┌──────────┼───────┐
<font color="#000000">6:</font> p:2    q:4     r:6   s:8        t:11    u:14    2
<font color="#000000">7:</font>        │             │          │
<font color="#000000">8:</font>        │          ┌──┴──┐     ┌─┴───┐
<font color="#000000">9:</font>        v:5        w:9   x:10  y:12  z:13        3
<font color="#000000">10:</font> </tt></pre>
</div>

The values we store in the tree are the integers. The old labels
are represented for clarity.
The path matrix for this tree is:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14  | preorder traversal
<font color="#000000">03:</font> ────────────────────────────────────────────────────────────
<font color="#000000">04:</font> 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  | depth=0
<font color="#000000">05:</font> -  1  1  3  3  3  3  7  7  7  7  7  7  7  7  | depth=1
<font color="#000000">06:</font> -  -  2  -  4  4  6  -  8  8  8 11 11 11 14  | depth=2
<font color="#000000">07:</font> -  -  -  -  -  5  -  -  -  9 10  - 12 13  -  | depth=3
<font color="#000000">08:</font> 
<font color="#000000">09:</font>               ∘:0                               0
<font color="#000000">10:</font> ┌──────────┬──┴─────────────────┐
<font color="#000000">11:</font> a:1        b:3                 c:7              1
<font color="#000000">12:</font> │      ┌───┴───┐     ┌──────────┼───────┐
<font color="#000000">13:</font> p:2    q:4     r:6   s:8        t:11    u:14    2
<font color="#000000">14:</font>        │             │          │
<font color="#000000">15:</font>        │          ┌──┴──┐     ┌─┴───┐
<font color="#000000">16:</font>        v:5        w:9   x:10  y:12  z:13        3
<font color="#000000">17:</font> </tt></pre>
</div>

<h4><a id=rendering-the-depth-information-in-2d href='#rendering-the-depth-information-in-2d'> § </a> Rendering the depth information in 2D</h4>
We use the incantation:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> $ d ← (0 1 2 1 2 3 2 1 2 3 3 2 3 3 2)
<font color="#000000">3:</font> $ ((⍳≢d)@(d,¨⍳≢d)) ((⌈/d) (≢d))⍴'-'
<font color="#000000">4:</font> 0 - - - - - - - - -  -  -  -  -  -
<font color="#000000">5:</font> - 1 - 3 - - - 7 - -  -  -  -  -  -
<font color="#000000">6:</font> - - 2 - 4 - 6 - 8 -  - 11  -  - 14
<font color="#000000">7:</font> - - - - - 5 - - - 9  -  - 12  -  -
<font color="#000000">8:</font> - - - - - - - - - - 10  -  - 13  -
<font color="#000000">9:</font> </tt></pre>
</div>

Let's break this down (the symbol <code> </code> means a lamp, for commenting/illumination)
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> $ ⍳ 3 ⍝ iota: make a list of n elements:.
<font color="#000000">3:</font> 1 2 3
<font color="#000000">4:</font> </tt></pre>
</div>

<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> $ d
<font color="#000000">3:</font> 0 1 2 1 2 3 2 1 2 3 4 2 3 4 2
<font color="#000000">4:</font> 
<font color="#000000">5:</font> $ ≢d ⍝ tally: ≢`. count no. of elements in d:
<font color="#000000">6:</font> 15
<font color="#000000">7:</font> </tt></pre>
</div>

<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> ⍳≢d  ⍝ list of elements of len (no. of elements in d).
<font color="#000000">3:</font> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
<font color="#000000">4:</font> </tt></pre>
</div>

<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> $ ]disp (1 2 3),(4 5 6) ⍝ ,:concatenate
<font color="#000000">3:</font> ┌→────┬─────┐
<font color="#000000">4:</font> │1 2 3│4 5 6│
<font color="#000000">5:</font> └~───→┴~───→┘
<font color="#000000">6:</font> </tt></pre>
</div>

<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> ]disp (1 2 3) ,¨ (4 5 6)
<font color="#000000">3:</font> ┌→──┬───┬───┐
<font color="#000000">4:</font> │1 4│2 5│3 6│
<font color="#000000">5:</font> └~─→┴~─→┴~─→┘
<font color="#000000">6:</font> </tt></pre>
</div>

The use of <code>¨</code> needs some explanation. <code>¨</code> is a higher order function which
takes a function and makes it a mapped version of the original function.
So, <code>,¨</code> is a function which attemps to map the concatenation operator.
Now, given two arrays <code>(1 2 3)</code>
and <code>(4 5 6)</code>, <code>(1 2 3) ,¨ 4 5 6</code> attemps to run <code>,</code> on each pair
<code>1 and 4</code>, <code>2 and 5</code>, <code>3 and 6</code>. This gives us tuples <code>((1 4) (2 5) (3 6))</code>.
So, for our purposes, <code>zip ← ,¨</code>.
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> ]disp (d,¨⍳≢d) ⍝ zip d with [1..len d].
<font color="#000000">3:</font> ┌→──┬───┬───┬───┬───┬───┬───┬───┬───┬───┬────┬────┬────┬────┬────┐
<font color="#000000">4:</font> │0 0│1 1│2 2│1 3│2 4│3 5│2 6│1 7│2 8│3 9│4 10│2 11│3 12│4 13│2 14│
<font color="#000000">5:</font> └~─→┴~─→┴~─→┴~─→┴~─→┴~─→┴~─→┴~─→┴~─→┴~─→┴~──→┴~──→┴~──→┴~──→┴~──→┘
<font color="#000000">6:</font> </tt></pre>
</div>

<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> $ ((⌈/d) (≢d))⍴'-' ⍝ array of dim (max val in d) x (no. of elem in d)
<font color="#000000">3:</font> ---------------
<font color="#000000">4:</font> ---------------
<font color="#000000">5:</font> ---------------
<font color="#000000">6:</font> ---------------
<font color="#000000">7:</font> </tt></pre>
</div>

<ul>
<li>
 <code>⌈</code> is the maximum operator and <code>/</code> is the fold operator, so
  <code>⌈/d</code> finds the maximum in <code>d</code>. Recall that <code>(≢d)</code> find the no. of
   elements in <code>d</code>. <code>⍴</code> reshapes an array to the desired size. We pass it
   a <code>1x1</code> array containing only <code>-</code>, which gets reshaped into a
   <code>(⌈/d) x (≢d)</code> sizes array of <code>-</code> symbols.
</li>

</ul>

TODO: explain @ and its use
<h4><a id=creating-the-path-matrix href='#creating-the-path-matrix'> § </a> Creating the path matrix</h4>
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> $ ⎕IO ← 0 ⍝ (inform APL that we wish to use 0-indexing.)
<font color="#000000">03:</font> $ d ← (0 1 2 1 2 3 2 1 2 3 3 2 3 3 2)
<font color="#000000">04:</font> $ PM ← ⌈\((⍳≢d)@(d,¨⍳≢d))(((⌈/d+1)(≢d))⍴0)
<font color="#000000">05:</font> 
<font color="#000000">06:</font> 0 0 0 0 0 0 0 0 0 0  0  0  0  0  0
<font color="#000000">07:</font> 0 1 1 3 3 3 3 7 7 7  7  7  7  7  7
<font color="#000000">08:</font> 0 0 2 2 4 4 6 6 8 8  8 11 11 11 14
<font color="#000000">09:</font> 0 0 0 0 0 5 5 5 5 9 10 10 12 13 13
<font color="#000000">10:</font> 
<font color="#000000">11:</font>       0               0
<font color="#000000">12:</font> ┌──┬──┴───────┐
<font color="#000000">13:</font> 1  3          7       1
<font color="#000000">14:</font> │ ┌┴┐  ┌──────┼───┐
<font color="#000000">15:</font> 2 4 6  8     11   14  2
<font color="#000000">16:</font>   │    │      |
<font color="#000000">17:</font>   │   ┌┴─┐   ┌┴──┐
<font color="#000000">18:</font>   5   9  10  12  13   3
<font color="#000000">19:</font> </tt></pre>
</div>

The incantation can be broken down into:
<ul>
<li>
 <code>(((⌈/d+1)(≢d))⍴0)</code> is used to create a <code>max(d+1)x|d|</code> dimension array of zeros.
   Here, the rows define depths, and the columns correspond to tree nodes
   which for us are their preorder indexes.
</li>

</ul>

<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> $ grid←(⌈/d+1) (≢d) ⍴ 0
<font color="#000000">3:</font> $ grid
<font color="#000000">4:</font> 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
<font color="#000000">5:</font> 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
<font color="#000000">6:</font> 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
<font color="#000000">7:</font> 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
<font color="#000000">8:</font> </tt></pre>
</div>

<ul>
<li>
 <code>((d ,¨ ⍳≢d))</code> creates an array of pairs <code>(depth, preindex)</code>. We will use
  this to fill index <code>(d, pi)</code> with the value <code>pi</code>.
</li>

</ul>

<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> $ writeixs ← (d,¨⍳≢d)
<font color="#000000">3:</font> $ ]disp writeixs
<font color="#000000">4:</font> ┌→──┬───┬───┬───┬───┬───┬───┬───┬───┬───┬────┬────┬────┬────┬────┐
<font color="#000000">5:</font> │0 0│1 1│2 2│1 3│2 4│3 5│2 6│1 7│2 8│3 9│3 10│2 11│3 12│3 13│2 14│
<font color="#000000">6:</font> └~─→┴~─→┴~─→┴~─→┴~─→┴~─→┴~─→┴~─→┴~─→┴~─→┴~──→┴~──→┴~──→┴~──→┴~──→┘
<font color="#000000">7:</font> </tt></pre>
</div>

<ul>
<li>
 <code>ixgrid ← ((⍳≢d)@writeixs) grid</code> rewrites at index <code>writeixs[i]</code> the value (<code>(i≢d)[i]</code>).
</li>

</ul>

<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> $ ixgrid ← ((⍳≢d)@writeixs) grid
<font color="#000000">3:</font> $ ixgrid
<font color="#000000">4:</font> 0 0 0 0 0 0 0 0 0 0  0  0  0  0  0
<font color="#000000">5:</font> 0 1 0 3 0 0 0 7 0 0  0  0  0  0  0
<font color="#000000">6:</font> 0 0 2 0 4 0 6 0 8 0  0 11  0  0 14
<font color="#000000">7:</font> 0 0 0 0 0 5 0 0 0 9 10  0 12 13  0
<font color="#000000">8:</font> </tt></pre>
</div>

<ul>
<li>
 Finally, <code>⌈</code> is the maximum operator, and <code>\</code> is the <a href=>
prefix scan</a>
 operator,
  so <code>⌈\ixgrid</code> creates a prefix scan of the above grid to give us our
  final path matrix:
</li>

</ul>

<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> $ PM ← ⌈\ixgrid
<font color="#000000">3:</font> $ PM
<font color="#000000">4:</font> 0 0 0 0 0 0 0 0 0 0  0  0  0  0  0
<font color="#000000">5:</font> 0 1 1 3 3 3 3 7 7 7  7  7  7  7  7
<font color="#000000">6:</font> 0 0 2 2 4 4 6 6 8 8  8 11 11 11 14
<font color="#000000">7:</font> 0 0 0 0 0 5 5 5 5 9 10 10 12 13 13
<font color="#000000">8:</font> </tt></pre>
</div>

<h4><a id=using-the-path-matrix-distance-of-a-node-from-every-other-node href='#using-the-path-matrix-distance-of-a-node-from-every-other-node'> § </a> Using the path matrix:  distance of a node from every other node.</h4>
Note that the maximum distance between two nodes is to climb
all the way to the top node, and then climb down:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> dmax ← depth(a) + depth(b)
<font color="#000000">3:</font> </tt></pre>
</div>

If we know the lowest common ancestor of two nodes,
then the distance of one node to another is:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> dcorrect ← dist(a, lca(a, b)) + dist(b, lca(a, b))
<font color="#000000">3:</font> </tt></pre>
</div>

So, we can compute the depth as:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> dcorrect ← dist(a, lca(a, b)) + dist(lca(a, b), b)
<font color="#000000">3:</font>  = dist(a, lca(a, b)) + depth(lca(a, b)) +
<font color="#000000">4:</font>    dist(b, lca(a, b)) + depth(lca(a, b)) +
<font color="#000000">5:</font>    -2 * depth(lca(a, b))
<font color="#000000">6:</font>  = depth(a) +
<font color="#000000">7:</font>    depth(b) +
<font color="#000000">8:</font>    -2 * depth (lca(a, b))
<font color="#000000">9:</font> </tt></pre>
</div>

[TODO: picture]
[TODO: finish writing this]
<h4><a id=parent-vector-representation href='#parent-vector-representation'> § </a> Parent vector representation</h4>
A parent vector is a vector of length <code>n</code> where <code>Parent[i]</code> denotes an
index into <code>Parent</code>. Hence, the following condition will return 1
if V is a parent vector.
For example, for our given example, here is the parent vector:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> d ← (0  1  2  1  2  3  2  1  2  3  3  2  3  3  2) │ depths
<font color="#000000">03:</font>     (∘  a  p  b  q  v  r  c  s  w  x  t  y  z  u) │ values
<font color="#000000">04:</font> p ← (∘  ∘  a  ∘  b  q  b  ∘  c  s  s  c  t  t  c) │ parents
<font color="#000000">05:</font>     (0  1  2  3  4  5  6  7  8  9 10 11 12 13 14) | indexes
<font color="#000000">06:</font> P ← (0  0  1  0  3  4  3  0  7  8  8  7 11 11  7) │ parent indices
<font color="#000000">07:</font> 
<font color="#000000">08:</font> 
<font color="#000000">09:</font> 
<font color="#000000">10:</font>               ∘:0                               0
<font color="#000000">11:</font> ┌──────────┬──┴─────────────────┐
<font color="#000000">12:</font> a:1        b:3                 c:7              1
<font color="#000000">13:</font> │      ┌───┴───┐     ┌──────────┼───────┐
<font color="#000000">14:</font> p:2    q:4     r:6   s:8        t:11    u:14    2
<font color="#000000">15:</font>        │             │          │
<font color="#000000">16:</font>        │          ┌──┴──┐     ┌─┴───┐
<font color="#000000">17:</font>        v:5        w:9   x:10  y:12  z:13        3
<font color="#000000">18:</font> </tt></pre>
</div>

The condition a parent vector must satisfy is:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> ∧/V ∊(⍳≢V) ⍝ [All elements of V belong in the list [1..len(V)] ]
<font color="#000000">3:</font> </tt></pre>
</div>

<ul>
<li>
 <code>V ∊ (⍳≢V)</code> will be a list of whether each element in v belongs (<code>∊</code>) to the list
  <code>(⍳≢V) = [1..len(V)]</code>
</li>
<li>
 Recall that <code>/</code> is for reduction, and <code>∧/</code> is a boolean <code>AND</code> reduction.
  Hence, we compute whether each element of the vector <code>V</code> is in the range <code>[1..len(V)]</code>.
</li>
<li>
 We add the constraint that root notes that don't have a parent simply
  point to themselves. This allows us to free ourselves from requiring
  some kind of <code>nullptr</code> check.
</li>

</ul>

The root node (parent of all elements) can be found using the fixpoint operator (<code>⍨</code>):
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> I←{(⊂⍵)⌷⍺} ⍝ index into the left hand side param using right hand side param
<font color="#000000">3:</font> I⍣≡⍨p ⍝ compute the fixpoint of the I operator using ⍨ and apply it to p
<font color="#000000">4:</font> </tt></pre>
</div>

<h4><a id=converting-from-depth-vector-to-parent-vector-take-1 href='#converting-from-depth-vector-to-parent-vector-take-1'> § </a> Converting from depth vector to parent vector, Take 1</h4>
As usual, let's consider our example:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> d ← (0  1  2  1  2  3  2  1  2  3  3  2  3  3  2) │ depths
<font color="#000000">03:</font>     (∘  a  p  b  q  v  r  c  s  w  x  t  y  z  u) │ values
<font color="#000000">04:</font> p ← (∘  ∘  a  ∘  b  q  b  ∘  c  s  s  c  t  t  c) │ parents
<font color="#000000">05:</font>     (0  1  2  3  4  5  6  7  8  9 10 11 12 13 14) | indexes
<font color="#000000">06:</font> P ← (0  0  1  0  3  4  3  0  7  8  8  7 11 11  7) │ parent indices
<font color="#000000">07:</font> 
<font color="#000000">08:</font> 
<font color="#000000">09:</font> 
<font color="#000000">10:</font>               ∘:0                               0
<font color="#000000">11:</font> ┌──────────┬──┴─────────────────┐
<font color="#000000">12:</font> a:1        b:3                 c:7              1
<font color="#000000">13:</font> │      ┌───┴───┐     ┌──────────┼───────┐
<font color="#000000">14:</font> p:2    q:4     r:6   s:8        t:11    u:14    2
<font color="#000000">15:</font>        │             │          │
<font color="#000000">16:</font>        │          ┌──┴──┐     ┌─┴───┐
<font color="#000000">17:</font>        v:5        w:9   x:10  y:12  z:13        3
<font color="#000000">18:</font> </tt></pre>
</div>

Note that the depth vector already encodes parent-child information.
<ul>
<li>
 The parent of node <code>i</code> is a node <code>j</code> such that <code>d[j] = d[i] - 1</code> and
  <code>j</code> is the closest index to the left of <code>i</code> such that this happens.
</li>

</ul>

For example, to compute the parent of <code>t:11</code>, notice that it's at depth <code>2</code>.
So we should find all the nodes from <code>d[0..11]</code> which have depths equal to
<code>2</code>, and then pick the rightmost one. This translates to the expression:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> $ d ← (0  1  2  1  2  3  2  1  2  3  3  2  3  3  2)
<font color="#000000">03:</font> $ t ← 11   ⍝ target node
<font color="#000000">04:</font> $ ixs ← ⍳t   ⍝ array indexes upto this node
<font color="#000000">05:</font>   0 1 2 3 4 5 6 7 8 9 10
<font color="#000000">06:</font> $ d[ixs]   ⍝ depths of nodes to the left of the given node t
<font color="#000000">07:</font>   0 1 2 1 2 3 2 1 2 3 3
<font color="#000000">08:</font> $ d[ixs]  = d[t]-1  ⍝ boolean vector of nodes whose depth is that of t's parent
<font color="#000000">09:</font>   0 1 0 1 0 0 0 1 0 0 0
<font color="#000000">10:</font> $ eqds ← ⍸ (d[ixs] = d[t]-1)  ⍝ array indexes of nodes whose depth is that of t's parent
<font color="#000000">11:</font>   1 3 7
<font color="#000000">12:</font> $ ⌽ eqds ⍝ reverse of array indexes to extract `7`
<font color="#000000">13:</font>   7 3 1
<font color="#000000">14:</font> $ ⊃ ⌽ eqds ⍝ first of the reverse of the array indexes to extract `7`
<font color="#000000">15:</font>   7
<font color="#000000">16:</font> $ (⌽⍸(d[⍳t] = d[t]-1))[0]  ⍝ APL style one-liner of the above
<font color="#000000">17:</font> </tt></pre>
</div>

While this is intuitive, this does not scale: It does not permit us to find
the parent of all the nodes <i>at once</i> --- ie, it is not parallelisable
over choices of <code>t</code>.
<h4><a id=converting-from-depth-vector-to-parent-vector-take-2-or-scan-idiom href='#converting-from-depth-vector-to-parent-vector-take-2-or-scan-idiom'> § </a> Converting from depth vector to parent vector, Take 2 (Or scan idiom)</h4>
Imagine we have a list of <code>0</code>s and <code>1</code>s, and we want to find the <i>index</i> of
the rightmost <code>1</code> value. For example, given:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font>        0 1 2 3 4 5 6 7 8 9 10 11 12
<font color="#000000">3:</font> $ a ← (0 0 1 0 0 0 1 0 1 0  0  0  0)
<font color="#000000">4:</font> </tt></pre>
</div>

we want the answer to be <code>f a = 8</code>. We saw an implementation in terms of
<code>f←{(⌽⍸⍵)[0]}</code> in Take 1.
(recall that <code>⍵</code> is the symbol for the right-hand-side argument of a function).
We're going to perform the same operation slightly differently. Let's consider
the series of transformations:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> ⍝      0 1 2 3 4 5 6 7 8 9 10 11 12
<font color="#000000">03:</font> $ a ← (0 0 1 0 0 0 1 0 1 0  0  0  0) ⍝ original array
<font color="#000000">04:</font> 
<font color="#000000">05:</font> $ ⌽a  ⍝ reverse of a
<font color="#000000">06:</font>   0 0 0 0 1 0 1 0 0 0 1 0 0
<font color="#000000">07:</font> 
<font color="#000000">08:</font> $ ∨\ ⌽a ⍝ prefix scan(\) using the OR(∨) operator. Turn all
<font color="#000000">09:</font>         ⍝ entries after the first 1 into a 1
<font color="#000000">10:</font>   0 0 0 0 1 1 1 1 1 1 1 1 1
<font color="#000000">11:</font> 
<font color="#000000">12:</font> $ +/ (∨\ ⌽a)  ⍝ sum over the previous list, counting number of 1s
<font color="#000000">13:</font>   9
<font color="#000000">14:</font> 
<font color="#000000">15:</font> $ ¯1 +  (+/ (∨\ ⌽a))  ⍝ subtract 1 from the previous number
<font color="#000000">16:</font>   8
<font color="#000000">17:</font> </tt></pre>
</div>

Why the hell does this work? Well, here's the proof:
<ul>
<li>
 On running <code>⌽a</code>, we reverse the <code>a</code>. The last 1 of <code>a</code> at index <span class='latexinline'>
<span style="font-style:italic">i</span></span>
  becomes the first <span class='latexinline'>
1</span> of <code>⌽a</code> at index <span class='latexinline'>
<span style="font-style:italic">i</span>&#X2032; &#X2261; <span style="font-style:italic">n</span>&#X2212;<span style="font-style:italic">i</span></span>.
</li>
<li>
 On running  <code>∨\ ⌽a</code>, numbers including and after the first 1
  become <code>1</code>. That is, all indexes <span class='latexinline'>
<span style="font-style:italic">j</span> &#X2265; <span style="font-style:italic">i</span>&#X2032;</span> have 1 in them.
</li>
<li>
 On running <code>+/ (∨\ ⌽a)</code>, we sum up all 1s. This will give us <span class='latexinline'>
<span style="font-style:italic">n</span>&#X2212;<span style="font-style:italic">i</span>&#X2032;+1</span> 1s.
  That is, <span class='latexinline'>
<span style="font-style:italic">n</span>&#X2212;<span style="font-style:italic">i</span>&#X2032;+1 = <span style="font-style:italic">n</span>&#X2212;(<span style="font-style:italic">n</span>&#X2212;<span style="font-style:italic">i</span>)+1 =<span style="font-style:italic">i</span>+1</span>.
</li>
<li>
 We subtract a <span class='latexinline'>
1</span> to correctly find the <span class='latexinline'>
<span style="font-style:italic">i</span></span> from <span class='latexinline'>
<span style="font-style:italic">i</span>+1</span>.
</li>

</ul>

This technique will work for <b>every row of a matrix</b>. This is paramount,
since we can now repeat this for the depth vector we were previously
interested in for each row, and thereby compute the parent index!
<h4><a id=converting-from-depth-vector-to-parent-vector-take-3-full-matrix href='#converting-from-depth-vector-to-parent-vector-take-3-full-matrix'> § </a> Converting from depth vector to parent vector, Take 3 (full matrix)</h4>
We want to extend the previous method we hit upon to compute the parents
of all nodes in parallel. To perform this, we need to run the moral
equivalent of the following:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> $ ⎕IO ← 0 ⍝ 0 indexing
<font color="#000000">3:</font> $ d ← (0  1  2  1  2  3  2  1  2  3  3  2  3  3  2) ⍝ depth vector
<font color="#000000">4:</font> $ t ← 11 ⍝ node we are interested in
<font color="#000000">5:</font> $ a←d[⍳t]=d[t]-1  ⍝ boolean vector of nodes whose depth is that of t's parent
<font color="#000000">6:</font>   0 1 0 1 0 0 0 1 0 0 0
<font color="#000000">7:</font> $ ¯1 +  (+/ (∨\ ⌽a)) ⍝ index of last 0 of boolean vector
<font color="#000000">8:</font> 7
<font color="#000000">9:</font> </tt></pre>
</div>

for <i>every single choice of t</i>. To perform this, we can build a 2D matrix
of <code>d[⍳t]=d[t]-1</code> where <code>t</code> ranges over <code>[0..len(d)-1]</code> (ie, it ranges
over all the nodes in the graph).
We begin by using:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> $ ⎕IO ← 0 ⋄ d ← (0  1  2  1  2  3  2  1  2  3  3  2  3  3  2) ⍝ depths
<font color="#000000">03:</font> $ ]display ltdepth ← d ∘.&gt; d ⍝ find `d[i] &gt; d[j]` for all i, j.
<font color="#000000">04:</font> ┌→────────────────────────────┐
<font color="#000000">05:</font> ↓0 0 0 0 0 0 0 0 0 0 0 0 0 0 0│
<font color="#000000">06:</font> │1 0 0 0 0 0 0 0 0 0 0 0 0 0 0│
<font color="#000000">07:</font> │1 1 0 1 0 0 0 1 0 0 0 0 0 0 0│
<font color="#000000">08:</font> │1 0 0 0 0 0 0 0 0 0 0 0 0 0 0│
<font color="#000000">09:</font> │1 1 0 1 0 0 0 1 0 0 0 0 0 0 0│
<font color="#000000">10:</font> │1 1 1 1 1 0 1 1 1 0 0 1 0 0 1│
<font color="#000000">11:</font> │1 1 0 1 0 0 0 1 0 0 0 0 0 0 0│
<font color="#000000">12:</font> │1 0 0 0 0 0 0 0 0 0 0 0 0 0 0│
<font color="#000000">13:</font> │1 1 0 1 0 0 0 1 0 0 0 0 0 0 0│
<font color="#000000">14:</font> │1 1 1 1 1 0 1 1 1 0 0 1 0 0 1│
<font color="#000000">15:</font> │1 1 1 1 1 0 1 1 1 0 0 1 0 0 1│
<font color="#000000">16:</font> │1 1 0 1 0 0 0 1 0 0 0 0 0 0 0│
<font color="#000000">17:</font> │1 1 1 1 1 0 1 1 1 0 0 1 0 0 1│
<font color="#000000">18:</font> │1 1 1 1 1 0 1 1 1 0 0 1 0 0 1│
<font color="#000000">19:</font> │1 1 0 1 0 0 0 1 0 0 0 0 0 0 0│
<font color="#000000">20:</font> └~────────────────────────────┘
<font color="#000000">21:</font> </tt></pre>
</div>

<ul>
<li>
 Note that <code>gt[i][j] = 1</code> iff <code>d[j] < d[i]</code>. So, for a given row (<code>i = fixed</code>), the <code>1s</code>
  nodes that are at lower depth (ie, potential parents).
</li>

</ul>

<ul>
<li>
 If we mask this to only have those indeces where <code>j <= i</code>, then the
  last one in each row will be such that <code>d[last 1] = d[i] - 1</code>. Why? Because
  the node that is closest to us with a depth less than us <i>must</i> be our parent,
  in the preorder traversal.
</li>

</ul>

<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> $ ⎕IO ← 0 ⋄ d ← (0  1  2  1  2  3  2  1  2  3  3  2  3  3  2) ⍝ depths
<font color="#000000">3:</font> $ ]display left ←  (⍳3) ∘.&gt; (⍳3) ⍝ find `i &gt; j` for all i, j.
<font color="#000000">4:</font> ┌→────┐
<font color="#000000">5:</font> ↓0 0 0│
<font color="#000000">6:</font> │1 0 0│
<font color="#000000">7:</font> │1 1 0│
<font color="#000000">8:</font> └~────┘
<font color="#000000">9:</font> </tt></pre>
</div>

Combining the three techniques, we can arrive at:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> $ ⎕IO ← 0 ⋄ d ← (0  1  2  1  2  3  2  1  2  3  3  2  3  3  2) ⍝ depths
<font color="#000000">3:</font> $ ltdepth ← d ∘.&gt; d ⍝ find `d[i] &gt; d[j]` for all i, j.
<font color="#000000">4:</font> $ preds ←  (⍳≢d) ∘.&gt; (⍳≢d) ⍝ predecessors: find `i &gt; j` for all i, j.
<font color="#000000">5:</font> $ pred_higher ←  ltdepth ∧ left   ⍝ predecessors tht are higher in the tree
<font color="#000000">6:</font> $  parents_take_3 ← ¯1 +  +/∨\⌽pred_higher  ⍝ previous idiom for finding last 1.
<font color="#000000">7:</font> ¯1 0 1 0 3 4 3 0 7 8 8 7 11 11 7
<font color="#000000">8:</font> </tt></pre>
</div>

For comparison, the actual value is:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font>     (0   1  2  3  4  5  6  7  8  9 10 11 12 13 14)  | indexes
<font color="#000000">03:</font> d ← (0   1  2  1  2  3  2  1  2  3  3  2  3  3  2)  │ depths
<font color="#000000">04:</font> P ← (0   0  1  0  3  4  3  0  7  8  8  7 11 11  7)  │ parent indices
<font color="#000000">05:</font>     (¯1  0  1  0  3  4  3  0  7  8  8  7 11 11  7) | parents, take 3
<font color="#000000">06:</font> 
<font color="#000000">07:</font>               ∘:0                               0
<font color="#000000">08:</font> ┌──────────┬──┴─────────────────┐
<font color="#000000">09:</font> a:1        b:3                 c:7              1
<font color="#000000">10:</font> │      ┌───┴───┐     ┌──────────┼───────┐
<font color="#000000">11:</font> p:2    q:4     r:6   s:8        t:11    u:14    2
<font color="#000000">12:</font>        │             │          │
<font color="#000000">13:</font>        │          ┌──┴──┐     ┌─┴───┐
<font color="#000000">14:</font>        v:5        w:9   x:10  y:12  z:13        3
<font color="#000000">15:</font> </tt></pre>
</div>

We have an off-by-one error for the <code>0</code> node! That's easily fixed, we simply
perform a maximum with <code>0</code> to move <code>¯1 -> 0</code>:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> $  parents_take_3 ← 0⌈  ¯1 +  +/∨\⌽pred_higher
<font color="#000000">3:</font> 0 0 1 0 3 4 3 0 7 8 8 7 11 11 7
<font color="#000000">4:</font> </tt></pre>
</div>

So, that's our function:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> parents_take_3 ← 0⌈  ¯1 +  +/∨\⌽ ((d∘.&gt;d) ∧ (⍳≢d)∘.&gt;(⍳≢d))
<font color="#000000">3:</font> 0 0 1 0 3 4 3 0 7 8 8 7 11 11 7
<font color="#000000">4:</font> </tt></pre>
</div>

Note that the time complexity for this is dominated by having to calculate
the outer products, which even given infinite parallelism, take <span class='latexinline'>
<span style="font-style:italic">O</span>(<span style="font-style:italic">n</span>)</span> time.
We will slowly chip away at this, to be far better.
<h4><a id=converting-from-depth-vector-to-parent-vector-take-4-log-critial-depth href='#converting-from-depth-vector-to-parent-vector-take-4-log-critial-depth'> § </a> Converting from depth vector to parent vector, Take 4 (log critial depth)</h4>
We will use the Key(<code>⌸</code>) operator which allows us to create key value pairs.
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> $ d ← 0 1 2 1 2 3 2 1 2 3 3 2 3 3 2
<font color="#000000">3:</font> $ ]disp (⍳≢d) ,¨ d ⍝ zip d with indexes
<font color="#000000">4:</font> ┌→──┬───┬───┬───┬───┬───┬───┬───┬───┬───┬────┬────┬────┬────┬────┐
<font color="#000000">5:</font> │0 0│1 1│2 2│3 1│4 2│5 3│6 2│7 1│8 2│9 3│10 3│11 2│12 3│13 3│14 2│
<font color="#000000">6:</font> └~─→┴~─→┴~─→┴~─→┴~─→┴~─→┴~─→┴~─→┴~─→┴~─→┴~──→┴~──→┴~──→┴~──→┴~──→┘
<font color="#000000">7:</font> </tt></pre>
</div>

<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> $ d ← 0 1 2 1 2 3 2 1 2 3 3 2 3 3 2
<font color="#000000">03:</font> $ ]display b ← {⍺ ⍵}⌸d  ⍝ each row i has tuple (i, js): d[js] = i
<font color="#000000">04:</font> ┌→──────────────────┐
<font color="#000000">05:</font> ↓   ┌→┐             │
<font color="#000000">06:</font> │ 0 │0│             │
<font color="#000000">07:</font> │   └~┘             │
<font color="#000000">08:</font> │   ┌→────┐         │
<font color="#000000">09:</font> │ 1 │1 3 7│         │
<font color="#000000">10:</font> │   └~────┘         │
<font color="#000000">11:</font> │   ┌→────────────┐ │
<font color="#000000">12:</font> │ 2 │2 4 6 8 11 14│ │
<font color="#000000">13:</font> │   └~────────────┘ │
<font color="#000000">14:</font> │   ┌→───────────┐  │
<font color="#000000">15:</font> │ 3 │5 9 10 12 13│  │
<font color="#000000">16:</font> │   └~───────────┘  │
<font color="#000000">17:</font> └∊──────────────────┘
<font color="#000000">18:</font> </tt></pre>
</div>

In fact, it allows us to apply an arbitrary function to combine keys and values.
We will use a function that simply returns all the values for each key.
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> $ d ← 0 1 2 1 2 3 2 1 2 3 3 2 3 3 2
<font color="#000000">3:</font> $ ]display b ← {⍵}⌸d ⍝ each row i contains values j such that d[j] = i.
<font color="#000000">4:</font> ┌→──────────────┐
<font color="#000000">5:</font> ↓0 0  0  0  0  0│
<font color="#000000">6:</font> │1 3  7  0  0  0│
<font color="#000000">7:</font> │2 4  6  8 11 14│
<font color="#000000">8:</font> │5 9 10 12 13  0│
<font color="#000000">9:</font> └~──────────────┘
<font color="#000000">10:</font> </tt></pre>
</div>

Our first try doesn't quite work: it winds up trying to create a numeric matrix,
which means that we can't have different rows of different sizes. So, the
information that <i>only</i> index <code>0</code> is such that <code>d[0] = 0</code> is lost. What we
can to is to wrap the keys to arrive at:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> $ d ← 0 1 2 1 2 3 2 1 2 3 3 2 3 3 2
<font color="#000000">3:</font> $ ]display b ← {⊂⍵}⌸d ⍝ d[b[i]] = i
<font color="#000000">4:</font> ┌→───────────────────────────────────────────┐
<font color="#000000">5:</font> │ ┌→┐ ┌→────┐ ┌→────────────┐ ┌→───────────┐ │
<font color="#000000">6:</font> │ │0│ │1 3 7│ │2 4 6 8 11 14│ │5 9 10 12 13│ │
<font color="#000000">7:</font> │ └~┘ └~────┘ └~────────────┘ └~───────────┘ │
<font color="#000000">8:</font> └∊───────────────────────────────────────────┘
<font color="#000000">9:</font> </tt></pre>
</div>

Consider the groups <code>b[2] = (2 4 6 8 11 14)</code> and <code>b[3] = (5 9 10 12 13)</code>. All of <code>3</code>'s parents
are present in <code>2</code>. Every element in <code>3</code> fits at some location in <code>2</code>. Here is what
the fit would look like:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> b[2]  2 4 _ 6 8 _  _ 11 __ __ 14   (nodes of depth 2)
<font color="#000000">03:</font> b[3]      5     9  10   12 13      (leaf nodes)
<font color="#000000">04:</font>           4     8   8   11 11      (parents: predecessor of b[3] in b[2])
<font color="#000000">05:</font> 
<font color="#000000">06:</font>               ∘:0                               0
<font color="#000000">07:</font> ┌──────────┬──┴─────────────────┐
<font color="#000000">08:</font> a:1        b:3                 c:7              1
<font color="#000000">09:</font> │      ┌───┴───┐     ┌──────────┼───────┐
<font color="#000000">10:</font> p:2    q:4     r:6   s:8        t:11    u:14    2
<font color="#000000">11:</font>        │             │          │
<font color="#000000">12:</font>        │          ┌──┴──┐     ┌─┴───┐
<font color="#000000">13:</font>        v:5        w:9   x:10  y:12  z:13        3
<font color="#000000">14:</font> </tt></pre>
</div>

We use the Interval Index(<code>⍸</code>) operator to solve the problem of finding the
parent / where we should sqeeze a node from <code>b[3]</code> into <code>b[2]</code>
(This is formally known as the
<a href=https://en.wikipedia.org/wiki/Predecessor_problem>
predecessor problem</a>
)
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> ⍝ left[a[i]] is closest number &lt; right[i]
<font color="#000000">3:</font> ⍝ left[a[i]] is the predecessor of right[i] in left[i].
<font color="#000000">4:</font> $ a ← (1 10 100 1000) ⍸ (1 2000 300 50 2 )
<font color="#000000">5:</font> 0 3 2 1 0
<font color="#000000">6:</font> </tt></pre>
</div>

Now, we can use the technology of predecessor to find parents
of depth 3 nodes among the depth 2 nodes:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> $ depth2 ← 2 4 6 8 11 14
<font color="#000000">03:</font> $ depth3 ← 5 9 10 12 13 ⍝ parents (from chart): 4 8 8 11 11
<font color="#000000">04:</font> $ depth3parentixs ← depth2 ⍸ depth3
<font color="#000000">05:</font> $ depth3parents  ← depth2[depth3parentixs]
<font color="#000000">06:</font> 4 8 8 11 11
<font color="#000000">07:</font> 
<font color="#000000">08:</font>               ∘:0                               0
<font color="#000000">09:</font> ┌──────────┬──┴─────────────────┐
<font color="#000000">10:</font> a:1        b:3                 c:7              1
<font color="#000000">11:</font> │      ┌───┴───┐     ┌──────────┼───────┐
<font color="#000000">12:</font> p:2    q:4     r:6   s:8        t:11    u:14    2
<font color="#000000">13:</font>        │             │          │
<font color="#000000">14:</font>        │          ┌──┴──┐     ┌─┴───┐
<font color="#000000">15:</font>        v:5        w:9   x:10  y:12  z:13        3
<font color="#000000">16:</font> </tt></pre>
</div>

We need to know one-more APL-ism: the <code>2-scan</code>. When we write
a usual scan operation, we have:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> $ ⍳5
<font color="#000000">3:</font> 1 2 3 4 5
<font color="#000000">4:</font> </tt></pre>
</div>

<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> $ +/⍳5 ⍝ reduce
<font color="#000000">3:</font> 15
<font color="#000000">4:</font> </tt></pre>
</div>

<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> $ 2+/⍳5 ⍝ apply + to _pairs_ (2 = pairs)
<font color="#000000">3:</font> 3 5 7 9 ⍝ (1+2) (2+3) (3+4) (4+5)
<font color="#000000">4:</font> </tt></pre>
</div>

<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> $ 3+/⍳5 ⍝  apply + to 3-tuples
<font color="#000000">3:</font> 6 9 12 ⍝ (1+2+3) (2+3+4) (3+4+5)
<font color="#000000">4:</font> </tt></pre>
</div>

We begin by assuming the parent of <code>i</code> is <code>i</code> by using <code>p←⍳≢d</code>.
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> $ d ← (0 1 2 1 2 3 2 1 2 3 3 2 3 3 2)
<font color="#000000">3:</font> $ d2nodes ← {⊂⍵}⌸d
<font color="#000000">4:</font> ┌→┬─────┬─────────────┬─────────────┐
<font color="#000000">5:</font> │1│2 4 8│3 5 7 9 12 15│6 10 11 13 14│
<font color="#000000">6:</font> └→┴~───→┴~───────────→┴~───────────→┘
<font color="#000000">7:</font> $ p←⍳≢d
<font color="#000000">8:</font> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
<font color="#000000">9:</font> </tt></pre>
</div>

Now comes the biggie:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> $ findparent ← {parentixs ← ⍺⍸⍵ ⋄ p[⍵]←⍺[parentixs]}
<font color="#000000">3:</font> </tt></pre>
</div>

<ul>
<li>
 <code>⍺</code> is the list of parent nodes.
</li>
<li>
 <code>⍵</code> is the list of current child nodes.
</li>
<li>
 We first find the indexes of our parent nodes by using
  the <code>pix ← parent ⍸ child</code> idiom.
</li>
<li>
 Then, we find the actual parents by indexing into
  the parent list: <code>pix[parentixs]</code>.
</li>
<li>
 We write these into the parents of the child using:
  <code>p[children] ← parent[parent ⍸ child]</code>
</li>

</ul>

This finally culminates in:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> $ d←0 1 2 1 2 3 2 1 2 3 3 2 3 3 2
<font color="#000000">03:</font> $ p←⍳≢d ⋄ d2nodes←{⊂⍵}⌸d ⋄ findp←{pix ← ⍺⍸⍵ ⋄ p[⍵]←⍺[pix]} ⋄ 2findp/d2nodes ⋄ p
<font color="#000000">04:</font> 0 0 1 0 3 4 3 0 7 8 8 7 11 11 7
<font color="#000000">05:</font> 
<font color="#000000">06:</font> 
<font color="#000000">07:</font>     (0   1  2  3  4  5  6  7  8  9 10 11 12 13 14)  | indexes
<font color="#000000">08:</font> d ← (0   1  2  1  2  3  2  1  2  3  3  2  3  3  2)  │ depths
<font color="#000000">09:</font> P ← (0   0  1  0  3  4  3  0  7  8  8  7 11 11  7)  │ parent indices
<font color="#000000">10:</font>               ∘:0                               0
<font color="#000000">11:</font> ┌──────────┬──┴─────────────────┐
<font color="#000000">12:</font> a:1        b:3                 c:7              1
<font color="#000000">13:</font> │      ┌───┴───┐     ┌──────────┼───────┐
<font color="#000000">14:</font> p:2    q:4     r:6   s:8        t:11    u:14    2
<font color="#000000">15:</font>        │             │          │
<font color="#000000">16:</font>        │          ┌──┴──┐     ┌─┴───┐
<font color="#000000">17:</font>        v:5        w:9   x:10  y:12  z:13        3
<font color="#000000">18:</font> </tt></pre>
</div>

Which can be further golfed to:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> $ p⊣2{p[⍵]←⍺[⍺⍸⍵]}⌿⊢∘⊂⌸d⊣p←⍳≢d
<font color="#000000">3:</font> 0 0 1 0 3 4 3 0 7 8 8 7 11 11 7
<font color="#000000">4:</font> </tt></pre>
</div>

The total time complexity of this method assuming infinite parallelism is as follows:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> $ p←⍳≢d ⋄ d2nodes←{⊂⍵}⌸d ⋄ findp←{pix ← ⍺⍸⍵ ⋄ p[⍵]←⍺[pix]} ⋄ 2findp/d2nodes ⋄ p
<font color="#000000">3:</font> </tt></pre>
</div>

<ul>
<li>
 <code>(p←⍳≢d)</code> can be filled in <code>O(1)</code> time.
</li>
<li>
 <code>(d2nodes←{⊂⍵}⌸d)</code> is searching for keys in a small integer domain, so this is <code>O(#nodes)</code> using
  radix sort as far as I know. However, the thesis mentions that this can be done in
  <code>O(log(|#nodes|))</code>. I'm not sure how, I need to learn this.
</li>
<li>
 For each call of <code>findp</code>, the call <code>(pix ← ⍺⍸⍵)</code> can be implemented using binary search
  leading to a logarthmic complexity in the size of <code>⍺</code> (since we are looking up
  for predecessors of <code>⍵</code> in <code>⍺</code>).
</li>
<li>
 The time complexity of the fold <code>2findp/d2nodes</code> can be done entirely in parallel
  since all the writes into the <code>p</code> vector are independent: we only write the
  parent of the current node we are looking at.
</li>

</ul>

<h4><a id=34-computing-nearest-parent-by-predicate href='#34-computing-nearest-parent-by-predicate'> § </a> 3.4: Computing nearest Parent by predicate</h4>
I'm going to simplify the original presentation by quite a bit.
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font>      a b c d e f g h i  | names
<font color="#000000">03:</font>      0 1 2 3 4 5 6 7 8  | indexes
<font color="#000000">04:</font> P ← (0 0 1 2 0 4 5 6 7) | parents
<font color="#000000">05:</font> X ← (0 1 0 0 1 1 0 0 0) | marked nodes
<font color="#000000">06:</font> 
<font color="#000000">07:</font>      a:0
<font color="#000000">08:</font> ┌────┴───┐
<font color="#000000">09:</font> b:1(X)   e:4(X)
<font color="#000000">10:</font> |        |
<font color="#000000">11:</font> c:2      f:5(X)
<font color="#000000">12:</font> |        |
<font color="#000000">13:</font> d:3      g:6
<font color="#000000">14:</font>          │
<font color="#000000">15:</font>          h:7
<font color="#000000">16:</font>          |
<font color="#000000">17:</font>          i:8
<font color="#000000">18:</font> </tt></pre>
</div>

We want to find nodes marked as <code>X</code> that are the closest parents to a
given node. The <code>X</code> vector is a boolean vector that has a <code>1</code> at
the index of each <code>X</code> node: <code>(b, e, f)</code>. So, the indexes <code>(1, 4, 5)</code>
are <code>1</code> in the <code>X</code> vector.
The output we want is the vector:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font>       0 1 2 3 4 5 6 7 8  | indexes
<font color="#000000">03:</font>       a b c d e f g h i  | names
<font color="#000000">04:</font> PX ← (0 0 1 1 0 4 5 5 5) | closest X parent index
<font color="#000000">05:</font>       a a b b a e f f f  | closest X parent name
<font color="#000000">06:</font> 
<font color="#000000">07:</font>     a:0
<font color="#000000">08:</font> ┌────┴───┐
<font color="#000000">09:</font> b:1(X)   e:4(X)
<font color="#000000">10:</font> |        |
<font color="#000000">11:</font> c:2      f:5(X)
<font color="#000000">12:</font> |        |
<font color="#000000">13:</font> d:3      g:6
<font color="#000000">14:</font>          │
<font color="#000000">15:</font>          h:7
<font color="#000000">16:</font>          |
<font color="#000000">17:</font>          i:8
<font color="#000000">18:</font> </tt></pre>
</div>

The incantation is:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> $ I←{(⊂⍵)⌷⍺} ⍝ index LHS by RHS | (100 101 102 103)[(3 1 2)] := 103 101 102
<font color="#000000">3:</font> $ PX ← P I@{X[⍵]≠1} ⍣ ≡ P
<font color="#000000">4:</font> 0 0 1 1 0 4 5 5 5
<font color="#000000">5:</font> </tt></pre>
</div>

TODO. At any rate, since this does not require any writes and purely reads,
and nor does it need any synchronization, this is fairly straightforward
to implement on the GPU.
<h4><a id=35-lifting-subtrees-to-the-root href='#35-lifting-subtrees-to-the-root'> § </a> 3.5: Lifting subtrees to the root</h4>
Once we have marked our <code>X</code> nodes, we now wish to lift entire subtrees of <code>X</code>
up to the root.
<ul>
<li>
  This pass displays how to lift subtrees and add new nodes to replace the subtree's original nodes.
</li>
<li>
 Luckily, there are no <i>sibling</i> relationships that need to be maintained since
  we are uprooting an entire subtree.
</li>
<li>
 There are no <i>ordering constraints</i> on how the subtrees should be arranged at
  the top.
</li>
<li>
 Hence, we can simply add new nodes to the <i>end</i> of the tree (in terms of the preorder traversal).
  Adding to the middle of the tree will be discussed later.
</li>

</ul>

There is some good advice in the thesis:
<blockquote> When using APL primitives this way, it may be good to map their names and definitions to the domain of trees. For example, the primitive <code>⍸Predicate</code> is read as "the nodes where <code>Predicate</code> holds" and not as "the indexes where <code>Predicate</code> is 1".</blockquote>
For example, given the tree:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font>       0 1 2 3 4 5  | indexes
<font color="#000000">03:</font>       a b c d e f  | names
<font color="#000000">04:</font> P  ← (0 0 1 0 3 4) | parents
<font color="#000000">05:</font> X  ← (0 1 0 1 1 0) | X nodes
<font color="#000000">06:</font> PX ← (0 0 1 0 3 4) | closest X parent index
<font color="#000000">07:</font> 
<font color="#000000">08:</font>     a:0
<font color="#000000">09:</font> ┌────┴───┐
<font color="#000000">10:</font> b:1(X)   d:3(X)
<font color="#000000">11:</font> |        |
<font color="#000000">12:</font> c:2      e:4(X)
<font color="#000000">13:</font>          |
<font color="#000000">14:</font>          f:5
<font color="#000000">15:</font> </tt></pre>
</div>

we want the transformed tree to be:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font>     a:0
<font color="#000000">03:</font> ┌────┴───┐
<font color="#000000">04:</font> bp:1(X)   ep:4(X)
<font color="#000000">05:</font> ---------
<font color="#000000">06:</font> b:1(X)
<font color="#000000">07:</font> |
<font color="#000000">08:</font> c:2
<font color="#000000">09:</font> ---------
<font color="#000000">10:</font> e:4
<font color="#000000">11:</font> |
<font color="#000000">12:</font> fp:5
<font color="#000000">13:</font> ---------
<font color="#000000">14:</font> f:5(X)
<font color="#000000">15:</font> |
<font color="#000000">16:</font> g:6
<font color="#000000">17:</font> </tt></pre>
</div>

We first look for nodes that need to be lifted.  There are:
<ul>
<li>
 Non-root nodes (ie, nodes whose parents are not themselves: <code>p≠(⍳≢p)</code>)
</li>
<li>
 Which have the property <code>X</code>.
</li>

</ul>

<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> nodes←⍸(X ∧ p≠(⍳≢p))  ⍝ ⍸:pick indexes.
<font color="#000000">3:</font> </tt></pre>
</div>

<h4><a id=36-wrapping-expressions href='#36-wrapping-expressions'> § </a> 3.6: Wrapping Expressions</h4>
<h4><a id=37-lifting-guard-test-exprsessions href='#37-lifting-guard-test-exprsessions'> § </a> 3.7: Lifting Guard Test Exprsessions</h4>
<h4><a id=38-couting-rank-of-index-operators href='#38-couting-rank-of-index-operators'> § </a> 3.8: Couting rank of index operators</h4>
<h4><a id=39-flattening-expressions href='#39-flattening-expressions'> § </a> 3.9: Flattening Expressions</h4>
<h4><a id=310-associating-frame-slots-and-variables href='#310-associating-frame-slots-and-variables'> § </a> 3.10: Associating Frame slots and variables</h4>
<h4><a id=311-placing-frames-into-a-lexical-stack href='#311-placing-frames-into-a-lexical-stack'> § </a> 3.11: Placing frames into a lexical stack</h4>
<h4><a id=312-recording-exported-names href='#312-recording-exported-names'> § </a> 3.12: Recording Exported names</h4>
<h4><a id=313-lexical-resolution href='#313-lexical-resolution'> § </a> 3.13: Lexical Resolution</h4>
<h4><a id=521-traversal-idioms href='#521-traversal-idioms'> § </a> 5.2.1 Traversal Idioms</h4>
<h4><a id=522-edge-mutation-idioms href='#522-edge-mutation-idioms'> § </a> 5.2.2 Edge Mutation Idioms</h4>
<h4><a id=523-node-mutation-idioms href='#523-node-mutation-idioms'> § </a> 5.2.3 Node Mutation Idioms</h4>
<h3><a id=things-i-wish-i-knew-when-i-was-learning-apl href='#things-i-wish-i-knew-when-i-was-learning-apl'> § </a> <a href=#things-i-wish-i-knew-when-i-was-learning-apl>
Things I wish I knew when I was learning APL</a>
</h3>
<ul>
<li>
 For pasting multi-line code,
  <a href=https://github.com/Dyalog/ride/issues/323>
there is a bug in the bug tracker for RIDE</a>
.
  For multi-line dfns, one can use <code>∇</code>. For multi-line values, I don't know yet.
</li>

</ul>

<ul>
<li>
 Operators in APL terminology (such as <code>¨</code>) are higher order functions.
  Thus, an operator allows one to modify known functions.
</li>

</ul>

<ul>
<li>
 Use <code>]disp</code> and <code>]display</code> to understand the structure of APL arrays.
</li>

</ul>

<ul>
<li>
 Set <code>]box on -style=max</code> to <i>always enable</i> drawing arrays with <code>]display</code>.
  This is supremely useful as a newbie to understand array structure.
</li>

</ul>

<ul>
<li>
 Set <code>]box on -trains=parens</code> to render trains as trees. Super
  helpful when attempting to grok <code>train</code> code.
</li>

</ul>

<ul>
<li>
 Set <code>]boxing on</code> to enable boxing for trains, arguments, everything.
</li>

</ul>

<h3><a id=every-ideal-that-is-maximal-wrt-being-disjoint-from-a-multiplicative-subset-is-prime href='#every-ideal-that-is-maximal-wrt-being-disjoint-from-a-multiplicative-subset-is-prime'> § </a> <a href=#every-ideal-that-is-maximal-wrt-being-disjoint-from-a-multiplicative-subset-is-prime>
Every ideal that is maximal wrt. being disjoint from a multiplicative subset is prime</a>
</h3>
I ran across this when reading another question on math.se, so I
<a href=https://math.stackexchange.com/questions/3570129/proof-verification-request-complement-of-multiplicative-set-is-ideal-iff-the-id>
posted this proof for verification</a>
 just to be sure I wasn't missing
something.
We wish to characterise prime ideals as precisely those that are disjoint from
a multiplicative subset <span class='latexinline'>
<span style="font-style:italic">S</span> &#X2286; <span style="font-style:italic">R</span></span>. That is:
<ul>
<li>
 An ideal <span class='latexinline'>
<span style="font-style:italic">P</span></span> is prime iff <span class='latexinline'>
<span style="font-style:italic">P</span> = <span style="font-style:italic">R</span> &#X2216; <span style="font-style:italic">S</span></span>, where <span class='latexinline'>
<span style="font-style:italic">S</span></span> is a multiplicative subset
  that cannot be made larger (ie, is maximal wrt to the <span class='latexinline'>
&#X2286;</span> ordering).
</li>

</ul>

I'll be using the definition of prime as:
<ul>
<li>
 An ideal <span class='latexinline'>
<span style="font-style:italic">P</span></span> is prime if for all <span class='latexinline'>
<span style="font-style:italic">x</span>, <span style="font-style:italic">y</span> &#X2208; <span style="font-style:italic">R</span></span>,
  <span class='latexinline'>
<span style="font-style:italic">xy</span> &#X2208; <span style="font-style:italic">P</span>  <span style="font-style:italic">x</span> &#X2208; <span style="font-style:italic">P</span> &#X2228; <span style="font-style:italic">y</span> &#X2208; <span style="font-style:italic">P</span></span>.
</li>

</ul>

<h4><a id=prime-ideal-implies-complement-is-maximal-multiplicative-subset href='#prime-ideal-implies-complement-is-maximal-multiplicative-subset'> § </a> Prime ideal implies complement is maximal multiplicative subset:</h4>
Let <span class='latexinline'>
<span style="font-style:italic">S</span> = &#X2261; <span style="font-style:italic">R</span> &#X2216; <span style="font-style:italic">P</span></span> be the complement of the prime ideal <span class='latexinline'>
<span style="font-style:italic">P</span>  <span style="font-style:italic">R</span></span>
in question.
<ul>
<li>
 Since <span class='latexinline'>
<span style="font-style:italic">P</span> &#X2260; <span style="font-style:italic">R</span></span>, <span class='latexinline'>
1 &#X2209;</span>P. (if <span class='latexinline'>
1 &#X2208; <span style="font-style:italic">P</span></span>, then every element <span class='latexinline'>
<span style="font-style:italic">x</span> . 1 &#X2208; <span style="font-style:italic">P</span></span>
  since <span class='latexinline'>
<span style="font-style:italic">P</span></span> is an ideal, and must be closed under multiplication with the
  entire ring). Hence, <span class='latexinline'>
1 &#X2208; <span style="font-style:italic">S</span></span>.
</li>
<li>
 For any <span class='latexinline'>
<span style="font-style:italic">x</span>, <span style="font-style:italic">y</span> &#X2208; <span style="font-style:italic">S</span></span>, we need <span class='latexinline'>
<span style="font-style:italic">xy</span> &#X2208; <span style="font-style:italic">S</span></span> for <span class='latexinline'>
<span style="font-style:italic">S</span></span> to be mulitplicative.
</li>
<li>
 For contradiction, let us say that <span class='latexinline'>
<span style="font-style:italic">x</span>, <span style="font-style:italic">y</span> &#X2208; <span style="font-style:italic">S</span></span> such that <span class='latexinline'>
<span style="font-style:italic">xy</span> &#X2209;<span style="font-style:italic">S</span></span>.
  Translating to <span class='latexinline'>
<span style="font-style:italic">P</span></span>, this means that <span class='latexinline'>
<span style="font-style:italic">x</span>, <span style="font-style:italic">y</span> &#X2209;<span style="font-style:italic">P</span></span> such that <span class='latexinline'>
<span style="font-style:italic">xy</span> &#X2208; <span style="font-style:italic">P</span></span>.
  This contradictions the definition of <span class='latexinline'>
<span style="font-style:italic">P</span></span> being prime.
</li>

</ul>

<h4><a id=ideal-whose-complement-is-maximal-multiplicative-subset-implies-ideal-is-prime href='#ideal-whose-complement-is-maximal-multiplicative-subset-implies-ideal-is-prime'> § </a> Ideal whose complement is maximal multiplicative subset implies ideal is prime.</h4>
<ul>
<li>
 Let <span class='latexinline'>
<span style="font-style:italic">I</span></span> be an ideal of the ring <span class='latexinline'>
<span style="font-style:italic">R</span></span> such that its complement <span class='latexinline'>
<span style="font-style:italic">S</span> &#X2261; <span style="font-style:italic">R</span> / <span style="font-style:italic">I</span></span>
  is a maximal multiplicative subset.
</li>
<li>
 Let <span class='latexinline'>
<span style="font-style:italic">i</span><sub>1</sub> <span style="font-style:italic">i</span><sub>2</sub> &#X2208; <span style="font-style:italic">I</span></span>. For <span class='latexinline'>
<span style="font-style:italic">I</span></span> to be prime,
  we need to show that <span class='latexinline'>
<span style="font-style:italic">i</span><sub>1</sub> &#X2208; <span style="font-style:italic">I</span></span> or <span class='latexinline'>
<span style="font-style:italic">i</span><sub>2</sub> &#X2208; <span style="font-style:italic">I</span></span>.
</li>
<li>
 For contradiction, let <span class='latexinline'>
<span style="font-style:italic">i</span><sub>1</sub>, <span style="font-style:italic">i</span><sub>2</sub> &#X2209;<span style="font-style:italic">I</span></span>.
  Thus, <span class='latexinline'>
<span style="font-style:italic">i</span><sub>1</sub>, <span style="font-style:italic">i</span><sub>2</sub> &#X2208; <span style="font-style:italic">S</span></span>. Since <span class='latexinline'>
<span style="font-style:italic">S</span></span> is multiplicative, <span class='latexinline'>
<span style="font-style:italic">i</span><sub>1</sub> <span style="font-style:italic">i</span><sub>2</sub> &#X2208; <span style="font-style:italic">S</span></span>. That is,
  <span class='latexinline'>
<span style="font-style:italic">i</span><sub>1</sub> <span style="font-style:italic">i</span><sub>2</sub> &#X2209;<span style="font-style:italic">I</span></span> (since <span class='latexinline'>
<span style="font-style:italic">I</span></span> is disjoint from <span class='latexinline'>
<span style="font-style:italic">S</span></span>).
</li>
<li>
 But this violates our assumption that <span class='latexinline'>
<span style="font-style:italic">i</span><sub>1</sub> <span style="font-style:italic">i</span><sub>2</sub> &#X2208; <span style="font-style:italic">I</span></span>. Hence, contradiction.
</li>

</ul>

<h3><a id=getting-started-with-apl href='#getting-started-with-apl'> § </a> <a href=#getting-started-with-apl>
Getting started with APL</a>
</h3>
<ul>
<li>
 Install <a href=https://www.dyalog.com/download-zone.htm>
Dyalog APL</a>
.
</li>
<li>
 Setup <a href=https://github.com/Dyalog/ride>
RIDE</a>
, the IDE for dyalog APL.
  This IDE comes with auto complete, good key bindings, a top bar chock-full of
  information of all the APL symbols. It's really well designed and a pleasure
  to use.
</li>
<li>
 Follow the <a href=https://tutorial.dyalog.com/>
Dyalog tutorial</a>
, solving it
  chapter by chapter.
</li>
<li>
 Bookmark <a href=https://aplcart.info/>
APLCart</a>
, a collection of APL idioms, and
  refer to it when in need.
</li>

</ul>

<h3><a id=spacechem-was-the-best-compiler-i-ever-used href='#spacechem-was-the-best-compiler-i-ever-used'> § </a> <a href=#spacechem-was-the-best-compiler-i-ever-used>
SpaceChem was the best compiler I ever used</a>
</h3>
It's kind of sad that this is the case, but on thinking about this, I realised
that the SpaceChem game was essentially a compiler, and it was such a pleasure
to learn how to use and debug --- the visual nature of it made it amazing to
find out.
<h3><a id=mnemonic-for-kruskal-and-prim href='#mnemonic-for-kruskal-and-prim'> § </a> <a href=#mnemonic-for-kruskal-and-prim>
Mnemonic for Kruskal and Prim</a>
</h3>
I often forget which is which, so I came up with this:
<ul>
<li>
 Prim is very prim and proper, and therefore doesn't spread herself out. She
  picks out the minimum spanning tree one vertex at a time.
</li>

</ul>

<h3><a id=legendre-transform href='#legendre-transform'> § </a> <a href=#legendre-transform>
Legendre transform</a>
</h3>
<img  src="./static/legendre.png">
<h3><a id=cartesian-trees href='#cartesian-trees'> § </a> <a href=#cartesian-trees>
Cartesian Trees</a>
</h3>
Cartesian trees construct a tree <span class='latexinline'>
<span style="font-style:italic">T</span> = <span style="font-style:italic">C</span>(<span style="font-style:italic">A</span>)</span> given an array <span class='latexinline'>
<span style="font-style:italic">A</span></span>, such that
range minimum query (RMQ) on the array <span class='latexinline'>
<span style="font-style:italic">A</span></span> is equivalent to the lowest common ancestor (LCA)
of the nodes of the tree <span class='latexinline'>
<span style="font-style:italic">T</span></span>.
<img width=200 height=200 src="./static/cartesian-tree.svg">
Note that the tree looks like a <i>min-heap</i>.
To see the connection to LCA, if we want to find the range minimum in the range containing the
elements <code>[12, 10, 20, 15, 18]</code> of the array, the minimum is <code>10</code>, which is
indeed the lowest common ancestor of the nodes of <code>12</code> and <code>18</code> in the tree.
<h4><a id=building-a-cartesian-tree-in-linear-time href='#building-a-cartesian-tree-in-linear-time'> § </a> Building a Cartesian tree in linear time:</h4>
<h4><a id=converting-lca-to-rmq href='#converting-lca-to-rmq'> § </a> Converting LCA to RMQ</h4>
We can go the other way, and convert an LCA problem into a RMQ problem. We
perform an inorder traversal of the nodes, scribbling down the
depth of the node (<a href=https://youtu.be/0rCFkuQS968?t=934>
Link to lecture at 15:30</a>
).
We ask for the <i>argmin</i> version of RMQ, that gives us the <i>index</i> of
the node with the lowest depth. This gives us the index of where the node lives.
<h4><a id=universe-reduction-in-rmq href='#universe-reduction-in-rmq'> § </a> Universe reduction in RMQ</h4>
We can have an arbitrary ordered universe, on which we want to perform RMQ.
We can convert this to LCA by using a cartesian tree, and then convert to
a "clean" RMQ (by using the LCA -> RMQ using depth conversion). This now
will give us way faster operations (since we now have integers).
<h4><a id=rmq href='#rmq'> § </a> <code>+-1</code> RMQ:</h4>
We want the differences between nodes to have a difference of only <code>+-1</code>. We
had a much wider gap. Here, we perform an Euler tour (walk the tree DFS search order),
and sribble down every vertex we visit.
To find the LCA, we perform the RMQ on the locations of the <i>first</i> occurence
of the node. (I think we don't actually need the first occurence, any
occurence will do).
<h4><a id=references href='#references'> § </a> References</h4>
<ul>
<li>
 Material shamelessly written down from
  <a href=https://www.youtube.com/watch?v=0rCFkuQS968>
Eric Demaine's excellent (MIT 6.851 Advanced Data Structures): Lecture 15</a>

</li>
<li>
 Image of the tree <a href=https://upload.wikimedia.org/wikipedia/commons/d/d5/Cartesian_tree.svg>
taken from WikiMedia</a>

</li>

</ul>

<h3><a id=dfs-numbers-as-a-monotone-map href='#dfs-numbers-as-a-monotone-map'> § </a> <a href=#dfs-numbers-as-a-monotone-map>
DFS numbers as a monotone map</a>
</h3>
Really, we want a partial order that is defined with the tree as the
Hasse diagram. However, performing operations on this is hard. Hence,
the DFS numbering is a good monotone map from this partial order
to the naturals, which creates a total order.
I want to think about this deeper, I feel that this might be a good way
to think about the <code>low</code> numbers that show up in
<a href=https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm>
tarjan's algorithm for strongly connected components</a>

This also begs the question: can we use other partial orders, that chunk
some information, but don't lose <i>all</i> the information as going to a total
order (the naturals) does?
<h3><a id=self-attention-not-really href='#self-attention-not-really'> § </a> <a href=#self-attention-not-really>
Self attention? not really</a>
</h3>
The code is taken from <a href=https://nlp.seas.harvard.edu/2018/04/03/attention.html>
The annotated transformer</a>

which explains the "attention is all you need paper".
On skimming the code, one sees the delightful line of code:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> <b><u><font color="#000000">class</font></u></b> EncoderLayer(nn.Module):
<font color="#000000">03:</font> <i><font color="#222222">  "Encoder is made up of self-attn and feed forward (defined below)"</font></i>
<font color="#000000">04:</font>   <b><u><font color="#000000">def</font></u></b> __init__(self, size, self_attn, feed_forward, dropout):
<font color="#000000">05:</font>      super(EncoderLayer, self).__init__()
<font color="#000000">06:</font>      self.self_attn = self_attn
<font color="#000000">07:</font>      self.feed_forward = feed_forward
<font color="#000000">08:</font>      self.sublayer = clones(SublayerConnection(size, dropout), <font color="#000000">2</font>)
<font color="#000000">09:</font>      self.size = size
<font color="#000000">10:</font>   <b><u><font color="#000000">def</font></u></b> forward(self, x, mask):
<font color="#000000">11:</font> <i><font color="#222222">    "Follow Figure 1 (left) for connections."</font></i>
<font color="#000000">12:</font>     x = self.sublayer[<font color="#000000">0</font>](x, <b><u><font color="#000000">lambda</font></u></b> x: self.self_attn(x, x, x, mask))
<font color="#000000">13:</font>     <b><u><font color="#000000">return</font></u></b> self.sublayer[<font color="#000000">1</font>](x, self.feed_forward)
<font color="#000000">14:</font> </tt></pre>
</div>

where the line:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> x = self.sublayer[<font color="#000000">0</font>](x, <b><u><font color="#000000">lambda</font></u></b> x: self.self_attn(x, x, x, mask))
<font color="#000000">3:</font> </tt></pre>
</div>

seems to imply that we are, indeed, performing a self attention with the same
value <code>x</code> as the query, key, and value.
However, reading the code of the self-attention (or the paper) leads
one to realise:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> <b><u><font color="#000000">class</font></u></b> MultiHeadedAttention(nn.Module):
<font color="#000000">03:</font>   <b><u><font color="#000000">def</font></u></b> __init__(self, h, d_model, dropout=<font color="#000000">0.1</font>):
<font color="#000000">04:</font> <i><font color="#222222">    "Take in model size and number of heads."</font></i>
<font color="#000000">05:</font>     super(MultiHeadedAttention, self).__init__()
<font color="#000000">06:</font>     <b><u><font color="#000000">assert</font></u></b> d_model % h == <font color="#000000">0</font>
<font color="#000000">07:</font>     <i><font color="#222222"># We assume d_v always equals d_k</font></i>
<font color="#000000">08:</font>     self.d_k = d_model // h
<font color="#000000">09:</font>     self.h = h
<font color="#000000">10:</font>     self.linears = clones(nn.Linear(d_model, d_model), <font color="#000000">4</font>)
<font color="#000000">11:</font>     self.attn = None
<font color="#000000">12:</font>     self.dropout = nn.Dropout(p=dropout)
<font color="#000000">13:</font> 
<font color="#000000">14:</font>   <b><u><font color="#000000">def</font></u></b> forward(self, query, key, value, mask=None):
<font color="#000000">15:</font> <i><font color="#222222">    "Implements Figure 2"</font></i>
<font color="#000000">16:</font>     <b><u><font color="#000000">if</font></u></b> mask <b><u><font color="#000000">is</font></u></b> <b><u><font color="#000000">not</font></u></b> None:
<font color="#000000">17:</font>         <i><font color="#222222"># Same mask applied to all h heads.</font></i>
<font color="#000000">18:</font>         mask = mask.unsqueeze(<font color="#000000">1</font>)
<font color="#000000">19:</font>     nbatches = query.size(<font color="#000000">0</font>)
<font color="#000000">20:</font> 
<font color="#000000">21:</font>     <i><font color="#222222"># 1) Do all the linear projections in batch from d_model =&gt; h x d_k</font></i>
<font color="#000000">22:</font>     query, key, value = \
<font color="#000000">23:</font>         [l(x).view(nbatches, -<font color="#000000">1</font>, self.h, self.d_k).transpose(<font color="#000000">1</font>, <font color="#000000">2</font>)
<font color="#000000">24:</font>          <b><u><font color="#000000">for</font></u></b> l, x <b><u><font color="#000000">in</font></u></b> zip(self.linears, (query, key, value))]
<font color="#000000">25:</font> 
<font color="#000000">26:</font>     <i><font color="#222222"># 2) Apply attention on all the projected vectors in batch.</font></i>
<font color="#000000">27:</font>     x, self.attn = attention(query, key, value, mask=mask,
<font color="#000000">28:</font>                              dropout=self.dropout)
<font color="#000000">29:</font> 
<font color="#000000">30:</font>     <i><font color="#222222"># 3) "Concat" using a view and apply a final linear.</font></i>
<font color="#000000">31:</font>     x = x.transpose(<font color="#000000">1</font>, <font color="#000000">2</font>).contiguous() \
<font color="#000000">32:</font>          .view(nbatches, -<font color="#000000">1</font>, self.h * self.d_k)
<font color="#000000">33:</font>     <b><u><font color="#000000">return</font></u></b> self.linears[-<font color="#000000">1</font>](x)
<font color="#000000">34:</font> </tt></pre>
</div>

where we notice:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> <i><font color="#222222">## 1) Do all the linear projections in batch from d_model =&gt; h x d_k</font></i>
<font color="#000000">3:</font> query, key, value = \
<font color="#000000">4:</font>   [l(x).view(nbatches, -<font color="#000000">1</font>, self.h, self.d_k).transpose(<font color="#000000">1</font>, <font color="#000000">2</font>)
<font color="#000000">5:</font>    <b><u><font color="#000000">for</font></u></b> l, x <b><u><font color="#000000">in</font></u></b> zip(self.linears, (query, key, value))]
<font color="#000000">6:</font> 
<font color="#000000">7:</font> <i><font color="#222222">## 2) Apply attention on all the projected vectors in batch.</font></i>
<font color="#000000">8:</font> x, self.attn = attention(query, key, value, mask=mask,
<font color="#000000">9:</font>                          dropout=self.dropout)
<font color="#000000">10:</font> </tt></pre>
</div>

where we see that <code>query, key, value</code> are being linearly transformed
before being used. Hence, an input of <span class='latexinline'>
(<span style="font-style:italic">x</span>, <span style="font-style:italic">x</span>, <span style="font-style:italic">x</span>)</span> is transformed
to <span class='latexinline'>
(<span style="font-style:italic">q</span>&#X2032;, <span style="font-style:italic">k</span>&#X2032;, <span style="font-style:italic">v</span>&#X2032;) = (<span style="font-style:italic">Qx</span>, <span style="font-style:italic">Kx</span>, <span style="font-style:italic">Vx</span>)</span> where <span class='latexinline'>
<span style="font-style:italic">Q</span>, <span style="font-style:italic">K</span>, <span style="font-style:italic">V</span></span> are arbitrary matrices.
Next, when we pass these into attention, the output we get is:
<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">softmax(<span style="font-style:italic">q</span>&#X2032;,&#XA0;<span style="font-style:italic">k</span>&#X2032;<sup><span style="font-style:italic">T</span></sup>)&#XA0;<span style="font-style:italic">v</span>&#XA0;=&#XA0;(<span style="font-style:italic">Q</span>&#XA0;<span style="font-style:italic">x</span>)&#XA0;(<span style="font-style:italic">K</span>&#XA0;<span style="font-style:italic">x</span>)<sup><span style="font-style:italic">T</span></sup>&#XA0;(<span style="font-style:italic">V</span>&#XA0;<span style="font-style:italic">x</span>)&#XA0;=&#XA0;<span style="font-style:italic">Q</span>&#XA0;<span style="font-style:italic">x</span>&#XA0;<span style="font-style:italic">x</span><sup><span style="font-style:italic">T</span></sup>&#XA0;<span style="font-style:italic">K</span><sup><span style="font-style:italic">T</span></sup>&#XA0;<span style="font-style:italic">V</span>&#XA0;<span style="font-style:italic">x</span>
</td></tr>
</table></div>
the code below is the same thing, spelled out:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> def attention(query, key, value, mask=None, dropout=None):
<font color="#000000">03:</font>     "Compute 'Scaled Dot Product Attention'"
<font color="#000000">04:</font>     d_k = query.size(-1)
<font color="#000000">05:</font>     scores = torch.matmul(query, key.transpose(-2, -1)) \
<font color="#000000">06:</font>              / math.sqrt(d_k)
<font color="#000000">07:</font>     if mask is not None:
<font color="#000000">08:</font>         scores = scores.masked_fill(mask == 0, -1e9)
<font color="#000000">09:</font>     p_attn = F.softmax(scores, dim = -1)
<font color="#000000">10:</font>     if dropout is not None:
<font color="#000000">11:</font>         p_attn = dropout(p_attn)
<font color="#000000">12:</font>     return torch.matmul(p_attn, value), p_attn
<font color="#000000">13:</font> </tt></pre>
</div>

So It's not <i>really</i> self attention: it's more like: modulated attention
to self <code>:)</code>
<h3><a id=coarse-structures href='#coarse-structures'> § </a> <a href=#coarse-structures>
Coarse structures</a>
</h3>
A coarse structure on the set <span class='latexinline'>
<span style="font-style:italic">X</span></span> is a collection of relations on <span class='latexinline'>
<span style="font-style:italic">X</span></span>:
<span class='latexinline'>
<span style="font-style:italic">E</span> &#X2286; 2<sup><span style="font-style:italic">X</span> &#XD7; <span style="font-style:italic">X</span></sup></span> (called as <i>controlled sets</i> / <i>entourages</i>)
such that:
<ul>
<li>
 <span class='latexinline'>
(&#X3B4; &#X2261; { (<span style="font-style:italic">x</span>, <span style="font-style:italic">x</span>) : <span style="font-style:italic">x</span> &#X2208; <span style="font-style:italic">X</span> }) &#X2208; <span style="font-style:italic">E</span></span>.
</li>
<li>
 Closed under subsets: <span class='latexinline'>
&#X2200; <span style="font-style:italic">e</span> &#X2208; <span style="font-style:italic">E</span>, <span style="font-style:italic">f</span> &#X2282; <span style="font-style:italic">e</span>  <span style="font-style:italic">f</span> &#X2208; <span style="font-style:italic">E</span></span>.
</li>
<li>
 Closed under transpose: if <span class='latexinline'>
<span style="font-style:italic">e</span> &#X2208; <span style="font-style:italic">E</span></span> then <span class='latexinline'>
(<span style="font-style:italic">e</span><sup><span style="font-style:italic">T</span></sup> &#X2261; { (<span style="font-style:italic">y</span>, <span style="font-style:italic">x</span>) : (<span style="font-style:italic">x</span>, <span style="font-style:italic">y</span>) &#X2208; <span style="font-style:italic">e</span> }) &#X2208; <span style="font-style:italic">E</span></span>.
</li>
<li>
 Closed under finite unions.
</li>
<li>
 Closed under composition: <span class='latexinline'>
&#X2200; <span style="font-style:italic">e</span>, <span style="font-style:italic">f</span> &#X2208; <span style="font-style:italic">E</span>, <span style="font-style:italic">e</span> &#X2218; <span style="font-style:italic">f</span> &#X2208; <span style="font-style:italic">E</span></span>, where <span class='latexinline'>
&#X2218;</span>
  is composition of relations.
</li>

</ul>

The sets that are controlled are "small" sets.
The bounded coarse structure on a metric space <span class='latexinline'>
(<span style="font-style:italic">X</span>, <span style="font-style:italic">d</span>)</span> is the set of all relations
such that there exists a uniform bound such that all related elements are within
that bounded distance.
<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(<span style="font-style:italic">e</span>&#XA0;&#X2282;&#XA0;<span style="font-style:italic">X</span>&#XA0;&#XD7;&#XA0;<span style="font-style:italic">X</span>)&#XA0;&#X2208;&#XA0;<span style="font-style:italic">E</span>&#XA0;&#XA0;&#X21D0;&#X21D2;&#XA0;&#X2203;&#XA0;&#X3B4;&#XA0;&#X2208;&#XA0;&#X211D;,&#XA0;&#X2200;&#XA0;(<span style="font-style:italic">x</span>,&#XA0;<span style="font-style:italic">y</span>)&#XA0;&#X2208;&#XA0;<span style="font-style:italic">E</span>,&#XA0;<span style="font-style:italic">d</span>(<span style="font-style:italic">x</span>,&#XA0;<span style="font-style:italic">y</span>)&#XA0;&lt;&#XA0;&#X3B4;
</td></tr>
</table></div>
We can check that the functions:
<ul>
<li>
 <span class='latexinline'>
<span style="font-style:italic">f</span>: &#X2124; &#X2192; &#X211D;, <span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>) &#X2261; <span style="font-style:italic">x</span></span> and
</li>
<li>
 <span class='latexinline'>
<span style="font-style:italic">g</span>: &#X211D; &#X2192; &#X2124;, <span style="font-style:italic">g</span>(<span style="font-style:italic">x</span>) &#X2261; &#X230A; <span style="font-style:italic">x</span> &#X230B;</span>
</li>

</ul>

are coarse inverses to each other.
I am interested in this because if topology is related to semidecidability,
then coarse structures (which are their dual) are related to..?
<h4><a id=references href='#references'> § </a> References</h4>
<ul>
<li>
 <a href=http://www.ams.org/notices/200606/whatis-roe.pdf>
What is a.. coarse structure by AMS</a>

</li>

</ul>

<h3><a id=matroids-for-greedy-algorithms href='#matroids-for-greedy-algorithms'> § </a> <a href=#matroids-for-greedy-algorithms>
Matroids for greedy algorithms</a>
</h3>
<h4><a id=definitions-of-matroids href='#definitions-of-matroids'> § </a> Definitions of matroids</h4>
A matrioid <span class='latexinline'>
<span style="font-style:italic">M</span></span> is a set <span class='latexinline'>
<span style="font-style:italic">X</span></span> equipped with an independence set <span class='latexinline'>
<span style="font-style:italic">I</span> &#X2286; 2<sup><span style="font-style:italic">X</span></sup></span>.
<ul>
<li>
 The empty set is independent: <span class='latexinline'>
&#X2205; &#X2208; <span style="font-style:italic">I</span></span>.
</li>
<li>
 The independence set is downward-closed/closed under subsets:  <span class='latexinline'>
 &#X2200; <span style="font-style:italic">i</span> &#X2208; <span style="font-style:italic">I</span>, &#X2200; <span style="font-style:italic">i</span>&#X2032; &#X2286; <span style="font-style:italic">i</span>, <span style="font-style:italic">i</span>&#X2032; &#X2208; <span style="font-style:italic">I</span></span>.
</li>
<li>
 For any independent sets <span class='latexinline'>
<span style="font-style:italic">A</span>, <span style="font-style:italic">B</span> &#X2208; <span style="font-style:italic">I</span></span>, if <span class='latexinline'>
| <span style="font-style:italic">A</span> |</span> is larger than
  <span class='latexinline'>
| <span style="font-style:italic">B</span> |</span>, then we must be able to add an element from
  <span class='latexinline'>
<span style="font-style:italic">a</span> &#X2208; <span style="font-style:italic">A</span></span> into <span class='latexinline'>
<span style="font-style:italic">B</span>&#X2032; &#X2261; <span style="font-style:italic">B</span> &#X222A; <span style="font-style:italic">a</span></span> such that <span class='latexinline'>
<span style="font-style:italic">B</span>&#X2032;</span> is both independent and larger than <span class='latexinline'>
<span style="font-style:italic">B</span></span>:
  <span class='latexinline'>
<span style="font-style:italic">B</span>&#X2032; &#X2208; <span style="font-style:italic">I</span> &#X2227; | <span style="font-style:italic">B</span>&#X2032; | &gt; | <span style="font-style:italic">B</span> |</span>. (<b>The exchange property</b>)
</li>

</ul>

<h4><a id=example-1-linearly-independent-sets href='#example-1-linearly-independent-sets'> § </a> Example 1: Linearly independent sets</h4>
Let <span class='latexinline'>
<span style="font-style:italic">V</span></span> be a vector space. The independent sets <span class='latexinline'>
<span style="font-style:italic">I</span></span> are of the form:
<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">I</span>&#XA0;&#X2261;&#XA0;{&#XA0;<span style="font-style:italic">S</span>&#XA0;&#X2286;&#XA0;<span style="font-style:italic">V</span>&#XA0;&#XA0;:&#XA0;&#XA0;vectors in <span style="font-style:italic">S</span> are lineary independent&#XA0;}&#XA0;</td></tr>
</table></div>
This is an independence system because the empty set is linearly independent,
and subsets of a linearly independent collection of vectors will be linearly
independent.
The exchange property is satisfied because of linear algebraic reasons.
<h4><a id=example-2-the-graphiccyclic-matroid-matroid-of-forests href='#example-2-the-graphiccyclic-matroid-matroid-of-forests'> § </a> Example 2: The graphic/cyclic Matroid: Matroid of Forests</h4>
Let <span class='latexinline'>
<span style="font-style:italic">G</span> = (<span style="font-style:italic">V</span>, <span style="font-style:italic">E</span>)</span> be a graph. Then collections of edges of the form:
<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">I</span>&#XA0;&#X2261;&#XA0;{&#XA0;<span style="font-style:italic">F</span>&#XA0;&#X2286;&#XA0;<span style="font-style:italic">E</span>&#XA0;:&#XA0;<span style="font-style:italic">F</span> contains no cycles&#XA0;}&#XA0;</td></tr>
</table></div>
is an independence system because the empty forest is a forest, and
a subset of edges of a forest continues to be a forest.
To check the exchange property, TODO
<h4><a id=example-3-the-partition-matroid href='#example-3-the-partition-matroid'> § </a> Example 3: The partition matroid</h4>
Consider the partition matroid <span class='latexinline'>
<span style="font-style:italic">M</span> &#X2261; (<span style="font-style:italic">E</span>, <span style="font-style:italic">I</span>)</span>, where we have a
partitioning of <span class='latexinline'>
<span style="font-style:italic">E</span></span> known as <span class='latexinline'>
<span style="font-style:italic">E</span><sub><span style="font-style:italic">i</span></sub></span>, and numbers <span class='latexinline'>
<span style="font-style:italic">k</span><sub><span style="font-style:italic">i</span></sub></span> the
independence set consists of subsets <span class='latexinline'>
<span style="font-style:italic">F</span></span> which have at most <span class='latexinline'>
<span style="font-style:italic">k</span><sub><span style="font-style:italic">i</span></sub></span>
elements in common with each <span class='latexinline'>
<span style="font-style:italic">E</span><sub><span style="font-style:italic">i</span></sub></span>.
<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">I</span>&#XA0;&#X2261;&#XA0;{&#XA0;<span style="font-style:italic">F</span>&#XA0;&#X2286;&#XA0;<span style="font-style:italic">E</span>&#XA0;&#XA0;:&#XA0;&#X2200;&#XA0;<span style="font-style:italic">i</span>&#XA0;=&#XA0;1,&#XA0;&#X2026;&#XA0;<span style="font-style:italic">N</span>,&#XA0;|&#XA0;<span style="font-style:italic">F</span>&#XA0;&#X22C2;&#XA0;<span style="font-style:italic">E</span><sub><span style="font-style:italic">i</span></sub>&#XA0;|&#XA0;&#X2264;&#XA0;<span style="font-style:italic">k</span><sub><span style="font-style:italic">i</span></sub>&#XA0;}
</td></tr>
</table></div>
The independence axioms are intuitively satisfied, since our constraints on picking
edges are of the form <span class='latexinline'>
| <span style="font-style:italic">F</span> &#X2229; <span style="font-style:italic">E</span><sub><span style="font-style:italic">i</span></sub> | &#X2264; <span style="font-style:italic">k</span><sub><span style="font-style:italic">i</span></sub></span>, which will continue to
hold as <span class='latexinline'>
<span style="font-style:italic">F</span></span> becomes smaller.
For the exchange axiom, let <span class='latexinline'>
| <span style="font-style:italic">Y</span> | &gt; | <span style="font-style:italic">X</span> |</span>. Then, we can assert that for some index
<span class='latexinline'>
<span style="font-style:italic">i</span></span>, it must be the case that <span class='latexinline'>
| <span style="font-style:italic">Y</span> &#X2229; <span style="font-style:italic">E</span><sub><span style="font-style:italic">i</span></sub> | &gt; | <span style="font-style:italic">X</span> &#X2229; <span style="font-style:italic">E</span><sub><span style="font-style:italic">i</span></sub> |</span>. Hence,
we can add an element in <span class='latexinline'>
<span style="font-style:italic">E</span><sub><span style="font-style:italic">i</span></sub> &#X2229; (<span style="font-style:italic">Y</span> / <span style="font-style:italic">X</span>)</span> into <span class='latexinline'>
<span style="font-style:italic">X</span></span> whilst still maintaining independence.
<h4><a id=bases-and-circuits href='#bases-and-circuits'> § </a> Bases and Circuits</h4>
<ul>
<li>
 <b>Bases</b> are the maximal independent sets of <span class='latexinline'>
<span style="font-style:italic">I</span></span> (ordered by inclusion). On adding an element into a basis element, they
  will become dependent. They are called bases by analogy with linear algebra.
</li>

</ul>

<ul>
<li>
 <b>Circuits</b> are minimal dependent sets of <span class='latexinline'>
<span style="font-style:italic">I</span></span>. This comes from analogy with trees: if we remove an element
  from any circuit (loop) in a graph, what we are left with is a tree.
</li>

</ul>

A matroid can be completely categorized by knowing either the bases or the circuits of that matroid.
<h4><a id=unique-circuit-property href='#unique-circuit-property'> § </a> Unique Circuit property</h4>
<ul>
<li>
 <b>Theorem</b>: Let <span class='latexinline'>
<span style="font-style:italic">M</span> &#X2261; (<span style="font-style:italic">E</span>, <span style="font-style:italic">I</span>)</span> be a matroid, and let <span class='latexinline'>
<span style="font-style:italic">S</span> &#X2208; <span style="font-style:italic">I</span>, <span style="font-style:italic">e</span> &#X2208; <span style="font-style:italic">E</span></span> such that <span class='latexinline'>
<span style="font-style:italic">S</span> &#X222A; {<span style="font-style:italic">e</span> } &#X2209;<span style="font-style:italic">I</span></span>.
</li>

</ul>

Then, there exists a <b>unique circuit</b> <span class='latexinline'>
<span style="font-style:italic">C</span> &#X2286; <span style="font-style:italic">S</span> &#X222A; { <span style="font-style:italic">e</span> }</span>.
That is, when we go from independent to dependent by adding an element, we will
have a <b>single, unique circuit</b>. For example, when we add an edge into a
forest to create a cycle, this cycle will be unique!
<h4><a id=proof href='#proof'> § </a> Proof</h4>
Let <span class='latexinline'>
<span style="font-style:italic">C</span><sub>1</sub>, <span style="font-style:italic">C</span><sub>2</sub></span> be circuits
created when <span class='latexinline'>
<span style="font-style:italic">e</span></span> was added into <span class='latexinline'>
<span style="font-style:italic">S</span></span>, where <span class='latexinline'>
<span style="font-style:italic">C</span><sub>1</sub></span> is the <b>largest</b> circuit of <span class='latexinline'>
<span style="font-style:italic">S</span></span>,
and <span class='latexinline'>
<span style="font-style:italic">C</span><sub>2</sub></span> is the <b>smallest</b> circuit of <span class='latexinline'>
<span style="font-style:italic">S</span></span>.
Notice that <span class='latexinline'>
<span style="font-style:italic">C</span><sub>1</sub>, <span style="font-style:italic">C</span><sub>2</sub></span> <b>must</b> contain <span class='latexinline'>
<span style="font-style:italic">e</span></span> ---
if they did not, then <span class='latexinline'>
<span style="font-style:italic">C</span><sub>1</sub>, <span style="font-style:italic">C</span><sub>2</sub></span> would be circuits in
<span class='latexinline'>
<span style="font-style:italic">S</span></span>, contradicting the assumption that <span class='latexinline'>
<span style="font-style:italic">S</span></span> is independent.
Recall that <span class='latexinline'>
<span style="font-style:italic">C</span><sub>1</sub>, <span style="font-style:italic">C</span><sub>2</sub></span> are both circuits, which means that removing even a
single element from them will cause them to become independent sets.
Let us contemplate <span class='latexinline'>
<span style="font-style:italic">C</span> &#X2261; <span style="font-style:italic">C</span><sub>1</sub> &#X222A; <span style="font-style:italic">C</span><sub>2</sub></span>. Either <span class='latexinline'>
<span style="font-style:italic">C</span> = <span style="font-style:italic">C</span><sub>1</sub></span> in which
case we are done.
Otherwise, <span class='latexinline'>
| <span style="font-style:italic">C</span> | &gt; | <span style="font-style:italic">C</span><sub>1</sub> |</span>, <span class='latexinline'>
| <span style="font-style:italic">C</span> | &gt; | <span style="font-style:italic">C</span><sub>2</sub> |</span>.
Otherwise, consider <span class='latexinline'>
<span style="font-style:italic">C</span>&#X2032; &#X2261; <span style="font-style:italic">C</span>  { <span style="font-style:italic">e</span> } = (<span style="font-style:italic">C</span><sub>1</sub> &#X222A; <span style="font-style:italic">C</span><sub>2</sub>)  {<span style="font-style:italic">e</span>} = (<span style="font-style:italic">C</span><sub>1</sub>  {<span style="font-style:italic">e</span>}) &#X222A; (<span style="font-style:italic">C</span><sub>2</sub>  { <span style="font-style:italic">e</span> })</span>.
<ul>
<li>
 <span class='latexinline'>
<span style="font-style:italic">C</span>&#X2032; &#X2286; <span style="font-style:italic">S</span></span>, since <span class='latexinline'>
<sub>1</sub>  {<span style="font-style:italic">e</span>}, <span style="font-style:italic">C</span><sub>2</sub>  {<span style="font-style:italic">e</span>} &#X2286; <span style="font-style:italic">S</span></span>.
</li>
<li>
 <span class='latexinline'>
<span style="font-style:italic">S</span></span> is an independent set, all of whose subsets are independent by
  definition.  So <span class='latexinline'>
<span style="font-style:italic">C</span>&#X2032;</span> is an independent set.
</li>
<li>
 <span class='latexinline'>
| <span style="font-style:italic">C</span>&#X2032; | &#X2265; | <span style="font-style:italic">C</span><sub>1</sub> |</span>, <span class='latexinline'>
| <span style="font-style:italic">C</span>&#X2032; | &#X2265; | <span style="font-style:italic">C</span><sub>2</sub> |</span>.
</li>

</ul>

Now, we consider <span class='latexinline'>
<span style="font-style:italic">C</span></span>. Clearly, this is a dependent set,
since <span class='latexinline'>
<span style="font-style:italic">C</span><sub>1</sub>  <span style="font-style:italic">C</span></span>, and <span class='latexinline'>
<span style="font-style:italic">C</span><sub>1</sub></span> is a dependent set.
Since, <span class='latexinline'>
<span style="font-style:italic">C</span> = <span style="font-style:italic">C</span>&#X2032; &#X222A; {<span style="font-style:italic">e</span> }</span>, this means that <span class='latexinline'>
<span style="font-style:italic">C</span>&#X2032;</span> is a maximally independent set.
Since <span class='latexinline'>
<span style="font-style:italic">C</span>&#X2032;</span> does not contain <span class='latexinline'>
<span style="font-style:italic">e</span></span>, <span class='latexinline'>
<span style="font-style:italic">C</span>&#X2032; = <span style="font-style:italic">S</span></span>.
<h4><a id=rank-functions href='#rank-functions'> § </a> Rank functions</h4>
A rank function of a matroid <span class='latexinline'>
<span style="font-style:italic">M</span> &#X2261; &#X27E8; <span style="font-style:italic">X</span>, <span style="font-style:italic">I</span> &#X27E9;</span>
is a function:
<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">r</span>:&#XA0;2<sup><span style="font-style:italic">X</span></sup>&#XA0;&#X2192;&#XA0;&#X2115;&#XA0;:&#XA0;<span style="font-style:italic">r</span>(<span style="font-style:italic">S</span>)&#XA0;=&#XA0;max{&#XA0;|&#XA0;<span style="font-style:italic">T</span>&#XA0;|&#XA0;:&#XA0;<span style="font-style:italic">T</span>&#XA0;&#X2286;&#XA0;<span style="font-style:italic">S</span>&#XA0;&#X2227;&#XA0;<span style="font-style:italic">T</span>&#XA0;&#X2208;&#XA0;<span style="font-style:italic">I</span>&#XA0;}
</td></tr>
</table></div>
That is, for any subset <span class='latexinline'>
<span style="font-style:italic">S</span> &#X2286; <span style="font-style:italic">X</span></span>, <span class='latexinline'>
<span style="font-style:italic">r</span>(<span style="font-style:italic">S</span>)</span> is the cardinality of the
largest independent subset of <span class='latexinline'>
<span style="font-style:italic">S</span></span>.
<ul>
<li>
 In the matroid of linearly independent sets of vectors, the rank of
  a set of vectors is the dimension of their spanning set.
</li>

</ul>

In this matroid, the
TODO: picture
<h4><a id=bipartite-matching-as-matroid-intersection href='#bipartite-matching-as-matroid-intersection'> § </a> Bipartite matching as matroid intersection</h4>
Matchings in a bipartite graph <span class='latexinline'>
<span style="font-style:italic">G</span> = (<span style="font-style:italic">V</span>, <span style="font-style:italic">E</span>)</span> with partition <span class='latexinline'>
(<span style="font-style:italic">A</span>, <span style="font-style:italic">B</span>)</span> arise
as the intersection of the independent sets of two matroids.
We will denote by <span class='latexinline'>
&#X3B4;: <span style="font-style:italic">V</span> &#X2192; 2<sup><span style="font-style:italic">E</span></sup></span> the function which takes
a vertex to the set of edges incident on that vertex.
Let <span class='latexinline'>
<span style="font-style:italic">M</span><sub><span style="font-style:italic">A</span></sub></span> be a <i>partition matroid</i>: <span class='latexinline'>
<span style="font-style:italic">M</span><sub><span style="font-style:italic">A</span></sub> &#X2261; (<span style="font-style:italic">E</span>, <span style="font-style:italic">I</span><sub><span style="font-style:italic">A</span></sub>)</span> where <span class='latexinline'>
<span style="font-style:italic">I</span><sub><span style="font-style:italic">A</span></sub></span> is:
<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">I</span><sub><span style="font-style:italic">A</span></sub>&#XA0;&#X2261;&#XA0;{&#XA0;<span style="font-style:italic">F</span>&#XA0;&#X2286;&#XA0;<span style="font-style:italic">E</span>&#XA0;:&#XA0;|&#XA0;<span style="font-style:italic">F</span>&#XA0;&#X22C2;&#XA0;&#X3B4;(<span style="font-style:italic">a</span>)&#XA0;|&#XA0;&#X2264;&#XA0;1&#XA0;&#X2200;&#XA0;<span style="font-style:italic">a</span>&#XA0;&#X2208;&#XA0;<span style="font-style:italic">A</span>&#XA0;}
</td></tr>
</table></div>
That is, in <span class='latexinline'>
<span style="font-style:italic">I</span><sub><span style="font-style:italic">A</span></sub></span>, every independent set has for each vertex of <span class='latexinline'>
<span style="font-style:italic">A</span></span>, at most
one edge incident. We need to check that this is an independent set.
The empty set of no edges is independent. If some collection of edges are
such that they have at most one edge incident, then removing edges can
only <i>decrease</i> incidence. Hence, it's also downward closed.
TODO: add picture
Similarly, we define <span class='latexinline'>
<span style="font-style:italic">M</span><sub><span style="font-style:italic">B</span></sub> &#X2261; (<span style="font-style:italic">E</span>, <span style="font-style:italic">I</span><sub><span style="font-style:italic">B</span></sub>)</span>:
<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">I</span><sub><span style="font-style:italic">B</span></sub>&#XA0;&#X2261;&#XA0;{&#XA0;<span style="font-style:italic">F</span>&#XA0;&#X2286;&#XA0;<span style="font-style:italic">E</span>&#XA0;:&#XA0;|&#XA0;<span style="font-style:italic">F</span>&#XA0;&#X22C2;&#XA0;&#X3B4;(<span style="font-style:italic">b</span>)&#XA0;|&#XA0;&#X2264;&#XA0;1&#XA0;&#X2200;&#XA0;<span style="font-style:italic">b</span>&#XA0;&#X2208;&#XA0;<span style="font-style:italic">B</span>&#XA0;}
</td></tr>
</table></div>
Now, notice that any collection of edges <span class='latexinline'>
<span style="font-style:italic">F</span> &#X2208; <span style="font-style:italic">I</span><sub><span style="font-style:italic">A</span></sub> &#X2229; <span style="font-style:italic">I</span><sub><span style="font-style:italic">B</span></sub></span> is a legal
matching, since the edges cover all vertices of <span class='latexinline'>
<span style="font-style:italic">A</span></span> and <span class='latexinline'>
<span style="font-style:italic">B</span></span> at most once.
The largest element of <span class='latexinline'>
<span style="font-style:italic">I</span><sub><span style="font-style:italic">A</span></sub> &#X2229; <span style="font-style:italic">I</span><sub><span style="font-style:italic">B</span></sub></span> is the <i>maximum matching</i> that we
are looking for.
<h4><a id=largest-common-independent-set href='#largest-common-independent-set'> § </a> Largest common independent set</h4>
Given two matroids <span class='latexinline'>
<span style="font-style:italic">M</span><sub>1</sub> &#X2261; (<span style="font-style:italic">E</span>, <span style="font-style:italic">I</span><sub>1</sub>)</span>, <span class='latexinline'>
<span style="font-style:italic">M</span><sub>2</sub> &#X2261; (<span style="font-style:italic">E</span>, <span style="font-style:italic">I</span><sub>2</sub>)</span>, with rank
functions <span class='latexinline'>
<span style="font-style:italic">r</span><sub>1</sub></span> and <span class='latexinline'>
<span style="font-style:italic">r</span><sub>2</sub></span>. Let <span class='latexinline'>
<span style="font-style:italic">S</span> &#X2208; <span style="font-style:italic">I</span><sub>1</sub> <span style="font-style:italic">cap</span> <span style="font-style:italic">I</span><sub>2</sub></span> and let <span class='latexinline'>
<span style="font-style:italic">F</span> &#X2286; <span style="font-style:italic">E</span></span>.
<ul>
<li>
  <span class='latexinline'>
| <span style="font-style:italic">S</span> | = | <span style="font-style:italic">S</span> &#X2229; <span style="font-style:italic">F</span> | + | <span style="font-style:italic">S</span> &#X2229; (<span style="font-style:italic">E</span> / <span style="font-style:italic">F</span>) |</span>.
</li>

</ul>

<h4><a id=references href='#references'> § </a> References:</h4>
<ul>
<li>
 <a href=http://math.mit.edu/~goemans/18433S11/matroid-notes.pdf>
Michel Goeman's standalone notes on matroids</a>

</li>
<li>
 <a href=http://math.mit.edu/~goemans/18433S11/matroid-intersect-notes.pdf>
Michel Goeman's standalone notes on matroid intersection</a>

</li>
<li>
 <a href=https://math.mit.edu/~goemans/18438F09/lec11.pdf>
Lecture 11 of Michel Goeman's lecture on Advanced Combinatorial Optimisation</a>

</li>

</ul>

<h3><a id=grokking-zariski href='#grokking-zariski'> § </a> <a href=#grokking-zariski>
Grokking Zariski</a>
</h3>
There's a lot written on the Zariski topology on the internet, but most
of them lack explicit examples and pictures. This is my attempt to
communicate what the Zariski topology looks like, from the perspectives
that tickle my fancy (a wealth of concrete examples,
topology-as-semi-decidability, and pictures).
<h4><a id=the-zariski-topology href='#the-zariski-topology'> § </a> The Zariski topology</h4>
Recall that the Zariski topology is defined by talking about what its
closed sets are. The common zero sets of a family of polynomials are
the closed sets of the Zariski topology. Formally, the topology <span class='latexinline'>
(&#X211D;<sup><span style="font-style:italic">n</span></sup>, &#X3C4;)</span>
has as closed sets:
<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">{&#XA0;<span style="font-style:italic">x</span>&#XA0;&#X2208;&#XA0;&#X211D;<sup><span style="font-style:italic">n</span></sup>&#XA0;:&#XA0;&#X2200;&#XA0;<span style="font-style:italic">f</span><sub><span style="font-style:italic">i</span></sub>&#XA0;&#X2208;&#XA0;&#X211D;[<span style="font-style:italic">X</span><sub>1</sub>,&#XA0;<span style="font-style:italic">X</span><sub>2</sub>,&#XA0;&#X2026;&#XA0;<span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub>],&#XA0;&#XA0;<span style="font-style:italic">f</span><sub><span style="font-style:italic">i</span></sub>(<span style="font-style:italic">x</span>)&#XA0;=&#XA0;0&#XA0;&#XA0;}
</td></tr>
</table></div>
Open sets (the complement of closed sets) are of them form:
<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">{&#XA0;<span style="font-style:italic">x</span>&#XA0;&#X2208;&#XA0;&#X211D;<sup><span style="font-style:italic">n</span></sup>&#XA0;:&#XA0;&#X2203;&#XA0;<span style="font-style:italic">f</span><sub><span style="font-style:italic">i</span></sub>&#XA0;&#X2208;&#XA0;&#X211D;[<span style="font-style:italic">X</span><sub>1</sub>,&#XA0;<span style="font-style:italic">X</span><sub>2</sub>,&#XA0;&#X2026;&#XA0;<span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub>],&#XA0;&#XA0;<span style="font-style:italic">f</span><sub><span style="font-style:italic">i</span></sub>(<span style="font-style:italic">x</span>)&#XA0;&#X2260;&#XA0;0&#XA0;&#XA0;}&#XA0;&#X2208;&#XA0;&#X3C4;
</td></tr>
</table></div>
The empty set is generated as <span class='latexinline'>
{ <span style="font-style:italic">x</span> &#X2208; &#X211D;<sup><span style="font-style:italic">n</span></sup> : 0 &#X2260; 0 }</span> and the
full set is generated as <span class='latexinline'>
{ <span style="font-style:italic">x</span> &#X2208; &#X211D;<sup><span style="font-style:italic">n</span></sup> : 1 &#X2260; 0 }</span>.
<h4><a id=semi-decidability href='#semi-decidability'> § </a> Semi-decidability</h4>
Recall that in this view of topology, for a space <span class='latexinline'>
(<span style="font-style:italic">X</span>, &#X3C4;)</span>, for every
open set <span class='latexinline'>
<span style="font-style:italic">O</span> &#X2208; &#X3C4;</span>, we associate a turing machine <span class='latexinline'>
<span style="font-style:italic">T</span><sub><span style="font-style:italic">O</span></sub></span>.
which obeys the relation:
<div class='latexblock'><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">x</span></td><td style="text-align:left;white-space:nowrap" >&#XA0;&#XA0;&#XA0;&#XA0;</td><td style="text-align:right;white-space:nowrap" >&#X2208;&#XA0;<span style="font-style:italic">O</span>&#XA0;&#XA0;&#X21D0;&#X21D2;&#XA0;<span style="font-style:italic">T</span><sub><span style="font-style:italic">O</span></sub> halts on input <span style="font-style:italic">x</span>&#XA0;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >
<span style="font-style:italic">x</span></td><td style="text-align:left;white-space:nowrap" >&#XA0;&#XA0;&#XA0;&#XA0;</td><td style="text-align:right;white-space:nowrap" >&#X2209;<span style="font-style:italic">O</span>&#XA0;&#XA0;&#X21D0;&#X21D2;&#XA0;<span style="font-style:italic">T</span><sub><span style="font-style:italic">O</span></sub> does not halts on input <span style="font-style:italic">o</span>
</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table>
</div>
<h4><a id=geometry--1d href='#geometry--1d'> § </a> Geometry --- 1D</h4>
Let's consider functions of the form <span class='latexinline'>
(&#X211D;<sup>2</sup>, <span style="font-style:italic">Z</span>) &#X2192;<sup><span style="font-style:italic">f</span></sup> (&#X211D;<sup>2</sup>, <span style="font-style:italic">Z</span>)</span>
where <span class='latexinline'>
<span style="font-style:italic">Z</span></span> is the Zariski topology. We are interested in discovering what
sort of functions <span class='latexinline'>
<span style="font-style:italic">f</span></span> are continuous.
<h4><a id=geometry--2d href='#geometry--2d'> § </a> Geometry --- 2D</h4>
Let's repeat the exercise for 2D. Here, we will manage to see much richer
behaviour. Let's consider functions of the form
<span class='latexinline'>
(&#X211D;<sup>2</sup>, <span style="font-style:italic">Z</span>) &#X2192;<sup><span style="font-style:italic">f</span></sup> (&#X211D;<sup>2</sup>, <span style="font-style:italic">Z</span>)</span> where
<span class='latexinline'>
<span style="font-style:italic">Z</span></span> is the Zariski topology.
<h3><a id=my-preferred-version-of-quicksort href='#my-preferred-version-of-quicksort'> § </a> <a href=#my-preferred-version-of-quicksort>
My preferred version of quicksort</a>
</h3>
Wikipedia lists the implementation of quicksort as:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> algorithm quicksort(A, lo, hi) is
<font color="#000000">03:</font>     <b><u><font color="#000000">if</font></u></b> lo &lt; hi then
<font color="#000000">04:</font>         p := partition(A, lo, hi)
<font color="#000000">05:</font>         quicksort(A, lo, p - <font color="#000000">1</font>)
<font color="#000000">06:</font>         quicksort(A, p + <font color="#000000">1</font>, hi)
<font color="#000000">07:</font> 
<font color="#000000">08:</font> algorithm partition(A, lo, hi) is
<font color="#000000">09:</font>     pivot := A[hi]
<font color="#000000">10:</font>     i := lo
<font color="#000000">11:</font>     <b><u><font color="#000000">for</font></u></b> j := lo to hi <b><u><font color="#000000">do</font></u></b>
<font color="#000000">12:</font>         <b><u><font color="#000000">if</font></u></b> A[j] &lt; pivot then
<font color="#000000">13:</font>             swap A[i] with A[j]
<font color="#000000">14:</font>             i := i + <font color="#000000">1</font>
<font color="#000000">15:</font>     swap A[i] with A[hi]
<font color="#000000">16:</font>     <b><u><font color="#000000">return</font></u></b> i
<font color="#000000">17:</font> </tt></pre>
</div>

Here, the indeces <code>[lo..i-1]</code> have values less than the pivot, while
<code>[i..j]</code> are great or equal to the pivot.
<h4><a id=the-version-i-prefer href='#the-version-i-prefer'> § </a> The version I prefer</h4>
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> <i><font color="#222222">// #define SWAP(ix, ix2) { int t = a[ix]; a[ix] = a[ix2]; a[ix2] = t; }</font></i>
<font color="#000000">03:</font> <i><font color="#222222">// sorts the interval [l, r]</font></i>
<font color="#000000">04:</font> <b><font color="#000000">void</font></b> qs(<b><font color="#000000">int</font></b> l, <b><font color="#000000">int</font></b> r) {
<font color="#000000">05:</font>     <b><u><font color="#000000">if</font></u></b> (r - l &lt; <font color="#000000">0</font>) <b><u><font color="#000000">return</font></u></b>;
<font color="#000000">06:</font>     <b><font color="#000000">int</font></b> part = a[r]; <i><font color="#222222">// the partition</font></i>
<font color="#000000">07:</font> 
<font color="#000000">08:</font>     <i><font color="#222222">// a[getill...n] &gt;= part (getill = greater or equal till)</font></i>
<font color="#000000">09:</font>     <i><font color="#222222">// starts at r since we know that a[r] &gt;= (partition=a[r])</font></i>
<font color="#000000">10:</font>     <b><font color="#000000">int</font></b> getill = r;
<font color="#000000">11:</font>     <i><font color="#222222">// a[l..lttill] &lt; part (lttill = less or equal till.</font></i>
<font color="#000000">12:</font>     <i><font color="#222222">// starts at (l-1) since we do not know about any value &lt; partition</font></i>
<font color="#000000">13:</font>     <b><font color="#000000">int</font></b> lttill = l-<font color="#000000">1</font>;
<font color="#000000">14:</font> 
<font color="#000000">15:</font> 
<font color="#000000">16:</font>     <i><font color="#222222">// loop until they start probing into the other set</font></i>
<font color="#000000">17:</font>     <b><u><font color="#000000">while</font></u></b>(!(lttill+<font color="#000000">1</font> &gt;=getill || getill-<font color="#000000">1</font> &lt;=lttill)) {
<font color="#000000">18:</font>         <i><font color="#222222">// if the speculated element is &lt; partition</font></i>
<font color="#000000">19:</font>         <b><u><font color="#000000">if</font></u></b> (a[getill-<font color="#000000">1</font>] &lt; part) {
<font color="#000000">20:</font>             <i><font color="#222222">// swap the value at getill-1 will the slot at lttill+1</font></i>
<font color="#000000">21:</font>             SWAP(getill-<font color="#000000">1</font>, lttill+<font color="#000000">1</font>);
<font color="#000000">22:</font>             <i><font color="#222222">// increment lttill, since we KNOW that the</font></i>
<font color="#000000">23:</font>             <i><font color="#222222">// value at lttill+1 = a[getill-1] is &lt; part</font></i>
<font color="#000000">24:</font>             lttill++;
<font color="#000000">25:</font>         } <b><u><font color="#000000">else</font></u></b> {
<font color="#000000">26:</font>             <i><font color="#222222">// all we know is that a[getill-1] &lt; part, so we can engulf</font></i>
<font color="#000000">27:</font>             <i><font color="#222222">// the region into</font></i>
<font color="#000000">28:</font>             getill--;
<font color="#000000">29:</font>         }
<font color="#000000">30:</font>     }
<font color="#000000">31:</font>     <i><font color="#222222">// the partitions must be next to each other, since we have engulfed everything</font></i>
<font color="#000000">32:</font>     assert(getill - lttill == <font color="#000000">1</font>);
<font color="#000000">33:</font>     <i><font color="#222222">// move the partition value to the center.</font></i>
<font color="#000000">34:</font>     SWAP(getill, r);
<font color="#000000">35:</font> 
<font color="#000000">36:</font>     <i><font color="#222222">// recurse:solve [l..littil] (leave getill=part alone) solve [getill+1..r]</font></i>
<font color="#000000">37:</font>     qs(l, lttill);
<font color="#000000">38:</font>     qs(getill+<font color="#000000">1</font>, r);
<font color="#000000">39:</font> }
<font color="#000000">40:</font> </tt></pre>
</div>

This implementation to me makes very clear to me what information is "known":
<ul>
<li>
 The segments that is strictly less than the partition.
</li>
<li>
 The segment that is strictly great or equal the partition.
</li>

</ul>

It also makes clear what is being "probed"/"tentative":
<ul>
<li>
 anything we are accessing as <code>+-1</code> is not known yet, we are feeling out
  the boundaries of our partitions.
</li>

</ul>

The termination condition is clear: when one partition starts reaching into
the other partitions resources, its done.
Due to using closed intervals everywhere, it's very easy to see precisely
what data starts and ends where.
What version of quicksort do you prefer? Drop me an email!
<h3><a id=geometric-proof-of-cauchy-schwarz-inequality href='#geometric-proof-of-cauchy-schwarz-inequality'> § </a> <a href=#geometric-proof-of-cauchy-schwarz-inequality>
Geometric proof of Cauchy Schwarz inequality</a>
</h3>
<img src="./static/cauchy-schwarz.svg">
<ul>
<li>
 All credit goes to <code>p0a</code> on <code>##math</code> on freenode for teaching me this proof!
</li>

</ul>

Here's one fun application of Cauchy-Schwarz. We can apply it to two vectors
<span class='latexinline'>
<span style="font-style:italic">x</span>=(&#X221A;<span style="text-decoration:overline"><span style="font-style:italic">a</span></span>, &#X221A;<span style="text-decoration:overline"><span style="font-style:italic">b</span></span>)</span> and <span class='latexinline'>
<span style="font-style:italic">y</span>=(&#X221A;<span style="text-decoration:overline"><span style="font-style:italic">b</span></span>, &#X221A;<span style="text-decoration:overline"><span style="font-style:italic">a</span></span>)</span> to derive the AM-GM
inequality:
<h3><a id=dataflow-analysis-using-grobner-basis href='#dataflow-analysis-using-grobner-basis'> § </a> <a href=#dataflow-analysis-using-grobner-basis>
Dataflow analysis using Grobner basis</a>
</h3>
This was a quick experiment in using Grobner basis to model situations. We
can represent our dataflow analysis constraints in terms of polynomial
rewrites over <span class='latexinline'>
<span style="font-style:italic">F</span><sub>2</sub></span>.
Given the program:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> p = { <font color="#000000">0</font>: [<font color="#808080">"="</font>, <font color="#808080">"x"</font>, <font color="#808080">'y'</font>],
<font color="#000000">3:</font>       <font color="#000000">1</font>: [<font color="#808080">'br'</font>, <font color="#000000">2</font>, <font color="#000000">100</font>],
<font color="#000000">4:</font>       <font color="#000000">2</font>: [<font color="#808080">'='</font>, <font color="#808080">'z'</font>, <font color="#808080">'x'</font>],
<font color="#000000">5:</font>       <font color="#000000">3</font>: [<font color="#808080">'br'</font>, <font color="#000000">2</font>],
<font color="#000000">6:</font>       <font color="#000000">100</font>: [<font color="#808080">'ret'</font>, <font color="#808080">'z'</font>] }
<font color="#000000">7:</font> </tt></pre>
</div>

whose semantics I hope are fairly straightforward --- the dictionary represents
instruction locations. Instructions proceed sequentially. branch moves
control flow around. Note that <code>br</code> can branch to multiple locations,
since we are not control-flow sensitive.
The idea is that since in a dataflow analysis, we need information at
each variable at each program point, we can create a ring of polynomials
over <span class='latexinline'>
<span style="font-style:italic">F</span><sub>2</sub></span> for each variable at each program point. So in this case,
we wold need:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> R = F_2[x0, y0, z0, x1, y1, z1, x2, y2, z2, x3, y3, z3, x100, y100, z100]
<font color="#000000">3:</font> </tt></pre>
</div>

We then add elements into the ideal that represents our constraints.
For example, to perform dataflow analysis, we need to add constraints
about how if a variable <code>z</code> is alive, all variables that are used
to compute <code>z</code> at <code>100</code> are alive. This sets up equations that may
have cycles (in the case of loops).
These are usually resolved using the
<a href=https://en.wikipedia.org/wiki/Data-flow_analysis#An_iterative_algorithm>
Kildall algorithm</a>
.
However, we can also ask SAGE to kindly solve the Grobner basis. I hypothesize
that the "easy" dataflow problems out to be <a href=https://hal.inria.fr/inria-00074446/document>
toric ideals</a>

which admit much faster solutions.
<h3><a id=fenwick-trees-and-orbits href='#fenwick-trees-and-orbits'> § </a> <a href=#Fenwick-trees-and-orbits>
Fenwick trees and orbits</a>
</h3>
I learnt of a nice, formal way to prove the correctness of Fenwick
trees in terms of orbits that I wish to reproduce here.
One can use a Fenwick tree to perform cumulative sums
<span class='latexinline'>
<span style="font-style:italic">Sum</span>(<span style="font-style:italic">n</span>) &#X2261; &#X2211;<sub><span style="font-style:italic">i</span></sub><sup><span style="font-style:italic">n</span></sup> <span style="font-style:italic">A</span>[<span style="font-style:italic">i</span>]</span>, and updates <span class='latexinline'>
<span style="font-style:italic">Upd</span>(<span style="font-style:italic">i</span>, <span style="font-style:italic">v</span>) &#X2261; <span style="font-style:italic">A</span>[<span style="font-style:italic">i</span>] += <span style="font-style:italic">v</span></span>. Naively,
cumulative sums can take <span class='latexinline'>
<span style="font-style:italic">O</span>(<span style="font-style:italic">n</span>)</span> time and updates take <span class='latexinline'>
<span style="font-style:italic">O</span>(1)</span> time.
A Fenwick tree can perform <i>both</i> in <span class='latexinline'>
log(<span style="font-style:italic">n</span>)</span>. In general, we can perform
any monoid-based catenation and update in <span class='latexinline'>
log(<span style="font-style:italic">n</span>)</span>.
<h4><a id=organization href='#organization'> § </a> organization</h4>
We allow indexes <span class='latexinline'>
[1, 2, &#X2026; <span style="font-style:italic">n</span>]</span>. The node with factorization <span class='latexinline'>
<span style="font-style:italic">i</span> &#X2261; 2<sup><span style="font-style:italic">k</span></sup> &#XD7; <span style="font-style:italic">l</span></span>,
<span class='latexinline'>
2 &#XAC;|<span style="font-style:italic">l</span></span> (that is, <span class='latexinline'>
<span style="font-style:italic">k</span></span> is the highest power of <span class='latexinline'>
2</span> in <span class='latexinline'>
<span style="font-style:italic">i</span></span>)
is responsible for the interval <span class='latexinline'>
[<span style="font-style:italic">i</span>&#X2212;2<sup><span style="font-style:italic">k</span></sup>+1, <span style="font-style:italic">i</span>] = (<span style="font-style:italic">i</span>&#X2212;2<sup><span style="font-style:italic">k</span></sup>, <span style="font-style:italic">i</span>]</span>.
I'm going to state all the manipulations in terms of prime factorizations,
since I find it far more intuitive than bit-fiddling. In general, I want
to find a new framework to discover and analyze bit-fiddling heavy algorithms.
Some examples of the range of responsibility of an index are:
<ul>
<li>
 <span class='latexinline'>
1 = 2<sup>0</sup> &#XD7; 1 = (0, 1]</span> (Subtract <span class='latexinline'>
2<sup>0</sup> = 1</span>)
</li>
<li>
 <span class='latexinline'>
2 = 2&#XD7; 1 = (0, 2]</span> (Subtract <span class='latexinline'>
2<sup>1</sup> = 2</span>)
</li>
<li>
 <span class='latexinline'>
3 = 3 = (2, 3]</span>
</li>
<li>
 <span class='latexinline'>
4 = 2<sup>2</sup> = (0, 4]</span>
</li>
<li>
 <span class='latexinline'>
5 = 5 = (4, 5]</span>
</li>
<li>
 <span class='latexinline'>
6 = 2&#XD7; 3 = (4, 6]</span>
</li>
<li>
 <span class='latexinline'>
7 = 7 = (6,7]</span>
</li>
<li>
 <span class='latexinline'>
8 = 2<sup>3</sup> = (0,8]</span>
</li>
<li>
 <span class='latexinline'>
9 = 9 = (8, 9]</span>
</li>
<li>
 <span class='latexinline'>
10 = 2&#XD7; 5 = (8, 10]</span>
</li>
<li>
 <span class='latexinline'>
11 = 11 = (10, 11]</span>
</li>
<li>
 <span class='latexinline'>
12 = 2<sup>2</sup>&#XD7; 3 = (8, 12]</span>
</li>
<li>
 <span class='latexinline'>
13 = 13 = (12, 13]</span>
</li>
<li>
 <span class='latexinline'>
14 = 2&#XD7; 7 = (12, 14]</span>
</li>
<li>
 <span class='latexinline'>
15 = 15 = (14, 15]</span>
</li>
<li>
 <span class='latexinline'>
16 = 2<sup>4</sup> = (0, 16]</span>
</li>

</ul>

<img width=300 src="./static/fenwick-structure.gif">
<h4><a id=query href='#query'> § </a> query</h4>
To perform a cumulative sum, we need to read from the correct overlap regions
that cover the full array. For example, to read from <span class='latexinline'>
15</span>, we would want
to read:
<ul>
<li>
 <span class='latexinline'>
<span style="font-style:italic">a</span>[15] = (14, 15], <span style="font-style:italic">a</span>[14] = (12, 14], <span style="font-style:italic">a</span>[12] = (8, 12], <span style="font-style:italic">a</span>[8] = (0, 8]</span>.
</li>

</ul>

So we need to read the indices:
<ul>
<li>
 <span class='latexinline'>
15=2<sup>0</sup> &#XB7; 15 &#X2192;<sup>&#X2212;2<sup>0</sup></sup> 14=2<sup>1</sup> &#XB7; 7 &#X2192;<sup>&#X2212;2<sup>1</sup></sup> 12=2<sup>2</sup>&#XB7;3 &#X2192;<sup>&#X2212;2<sup>2</sup></sup> 8=2<sup>3</sup>&#XB7;1 &#X2192;<sup>&#X2212;2<sup>3</sup></sup> 0</span>
</li>

</ul>

At each  location, we strip off the value <span class='latexinline'>
2<sup><span style="font-style:italic">r</span></sup></span>. We can discover this value
with bit-fiddling: We claim that <span class='latexinline'>
<span style="font-style:italic">a</span> &amp; (&#X2212;<span style="font-style:italic">a</span>) = 2<sup><span style="font-style:italic">r</span></sup></span>.
Let <span class='latexinline'>
<span style="font-style:italic">a</span> = <span style="font-style:italic">x</span> 1 0<sup><span style="font-style:italic">r</span></sup></span>. Now, <span class='latexinline'>
&#X2212;<span style="font-style:italic">a</span> = &#XAC; <span style="font-style:italic">a</span> + 1 = <span style="font-style:italic">x</span>01<sup><span style="font-style:italic">r</span></sup> + 1 = <span style="text-decoration:overline"><span style="font-style:italic">x</span></span>10<sup><span style="font-style:italic">r</span></sup></span>.
Hence, <span class='latexinline'>
<span style="font-style:italic">a</span> &amp; (&#X2212;<span style="font-style:italic">a</span>) = <span style="font-style:italic">a</span> &amp; (&#XAC; <span style="font-style:italic">a</span> + 1) = (<span style="font-style:italic">x</span> 10<sup><span style="font-style:italic">r</span></sup>) &amp; (10<sup><span style="font-style:italic">r</span></sup>) = 0<sup>|&#X3B1;|</sup>10<sup><span style="font-style:italic">r</span></sup> = 2<sup><span style="font-style:italic">r</span></sup></span>
So the full implementation of query is:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> <b><u><font color="#000000">#define</font></u></b> LSB(x) x&amp;(-x)
<font color="#000000">3:</font> <b><font color="#000000">int</font></b> a[N];
<font color="#000000">4:</font> <b><font color="#000000">int</font></b> q(<b><font color="#000000">int</font></b> i) {
<font color="#000000">5:</font>     <b><font color="#000000">int</font></b> s = <font color="#000000">0</font>;
<font color="#000000">6:</font>     <b><u><font color="#000000">while</font></u></b> (i &gt; <font color="#000000">0</font>) { s += a[i]; i -= LSB(i); }
<font color="#000000">7:</font>     <b><u><font color="#000000">return</font></u></b> s;
<font color="#000000">8:</font> }
<font color="#000000">9:</font> 
<font color="#000000">10:</font> </tt></pre>
</div>

<h4><a id=update href='#update'> § </a> update</h4>
To perform an update at <span class='latexinline'>
<span style="font-style:italic">i</span></span>, we need to update all locations which on querying
overlap with <span class='latexinline'>
<span style="font-style:italic">i</span></span>. For example, to update the location <span class='latexinline'>
9</span>, we would want to
update:
<ul>
<li>
 <span class='latexinline'>
<span style="font-style:italic">a</span>[9] = (8, 9], <span style="font-style:italic">a</span>[10] = (8, 10], <span style="font-style:italic">a</span>[12] = (8, 12], <span style="font-style:italic">a</span>[16] = (0, 16]</span>.
</li>

</ul>

So we need to update the indices:
<ul>
<li>
 <span class='latexinline'>
9=2<sup>0</sup> &#XB7; 9 &#X2192;<sup>+2<sup>0</sup></sup> 10=2<sup>1</sup> &#XB7; 5 &#X2192;<sup>+2<sup>1</sup></sup> 12=2<sup>2</sup>&#XB7;3 &#X2192;<sup>+2<sup>2</sup></sup> 16=2<sup>4</sup>&#XB7;1 &#X2192;<sup>+2<sup>4</sup></sup> &#X2026;</span>
</li>

</ul>

We use the same bit-fiddling technique as above to strip off the value <span class='latexinline'>
2<sup><span style="font-style:italic">r</span></sup></span>
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> <b><u><font color="#000000">#define</font></u></b> LSB(x) x&amp;(-x)
<font color="#000000">3:</font> <b><font color="#000000">int</font></b> tree[N];
<font color="#000000">4:</font> <b><font color="#000000">int</font></b> u(<b><font color="#000000">int</font></b> i, <b><font color="#000000">int</font></b> v) {
<font color="#000000">5:</font>     <b><u><font color="#000000">while</font></u></b> (i &lt; N) { tree[i] += v; i += LSB(i); }
<font color="#000000">6:</font> }
<font color="#000000">7:</font> </tt></pre>
</div>

<h4><a id=correctness href='#correctness'> § </a> correctness</h4>
We wish to analyze the operations <span class='latexinline'>
<span style="font-style:italic">Query</span>(<span style="font-style:italic">q</span>) &#X2261; &#X2211;<sub><span style="font-style:italic">i</span>=1</sub><sup><span style="font-style:italic">q</span></sup> <span style="font-style:italic">a</span>[<span style="font-style:italic">i</span>]</span>, and
<span class='latexinline'>
<span style="font-style:italic">Update</span>(<span style="font-style:italic">i</span>, <span style="font-style:italic">val</span>) &#X2261; <span style="font-style:italic">a</span>[<span style="font-style:italic">i</span>]&#XA0;<span style="font-family:monospace">+=</span>&#XA0;<span style="font-style:italic">val</span></span>. To do this, we are allowed to maintain
an auxiliary array <span class='latexinline'>
<span style="font-style:italic">d</span></span> which we will manipuate. We will stipulate the
conditions of operations on <span class='latexinline'>
<span style="font-style:italic">d</span></span> such that they will reflect the values of
<span class='latexinline'>
<span style="font-style:italic">Query</span></span> and <span class='latexinline'>
<span style="font-style:italic">Update</span></span>, albeit much faster.
We will analyze the algorithm in terms of orbits. We have two operators, one
for update called <span class='latexinline'>
<span style="font-style:italic">U</span></span>, and one for query called <span class='latexinline'>
<span style="font-style:italic">Q</span></span>. Given an index <span class='latexinline'>
<span style="font-style:italic">i</span></span>,
repeatedly applying the query operator gives us the indeces we need to read and
accumulate from the underlying array <span class='latexinline'>
<span style="font-style:italic">a</span></span> to get the total sum <span class='latexinline'>
<span style="font-style:italic">a</span>[0..<span style="font-style:italic">i</span>]</span>:
<ul>
<li>
 <span class='latexinline'>
<span style="font-style:italic">Query</span>(<span style="font-style:italic">i</span>) = &#X2211;<sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">d</span>[<span style="font-style:italic">Q</span><sup><span style="font-style:italic">i</span></sup>(<span style="font-style:italic">q</span>)]</span>
</li>

</ul>

Given an index <span class='latexinline'>
<span style="font-style:italic">u</span></span>, repeatedly applying the update operator <span class='latexinline'>
<span style="font-style:italic">U</span></span> gives us all
the indeces we need to add the change to update:
<ul>
<li>
 <span class='latexinline'>
<span style="font-style:italic">Update</span>(<span style="font-style:italic">i</span>, <span style="font-style:italic">val</span>) = &#X2200; <span style="font-style:italic">j</span>&#XA0;, <span style="font-style:italic">d</span>[<span style="font-style:italic">U</span><sup><span style="font-style:italic">j</span></sup>(<span style="font-style:italic">i</span>)]&#XA0;<span style="font-family:monospace">+=</span>&#XA0; <span style="font-style:italic">val</span></span>
</li>

</ul>

For query and update to work, we need the condition that:
<ul>
<li>
 <span class='latexinline'>
<span style="font-style:italic">q</span> &#X2265; <span style="font-style:italic">u</span> &#XA0;&#X21D0;&#X21D2;&#XA0;|{ <span style="font-style:italic">Q</span><sup><span style="font-style:italic">i</span></sup>(<span style="font-style:italic">q</span>)&#XA0;:&#XA0; <span style="font-style:italic">i</span> &#X2208; &#X2115; } &#X2229; { <span style="font-style:italic">U</span><sup><span style="font-style:italic">i</span></sup>(<span style="font-style:italic">u</span>)&#XA0;:&#XA0;<span style="font-style:italic">i</span> &#X2208; &#X2115; } |= 1</span>
</li>

</ul>

That is, if and only if the query index <span class='latexinline'>
<span style="font-style:italic">q</span></span> includes the update location <span class='latexinline'>
<span style="font-style:italic">u</span></span>,
will the orbits intersect.
The intuition is that we want updates at an index <span class='latexinline'>
<span style="font-style:italic">u</span></span> to only affect queries
that occur at indeces <span class='latexinline'>
<span style="font-style:italic">q</span> &#X2265; <span style="font-style:italic">u</span></span>. Hence, we axiomatise that for an update
to be legal, it must the orbits of queries that are at indeces greater than it.
We will show that our operators:
<ul>
<li>
 <span class='latexinline'>
<span style="font-style:italic">Q</span>(<span style="font-style:italic">i</span>=2<sup><span style="font-style:italic">r</span></sup>&#XB7; <span style="font-style:italic">a</span>) = <span style="font-style:italic">i</span> &#X2212; 2<sup><span style="font-style:italic">r</span></sup> = 2<sup><span style="font-style:italic">r</span></sup>(<span style="font-style:italic">a</span>&#X2212;1)</span>
</li>
<li>
 <span class='latexinline'>
<span style="font-style:italic">U</span>(<span style="font-style:italic">j</span>=2<sup><span style="font-style:italic">s</span></sup>&#XB7; <span style="font-style:italic">b</span>) = <span style="font-style:italic">j</span> + 2<sup><span style="font-style:italic">s</span></sup> = 2<sup><span style="font-style:italic">s</span></sup>(<span style="font-style:italic">b</span>+1)</span>
</li>

</ul>

do satisfy the conditions above.
For a quick numerical check, we can use the code blow to ensure
that the orbits are indeed disjoint:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> <i><font color="#222222">## calculate orbits of query and update in fenwick tree</font></i>
<font color="#000000">03:</font> 
<font color="#000000">04:</font> <b><u><font color="#000000">def</font></u></b> lsb(i): <b><u><font color="#000000">return</font></u></b> i &amp; (-i)
<font color="#000000">05:</font> <b><u><font color="#000000">def</font></u></b> U(i): <b><u><font color="#000000">return</font></u></b> i + lsb(i)
<font color="#000000">06:</font> <b><u><font color="#000000">def</font></u></b> Q(i): <b><u><font color="#000000">return</font></u></b> i - lsb(i)
<font color="#000000">07:</font> <b><u><font color="#000000">def</font></u></b> orbit(f, i):
<font color="#000000">08:</font>     s = set()
<font color="#000000">09:</font>     <b><u><font color="#000000">while</font></u></b> i <b><u><font color="#000000">not</font></u></b> <b><u><font color="#000000">in</font></u></b> s <b><u><font color="#000000">and</font></u></b> i &gt; <font color="#000000">0</font> <b><u><font color="#000000">and</font></u></b> i &lt; <font color="#000000">64</font>:
<font color="#000000">10:</font>         s.add(i); i = f(i)
<font color="#000000">11:</font>     <b><u><font color="#000000">return</font></u></b> s
<font color="#000000">12:</font> 
<font color="#000000">13:</font> <b><u><font color="#000000">if</font></u></b> __name__ == <font color="#808080">"__main__"</font>:
<font color="#000000">14:</font>     <b><u><font color="#000000">for</font></u></b> q <b><u><font color="#000000">in</font></u></b> range(<font color="#000000">1</font>, <font color="#000000">16</font>):
<font color="#000000">15:</font>         <b><u><font color="#000000">for</font></u></b> u <b><u><font color="#000000">in</font></u></b> range(<font color="#000000">1</font>, <font color="#000000">16</font>):
<font color="#000000">16:</font>             qo = orbit(Q, q); uo = orbit(U, u)
<font color="#000000">17:</font>             c = qo.intersection(uo)
<font color="#000000">18:</font>             <b><u><font color="#000000">print</font></u></b>(<font color="#808080">"q:%4s | u:%4s | qo: %20s | uo: %20s | qu: %4s"</font> %
<font color="#000000">19:</font>                   (q, u, qo, uo, c))
<font color="#000000">20:</font> 
<font color="#000000">21:</font>         <b><u><font color="#000000">print</font></u></b>(<font color="#808080">"--"</font>)
<font color="#000000">22:</font> </tt></pre>
</div>

<h4><a id=q-u-1- href='#q-u-1-'> § </a> Case 1: <span class='latexinline'>
<span style="font-style:italic">q</span> = <span style="font-style:italic">u</span></span></h4>
We note that <span class='latexinline'>
<span style="font-style:italic">Q</span></span> always decreases the value of <span class='latexinline'>
<span style="font-style:italic">q</span></span>, and <span class='latexinline'>
<span style="font-style:italic">u</span></span> always increases
it. Hence, if <span class='latexinline'>
<span style="font-style:italic">q</span> = <span style="font-style:italic">u</span></span>, they meet at this point, and
<span class='latexinline'>
&#X2200; <span style="font-style:italic">i</span>, <span style="font-style:italic">j</span> &#X2265; 1, &#XA0;&#XA0; <span style="font-style:italic">Q</span><sup><span style="font-style:italic">i</span></sup> (<span style="font-style:italic">q</span>) &#X2260; <span style="font-style:italic">U</span><sup><span style="font-style:italic">j</span></sup>(<span style="font-style:italic">u</span>)</span>.
Hence, they meet exactly once as required.
<h4><a id=q-u-2- href='#q-u-2-'> § </a> Case 2: <span class='latexinline'>
<span style="font-style:italic">q</span> &lt; <span style="font-style:italic">u</span></span></h4>
As noted above, <span class='latexinline'>
<span style="font-style:italic">q</span></span> always decreases and <span class='latexinline'>
<span style="font-style:italic">u</span></span> always increases, hence in this
case they will never meet as required.
<h4><a id=q-u-3- href='#q-u-3-'> § </a> Case 3: <span class='latexinline'>
<span style="font-style:italic">q</span> &gt; <span style="font-style:italic">u</span></span></h4>
Let the entire array have size <span class='latexinline'>
2<sup><span style="font-style:italic">N</span></sup></span>.
Let <span class='latexinline'>
<span style="font-style:italic">q</span> = <span style="font-family:monospace">e1 f_q</span>, <span style="font-style:italic">u</span> = <span style="font-family:monospace">e0 f_u</span></span>, where
<span class='latexinline'>
<span style="font-family:monospace">e, f_q, f_u</span></span> may be empty strings.
Notice that <span class='latexinline'>
<span style="font-style:italic">Q</span></span> will always strip away rightmost ones in <span class='latexinline'>
<span style="font-style:italic">f</span><sub><span style="font-style:italic">q</span></sub></span>,
leading to <span class='latexinline'>
<span style="font-style:italic">q</span> = <span style="font-family:monospace">e10...0</span></span> at some point.
Similarly, <span class='latexinline'>
<span style="font-style:italic">U</span></span> will keep on adding new rightmost ones, causing the
state to be <span class='latexinline'>
<span style="font-style:italic">u</span> = <span style="font-family:monospace">e01...10...0</span> &#X2192;<sup><span style="font-style:italic">U</span></sup> <span style="font-family:monospace">e100...</span></span>.
Hence, at some point <span class='latexinline'>
<span style="font-style:italic">q</span> = <span style="font-style:italic">u</span></span>.
<h4><a id=references href='#references'> § </a> References</h4>
<ul>
<li>
 <a href=http://michaelnielsen.org/polymath1/index.php?title=Updating_partial_sums_with_Fenwick_tree>
Fenwick trees on PolyMath</a>

</li>
<li>
 <a href=https://doc.lagout.org/security/Hackers%20Delight.pdf>
Hacker's delight</a>

</li>

</ul>

<h3><a id=dirichlet-inversion href='#dirichlet-inversion'> § </a> <a href=#Dirichlet-inversion>
Dirichlet inversion</a>
</h3>
We call all functions <span class='latexinline'>
<span style="font-style:italic">f</span>: &#X2124; &#X2192; &#X211D;</span> as
<i>arithmetic functions</i>, since they operate on the integers.
We introduce an operator <span class='latexinline'>
<span style="font-style:italic">f</span> &#X22C6; <span style="font-style:italic">g</span>: &#X2124; &#X2192; &#X211D;</span>.
It is defined by:
<ul>
<li>
 <span class='latexinline'>
(<span style="font-style:italic">f</span> &#X22C6; <span style="font-style:italic">g</span>)(<span style="font-style:italic">n</span>) &#X2261; &#X2211;<sub><span style="font-style:italic">d</span> | <span style="font-style:italic">n</span></sub> <span style="font-style:italic">f</span>(<span style="font-style:italic">d</span>) <span style="font-style:italic">g</span>(<span style="font-style:italic">n</span>/<span style="font-style:italic">d</span>)</span>
</li>

</ul>

We will show that the set of arithmetic functions forms a group
under the operator <span class='latexinline'>
&#X22C6;</span>, with identity:
<ul>
<li>
  <span class='latexinline'>
<span style="font-style:italic">id</span><sub>&#X22C6;</sub>(<span style="font-style:italic">n</span>) &#X2261; 1/<span style="font-style:italic">n</span> = {<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >1</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">n</span>&#XA0;=&#XA0;1&#XA0;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >0</td><td style="text-align:left;white-space:nowrap" >otherwise&#XA0;</td></tr>
</table></span>
</li>

</ul>

The reason all of this is interesting is that the inverse of the constant function <span class='latexinline'>
1(<span style="font-style:italic">n</span>) &#X2261; 1</span>
is going to be this function called as the mobius function <span class='latexinline'>
&#XB5;</span>:
<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">&#XB5;(<span style="font-style:italic">n</span>=<span style="font-style:italic">p</span><sub>1</sub><sup>&#X3B1;</sup><sub>1</sub>&#XA0;<span style="font-style:italic">p</span><sub>2</sub><sup>&#X3B1;</sup><sub>2</sub>&#XA0;&#X2026;&#XA0;<span style="font-style:italic">p</span><sub><span style="font-style:italic">r</span></sub><sup>&#X3B1;</sup><sub><span style="font-style:italic">r</span></sub>)&#XA0;&#X2261;
</td><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell">&#X23A7;<br>
&#X23A8;<br>
&#X23A9;</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >&#XA0;&#XA0;0</td><td style="text-align:left;white-space:nowrap" >if any &#X3B1;<sub><span style="font-style:italic">i</span></sub> &gt; 1&#XA0;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&#XA0;&#XA0;(&#X2212;1)<sup>&#X3B1;<sub>1</sub>&#XA0;+&#XA0;&#X3B1;<sub>2</sub>&#XA0;+&#XA0;&#X2026;&#XA0;+&#XA0;&#X3B1;<sub><span style="font-style:italic">r</span></sub></sup></td><td style="text-align:left;white-space:nowrap" >if all &#X3B1;<sub><span style="font-style:italic">i</span></sub> &#X2208; { 0, 1 }
</td></tr>
</table></td></tr>
</table></td></tr>
</table></div>
The mobius function will allow us to perform <i>mobius inversion</i>:
<div class='latexblock'><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >&#XA0;&#XA0;<span style="font-style:italic">f</span>(<span style="font-style:italic">n</span>)</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">&#X2261;&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">&#X2211;</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span>&#XA0;|&#XA0;<span style="font-style:italic">n</span></td></tr>
</table></td><td class="dcell">&#XA0;<span style="font-style:italic">g</span>(<span style="font-style:italic">d</span>)&#XA0;=&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">&#X2211;</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span>&#XA0;|&#XA0;<span style="font-style:italic">n</span></td></tr>
</table></td><td class="dcell">&#XA0;<span style="font-style:italic">g</span>(<span style="font-style:italic">d</span>)&#XA0;1(<span style="font-style:italic">n</span>/<span style="font-style:italic">d</span>)&#XA0;=&#XA0;<span style="font-style:italic">g</span>&#XA0;&#X22C6;&#XA0;1&#XA0;</td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >
<span style="font-style:italic">f</span>&#XA0;&#X22C6;&#XA0;1<sup>&#X2212;1</sup></td><td style="text-align:left;white-space:nowrap" >=&#XA0;&#XA0;<span style="font-style:italic">g</span>&#XA0;&#X22C6;&#XA0;1&#XA0;&#X22C6;&#XA0;1<sup>&#X2212;1</sup>&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >
<span style="font-style:italic">f</span>&#XA0;&#X22C6;&#XA0;&#XB5;</td><td style="text-align:left;white-space:nowrap" >=&#XA0;<span style="font-style:italic">g</span>
</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table>
</div>
That is, we originally had <span class='latexinline'>
<span style="font-style:italic">f</span></span> defined in terms of <span class='latexinline'>
<span style="font-style:italic">g</span></span>. We can
recover an expression for <span class='latexinline'>
<span style="font-style:italic">g</span></span> in terms of <span class='latexinline'>
<span style="font-style:italic">f</span></span>.
<h4><a id=the-algebra-of-multiplicative-functions href='#the-algebra-of-multiplicative-functions'> § </a> The algebra of multiplicative functions</h4>
We claim that the set of functions <span class='latexinline'>
{ &#X2124; &#X2192; &#X2102; }</span>
is a commutative group, with the group operation <span class='latexinline'>
&#X22C6;</span> such that:
<ul>
<li>
 <span class='latexinline'>
(<span style="font-style:italic">f</span> &#X22C6; <span style="font-style:italic">g</span>)(<span style="font-style:italic">n</span>) &#X2261; &#X2211;<sub><span style="font-style:italic">d</span> | <span style="font-style:italic">n</span></sub> <span style="font-style:italic">f</span>(<span style="font-style:italic">d</span>) <span style="font-style:italic">g</span>(<span style="font-style:italic">n</span>/<span style="font-style:italic">d</span>)</span>.
</li>

</ul>

with the identity element being <span class='latexinline'>
<span style="font-style:italic">id</span><sub>&#X22C6;</sub>(<span style="font-style:italic">n</span>) &#X2261; &#X230A; 1 / <span style="font-style:italic">n</span> &#X230B;</span>. The idea
is that if <span class='latexinline'>
(<span style="font-style:italic">n</span> = 1)</span>, then <span class='latexinline'>
&#X230A; 1/1 &#X230B; = 1</span>, and for any other
number <span class='latexinline'>
<span style="font-style:italic">n</span> &gt; 0</span>, <span class='latexinline'>
1/<span style="font-style:italic">n</span> &lt; 1</span>, hence <span class='latexinline'>
&#X230A; 1/<span style="font-style:italic">n</span> &#X230B; = 0</span>.
<h4><a id=being-the-identity href='#being-the-identity'> § </a> verification of <span class='latexinline'>
<span style="font-style:italic">istar</span></span> being the identity</h4>
<div class='latexblock'><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">(<span style="font-style:italic">f</span>&#XA0;&#X22C6;&#XA0;<span style="font-style:italic">id</span><sub>&#X22C6;</sub>)(<span style="font-style:italic">n</span>)&#XA0;&#X2261;&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">&#X2211;</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span>&#XA0;|&#XA0;<span style="font-style:italic">n</span></td></tr>
</table></td><td class="dcell">&#XA0;<span style="font-style:italic">f</span>(<span style="font-style:italic">d</span>)&#XA0;<span style="font-style:italic">id</span><sub>&#X22C6;</sub>(<span style="font-style:italic">n</span>/<span style="font-style:italic">d</span>)&#XA0;</td></tr>
</table></td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">=&#XA0;<span style="font-style:italic">f</span>(<span style="font-style:italic">n</span>)&#XA0;<span style="font-style:italic">id</span><sub>&#X22C6;</sub>(1)&#XA0;+&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">&#X2211;</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span>&#XA0;|&#XA0;<span style="font-style:italic">n</span>,&#XA0;<span style="font-style:italic">d</span>&#XA0;&gt;&#XA0;1</td></tr>
</table></td><td class="dcell">&#XA0;<span style="font-style:italic">f</span>(<span style="font-style:italic">n</span>)&#XA0;<span style="font-style:italic">id</span><sub>&#X22C6;</sub>(<span style="font-style:italic">d</span>)&#XA0;</td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">=&#XA0;<span style="font-style:italic">f</span>(<span style="font-style:italic">n</span>)&#XA0;&#XB7;&#XA0;1&#XA0;+&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">&#X2211;</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span>&#XA0;|&#XA0;<span style="font-style:italic">n</span>,&#XA0;<span style="font-style:italic">d</span>&#XA0;&gt;&#XA0;1</td></tr>
</table></td><td class="dcell">&#XA0;<span style="font-style:italic">f</span>(<span style="font-style:italic">n</span>)&#XA0;&#XB7;&#XA0;0&#XA0;</td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >=&#XA0;<span style="font-style:italic">f</span>(<span style="font-style:italic">n</span>)&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table>
</div>
<h4><a id=starciativity-commutativity-of- href='#starciativity-commutativity-of-'> § </a> associativity, commutativity of <span class='latexinline'>
&#X22C6;</span></h4>
To prove associativity, it's better to write the formula as:
<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(<span style="font-style:italic">f</span>&#XA0;&#X22C6;&#XA0;<span style="font-style:italic">g</span>)(<span style="font-style:italic">n</span>)&#XA0;&#X2261;&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">&#X2211;</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span>&#XA0;|&#XA0;<span style="font-style:italic">n</span></td></tr>
</table></td><td class="dcell">&#XA0;<span style="font-style:italic">f</span>(<span style="font-style:italic">n</span>)&#XA0;<span style="font-style:italic">g</span>(<span style="font-style:italic">n</span>/<span style="font-style:italic">d</span>)&#XA0;=&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">&#X2211;</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">xy</span>&#XA0;=&#XA0;<span style="font-style:italic">n</span></td></tr>
</table></td><td class="dcell">&#XA0;<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)&#XA0;<span style="font-style:italic">g</span>(<span style="font-style:italic">y</span>)
</td></tr>
</table></div>
From this rewrite, it's clear that <span class='latexinline'>
(<span style="font-style:italic">f</span> &#X22C6; <span style="font-style:italic">g</span> &#X22C6; <span style="font-style:italic">h</span>)(<span style="font-style:italic">n</span>)</span> will unambiguously
sum over tripes <span class='latexinline'>
(<span style="font-style:italic">x</span>, <span style="font-style:italic">y</span>, <span style="font-style:italic">z</span>)</span> such that <span class='latexinline'>
<span style="font-style:italic">xyz</span> = <span style="font-style:italic">n</span></span>. I leave the working-this-out
to you. This should also make the commutativity immediate. Summing over pairs
of the form <span class='latexinline'>
<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>) <span style="font-style:italic">g</span>(<span style="font-style:italic">y</span>) : <span style="font-style:italic">xy</span> = <span style="font-style:italic">n</span></span> is the same as summing over <span class='latexinline'>
<span style="font-style:italic">f</span>(<span style="font-style:italic">y</span>) <span style="font-style:italic">g</span>(<span style="font-style:italic">x</span>) : <span style="font-style:italic">yx</span> = <span style="font-style:italic">n</span></span>.
<h4><a id=existence-of-inverse href='#existence-of-inverse'> § </a> Existence of inverse</h4>
We can show that an inverse exists by showing that a formula for it exists; The 
idea is to construct one by induction. 
Clearly, for a given function <span class='latexinline'>
<span style="font-style:italic">f</span></span>, we need the inverse <span class='latexinline'>
<span style="font-style:italic">f</span><sup>&#X2212;1</sup></span> to be such that
<span class='latexinline'>
(<span style="font-style:italic">f</span> &#X22C6; <span style="font-style:italic">f</span><sup>&#X2212;1</sup>)(<span style="font-style:italic">n</span>) = <span style="font-style:italic">id</span><sub>&#X22C6;</sub></span>. Hence:
<div class='latexblock'><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >(<span style="font-style:italic">f</span>&#XA0;&#X22C6;&#XA0;<span style="font-style:italic">f</span><sup>&#X2212;1</sup>)(1)&#XA0;=&#XA0;<span style="font-style:italic">id</span><sub>&#X22C6;</sub>(1)&#XA0;=&#XA0;1&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">f</span>(1)&#XA0;<span style="font-style:italic">f</span><sup>&#X2212;1</sup>(1)&#XA0;=&#XA0;1&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&#XA0;<span style="font-style:italic">f</span><sup>&#X2212;1</sup>(1)&#XA0;&#X2261;&#XA0;1&#XA0;/&#XA0;<span style="font-style:italic">f</span>(1)</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table>
</div>
Great, we have a base case; We can now compute <span class='latexinline'>
<span style="font-style:italic">f</span><sup>&#X2212;1</sup>(<span style="font-style:italic">n</span>)</span> inductively, assuming
we know the value of <span class='latexinline'>
<span style="font-style:italic">f</span><sup>&#X2212;1</sup>(<span style="font-style:italic">d</span>)</span> for all <span class='latexinline'>
<span style="font-style:italic">d</span> | <span style="font-style:italic">n</span></span>.
<div class='latexblock'><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >(<span style="font-style:italic">f</span>&#XA0;&#X22C6;&#XA0;<span style="font-style:italic">f</span><sup>&#X2212;1</sup>)(<span style="font-style:italic">n</span>)&#XA0;=&#XA0;<span style="font-style:italic">id</span><sub>&#X22C6;</sub>(1)&#XA0;=&#XA0;0&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">&#X2211;</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span>&#XA0;|&#XA0;<span style="font-style:italic">n</span></td></tr>
</table></td><td class="dcell">&#XA0;<span style="font-style:italic">f</span>(<span style="font-style:italic">d</span>)&#XA0;<span style="font-style:italic">f</span><sup>&#X2212;1</sup>(<span style="font-style:italic">n</span>/<span style="font-style:italic">d</span>)&#XA0;=&#XA0;0&#XA0;</td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">f</span>(1)&#XA0;<span style="font-style:italic">f</span><sup>&#X2212;1</sup>(<span style="font-style:italic">n</span>)&#XA0;+&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">&#X2211;</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span>&#XA0;|&#XA0;<span style="font-style:italic">n</span>,&#XA0;<span style="font-style:italic">d</span>&#XA0;&lt;&#XA0;<span style="font-style:italic">n</span></td></tr>
</table></td><td class="dcell">&#XA0;<span style="font-style:italic">f</span>(<span style="font-style:italic">d</span>)&#XA0;<span style="font-style:italic">f</span><sup>&#X2212;1</sup>(<span style="font-style:italic">n</span>/<span style="font-style:italic">d</span>)&#XA0;=&#XA0;0&#XA0;&#XA0;&#XA0;&#XA0;</td></tr>
</table></td><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">f</span><sup>&#X2212;1</sup>(<span style="font-style:italic">n</span>)&#XA0;=&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell">&#X2212;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">&#X2211;</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span>&#XA0;|&#XA0;<span style="font-style:italic">n</span>,&#XA0;<span style="font-style:italic">d</span>&#XA0;&lt;&#XA0;<span style="font-style:italic">n</span></td></tr>
</table></td><td class="dcell">&#XA0;<span style="font-style:italic">f</span>(<span style="font-style:italic">d</span>)&#XA0;<span style="font-style:italic">f</span><sup>&#X2212;1</sup>(<span style="font-style:italic">n</span>/<span style="font-style:italic">d</span>)</td></tr>
</table></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">f</span>(1)</td></tr>
</table></td><td class="dcell">&#XA0;
</td></tr>
</table></td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table>
</div>
<h4><a id=functionnverse-of-the- href='#functionnverse-of-the-'> § </a> <span class='latexinline'>
&#XB5;</span> as the inverse of the <span class='latexinline'>
<span style="font-style:italic">one</span></span> function</h4>
<h4><a id=mobius-inversion href='#mobius-inversion'> § </a> Mobius inversion</h4>
Now that we know that <span class='latexinline'>
&#XB5; = <span style="font-family:monospace">const 1</span><sup>&#X2212;1</sup></span>, we can use this fact
to perform <i>mobius inversion</i>:
<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">f</span>(<span style="font-style:italic">n</span>)&#XA0;&#X2261;&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">&#X2211;</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span>&#XA0;|&#XA0;<span style="font-style:italic">n</span></td></tr>
</table></td><td class="dcell">&#XA0;<span style="font-style:italic">g</span>(<span style="font-style:italic">n</span>/<span style="font-style:italic">d</span>)&#XA0;=&#XA0;<span style="font-family:monospace">const 1</span>&#XA0;&#X22C6;&#XA0;<span style="font-style:italic">g</span>
</td></tr>
</table></div>
We have <span class='latexinline'>
<span style="font-style:italic">f</span></span> written in terms of <span class='latexinline'>
<span style="font-style:italic">g</span></span>. We can now write <span class='latexinline'>
<span style="font-style:italic">g</span></span> in terms of <span class='latexinline'>
<span style="font-style:italic">f</span></span>:
<div class='latexblock'><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">f</span>(<span style="font-style:italic">n</span>)&#XA0;&#XA0;=&#XA0;<span style="font-family:monospace">const 1</span>&#XA0;&#X22C6;&#XA0;<span style="font-style:italic">g</span>&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">f</span>&#XA0;&#X22C6;&#XA0;<span style="font-family:monospace">const 1</span><sup>&#X2212;1</sup>&#XA0;=&#XA0;<span style="font-style:italic">g</span>&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">g</span>&#XA0;=&#XA0;<span style="font-style:italic">f</span>&#XA0;&#X22C6;&#XA0;&#XB5;&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">g</span>&#XA0;=&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">&#X2211;</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span>&#XA0;|&#XA0;<span style="font-style:italic">n</span></td></tr>
</table></td><td class="dcell">&#XA0;<span style="font-style:italic">f</span>(<span style="font-style:italic">d</span>)&#XA0;&#XB5;(<span style="font-style:italic">n</span>/<span style="font-style:italic">d</span>)
</td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table>
</div>
<h4><a id=n-sumd-vert-n-phid href='#n-sumd-vert-n-phid'> § </a> <span class='latexinline'>
<span style="font-style:italic">n</span> = &#X2211;<sub><span style="font-style:italic">d</span> | <span style="font-style:italic">n</span></sub> &#X3C6;(<span style="font-style:italic">d</span>)</span></h4>
<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-style:italic">d</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" >{&#XA0;1&#XA0;&#X2264;&#XA0;<span style="font-style:italic">x</span>&#XA0;&#X2264;&#XA0;12&#XA0;:&#XA0;(<span style="font-style:italic">x</span>,&#XA0;12)&#XA0;=&#XA0;<span style="font-style:italic">d</span>&#XA0;}</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >{&#XA0;1&#XA0;&#X2264;&#XA0;<span style="font-style:italic">x</span>&#XA0;&#X2264;&#XA0;12:&#XA0;(<span style="font-style:italic">x</span>/<span style="font-style:italic">d</span>,&#XA0;12/<span style="font-style:italic">d</span>)&#XA0;=&#XA0;1}</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >size of set&#XA0;</td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" >1</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >{&#XA0;1,&#XA0;5,&#XA0;7,&#XA0;11&#XA0;}</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >(<span style="font-style:italic">x</span>,&#XA0;12)&#XA0;=&#XA0;1</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >4&#XA0;</td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" >2</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >{2,&#XA0;10&#XA0;}</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >(<span style="font-style:italic">x</span>/2,&#XA0;6)&#XA0;=&#XA0;1</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >2&#XA0;</td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" >3</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >{3,&#XA0;9&#XA0;}</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >(<span style="font-style:italic">x</span>/3,&#XA0;4)&#XA0;=&#XA0;1</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >2&#XA0;</td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" >4</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >{4,&#XA0;8&#XA0;}</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >(<span style="font-style:italic">x</span>/4,&#XA0;3)&#XA0;=&#XA0;1</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >2&#XA0;</td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" >6</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >{&#XA0;6&#XA0;}</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >(<span style="font-style:italic">x</span>/6,&#XA0;2)&#XA0;=&#XA0;1</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >1&#XA0;</td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" >12</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >{&#XA0;12&#XA0;}&#XA0;(<span style="font-style:italic">x</span>/12,&#XA0;1)&#XA0;=&#XA0;1</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >1
</td></tr>
</table></td></tr>
</table></div>
Notice that the sizes of sets that we are calculating, for example,
<span class='latexinline'>
|{ 1 &#X2264; <span style="font-style:italic">x</span> &#X2264; 12 : (<span style="font-style:italic">x</span>/2, 6) = 1 }| = &#X3C6;(6)</span>. Summing over all of
what we have, we've counted the numbers in <span class='latexinline'>
[1, 2, &#X2026;, 12]</span> in two ways ---
one directly, and the other by partitioning into equivalence classes:
<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">12&#XA0;=&#XA0;&#X3C6;(1)&#XA0;+&#XA0;&#X3C6;(2)&#XA0;+&#XA0;&#X3C6;(3)&#XA0;+&#XA0;&#X3C6;(4)&#XA0;+&#XA0;&#X3C6;(6)&#XA0;+&#XA0;&#X3C6;(12)&#XA0;=&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">&#X2211;</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span>&#XA0;|&#XA0;12</td></tr>
</table></td><td class="dcell">&#XA0;&#X3C6;(12/<span style="font-style:italic">d</span>)&#XA0;</td></tr>
</table></div>
In general, the same argument allows us to prove that:
<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">n</span>&#XA0;=&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">&#X2211;</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span>&#XA0;|&#XA0;<span style="font-style:italic">n</span></td></tr>
</table></td><td class="dcell">&#XA0;<span style="font-style:italic">n</span>/<span style="font-style:italic">d</span>&#XA0;</td></tr>
</table></div>
<h4><a id=using-mobius-inversion-on-the-euler-totient-function href='#using-mobius-inversion-on-the-euler-totient-function'> § </a> Using mobius inversion on the euler totient function</h4>
<h4><a id=other-arithmetical-functions-and-their-relations href='#other-arithmetical-functions-and-their-relations'> § </a> Other arithmetical functions and their relations</h4>
<h3><a id=incunabulum-for-the-21st-century-making-the-j-interpreter-compile-in-2020 href='#incunabulum-for-the-21st-century-making-the-j-interpreter-compile-in-2020'> § </a> <a href=#incunabulum-for-the-21st-century-making-the-j-interpreter-compile-in-2020>
Incunabulum for the 21st century: Making the J interpreter compile in 2020</a>
</h3>
This is me trying to understand the fabled interpreter of the <code>J</code> language
working, so I could absorb Arthur Whitney's style of writing C: it's
cryptic, short, and fits in a page. <a href=https://code.jsoftware.com/wiki/Essays/Incunabulum>
I learnt of this from the <code>J</code> language page</a>
,
which comes with the quote:
<blockquote> One summer weekend in 1989, Arthur Whitney visited Ken Iverson at Kiln Farm and produced—on one page and in one afternoon—an interpreter fragment on the AT&T 3B1 computer. I studied this interpreter for about a week for its organization and programming style; and on Sunday, August 27, 1989, at about four o'clock in the afternoon, wrote the first line of code that became the implementation described in this document. Arthur's one-page interpreter fragment is as follows:</blockquote>
<h4><a id=the-original-source href='#the-original-source'> § </a> The original source</h4>
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> <b><u><font color="#000000">typedef</font></u></b> <b><font color="#000000">char</font></b> C;<b><u><font color="#000000">typedef</font></u></b> <b><font color="#000000">long</font></b> I;
<font color="#000000">03:</font> <b><u><font color="#000000">typedef</font></u></b> <b><u><font color="#000000">struct</font></u></b> a{I t,r,d[<font color="#000000">3</font>],p[<font color="#000000">2</font>];}*A;
<font color="#000000">04:</font> <b><u><font color="#000000">#define</font></u></b> P printf
<font color="#000000">05:</font> <b><u><font color="#000000">#define</font></u></b> R <b><u><font color="#000000">return</font></u></b>
<font color="#000000">06:</font> <b><u><font color="#000000">#define</font></u></b> V1(f) A f(w)A w;
<font color="#000000">07:</font> <b><u><font color="#000000">#define</font></u></b> V2(f) A f(a,w)A a,w;
<font color="#000000">08:</font> <b><u><font color="#000000">#define</font></u></b> DO(n,x) {I i=<font color="#000000">0</font>,_n=(n);<b><u><font color="#000000">for</font></u></b>(;i&lt;_n;++i){x;}}
<font color="#000000">09:</font> I *ma(n){R(I*)malloc(n*<font color="#000000">4</font>);}mv(d,s,n)I *d,*s;{DO(n,d[i]=s[i]);}
<font color="#000000">10:</font> tr(r,d)I *d;{I z=<font color="#000000">1</font>;DO(r,z=z*d[i]);R z;}
<font color="#000000">11:</font> A ga(t,r,d)I *d;{A z=(A)ma(<font color="#000000">5</font>+tr(r,d));z-&gt;t=t,z-&gt;r=r,mv(z-&gt;d,d,r);
<font color="#000000">12:</font>  R z;}
<font color="#000000">13:</font> V1(iota){I n=*w-&gt;p;A z=ga(<font color="#000000">0</font>,<font color="#000000">1</font>,&amp;n);DO(n,z-&gt;p[i]=i);R z;}
<font color="#000000">14:</font> V2(plus){I r=w-&gt;r,*d=w-&gt;d,n=tr(r,d);A z=ga(<font color="#000000">0</font>,r,d);
<font color="#000000">15:</font>  DO(n,z-&gt;p[i]=a-&gt;p[i]+w-&gt;p[i]);R z;}
<font color="#000000">16:</font> V2(from){I r=w-&gt;r-<font color="#000000">1</font>,*d=w-&gt;d+<font color="#000000">1</font>,n=tr(r,d);
<font color="#000000">17:</font>  A z=ga(w-&gt;t,r,d);mv(z-&gt;p,w-&gt;p+(n**a-&gt;p),n);R z;}
<font color="#000000">18:</font> V1(box){A z=ga(<font color="#000000">1</font>,<font color="#000000">0</font>,<font color="#000000">0</font>);*z-&gt;p=(I)w;R z;}
<font color="#000000">19:</font> V2(cat){I an=tr(a-&gt;r,a-&gt;d),wn=tr(w-&gt;r,w-&gt;d),n=an+wn;
<font color="#000000">20:</font>  A z=ga(w-&gt;t,<font color="#000000">1</font>,&amp;n);mv(z-&gt;p,a-&gt;p,an);mv(z-&gt;p+an,w-&gt;p,wn);R z;}
<font color="#000000">21:</font> V2(find){}
<font color="#000000">22:</font> V2(rsh){I r=a-&gt;r?*a-&gt;d:<font color="#000000">1</font>,n=tr(r,a-&gt;p),wn=tr(w-&gt;r,w-&gt;d);
<font color="#000000">23:</font>  A z=ga(w-&gt;t,r,a-&gt;p);mv(z-&gt;p,w-&gt;p,wn=n&gt;wn?wn:n);
<font color="#000000">24:</font>  <b><u><font color="#000000">if</font></u></b>(n-=wn)mv(z-&gt;p+wn,z-&gt;p,n);R z;}
<font color="#000000">25:</font> V1(sha){A z=ga(<font color="#000000">0</font>,<font color="#000000">1</font>,&amp;w-&gt;r);mv(z-&gt;p,w-&gt;d,w-&gt;r);R z;}
<font color="#000000">26:</font> V1(id){R w;}V1(size){A z=ga(<font color="#000000">0</font>,<font color="#000000">0</font>,<font color="#000000">0</font>);*z-&gt;p=w-&gt;r?*w-&gt;d:<font color="#000000">1</font>;R z;}
<font color="#000000">27:</font> pi(i){P(<font color="#808080">"%d "</font>,i);}nl(){P(<font color="#808080">"</font>\n<font color="#808080">"</font>);}
<font color="#000000">28:</font> pr(w)A w;{I r=w-&gt;r,*d=w-&gt;d,n=tr(r,d);DO(r,pi(d[i]));nl();
<font color="#000000">29:</font>  <b><u><font color="#000000">if</font></u></b>(w-&gt;t)DO(n,P(<font color="#808080">"&lt; "</font>);pr(w-&gt;p[i]))<b><u><font color="#000000">else</font></u></b> DO(n,pi(w-&gt;p[i]));nl();}
<font color="#000000">30:</font> 
<font color="#000000">31:</font> C vt[]=<font color="#808080">"+{~&lt;#,"</font>;
<font color="#000000">32:</font> A(*vd[])()={<font color="#000000">0</font>,plus,from,find,<font color="#000000">0</font>,rsh,cat},
<font color="#000000">33:</font>  (*vm[])()={<font color="#000000">0</font>,id,size,iota,box,sha,<font color="#000000">0</font>};
<font color="#000000">34:</font> I st[<font color="#000000">26</font>]; qp(a){R  a&gt;=<font color="#808080">'a'</font>&amp;&amp;a&lt;=<font color="#808080">'z'</font>;}qv(a){R a&lt;<font color="#808080">'a'</font>;}
<font color="#000000">35:</font> A ex(e)I *e;{I a=*e;
<font color="#000000">36:</font>  <b><u><font color="#000000">if</font></u></b>(qp(a)){<b><u><font color="#000000">if</font></u></b>(e[<font color="#000000">1</font>]==<font color="#808080">'='</font>)R st[a-<font color="#808080">'a'</font>]=ex(e+<font color="#000000">2</font>);a= st[ a-<font color="#808080">'a'</font>];}
<font color="#000000">37:</font>  R qv(a)?(*vm[a])(ex(e+<font color="#000000">1</font>)):e[<font color="#000000">1</font>]?(*vd[e[<font color="#000000">1</font>]])(a,ex(e+<font color="#000000">2</font>)):(A)a;}
<font color="#000000">38:</font> noun(c){A z;<b><u><font color="#000000">if</font></u></b>(c&lt;<font color="#808080">'0'</font>||c&gt;<font color="#808080">'9'</font>)R <font color="#000000">0</font>;z=ga(<font color="#000000">0</font>,<font color="#000000">0</font>,<font color="#000000">0</font>);*z-&gt;p=c-<font color="#808080">'0'</font>;R z;}
<font color="#000000">39:</font> verb(c){I i=<font color="#000000">0</font>;<b><u><font color="#000000">for</font></u></b>(;vt[i];)<b><u><font color="#000000">if</font></u></b>(vt[i++]==c)R i;R <font color="#000000">0</font>;}
<font color="#000000">40:</font> I *wd(s)C *s;{I a,n=strlen(s),*e=ma(n+<font color="#000000">1</font>);C c;
<font color="#000000">41:</font>  DO(n,e[i]=(a=noun(c=s[i]))?a:(a=verb(c))?a:c);e[n]=<font color="#000000">0</font>;R e;}
<font color="#000000">42:</font> 
<font color="#000000">43:</font> main(){C s[<font color="#000000">99</font>];<b><u><font color="#000000">while</font></u></b>(gets(s))pr(ex(wd(s)));}
<font color="#000000">44:</font> </tt></pre>
</div>

It's a lot to take in --- it's quite breathtaking really, the way it all
hangs together in one page.
<h4><a id=the-attempt-to-get-it-run href='#the-attempt-to-get-it-run'> § </a> The attempt to get it run</h4>
Unfortunately, this does not work if we try to get it to run in 2020. I decided
to read the code and understand what would happen. I managed to read enough
to understand that the code <code>a=~3</code> ought to create an array with values <code>[0 1 2]</code>.
On attempting to <i>run</i> this however, we get:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> $ gcc -O0 -g -std=c89 -fsanitize=address -fsanitize=undefined incunabulum.c -o bin/incunabulum &amp;&amp; ./bin/incunabulum
<font color="#000000">03:</font> ...
<font color="#000000">04:</font> (many many GCC warnings elided)
<font color="#000000">05:</font> ...
<font color="#000000">06:</font> a=~3
<font color="#000000">07:</font> =================================================================
<font color="#000000">08:</font> ==23726==ERROR: AddressSanitizer: heap-buffer-overflow on address
<font color="#000000">09:</font>   0x60300000eff0 at pc 0x000000402be3 bp 0x7ffe6dde6b70 sp 0x7ffe6dde6b60
<font color="#000000">10:</font> WRITE of size 8 at 0x60300000eff0 thread T0
<font color="#000000">11:</font>     #0 0x402be2 in wd /home/bollu/work/w/incunabulum.c:40
<font color="#000000">12:</font>     #1 0x402d28 in main /home/bollu/work/w/incunabulum.c:42
<font color="#000000">13:</font>     #2 0x7f7ae901082f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2082f)
<font color="#000000">14:</font>     #3 0x400ca8 in _start (/home/bollu/w/bin/incunabulum+0x400ca8)
<font color="#000000">15:</font> ...
<font color="#000000">16:</font> SUMMARY: AddressSanitizer: heap-buffer-overflow /home/bollu/work/w/incunabulum.c:40 wd
<font color="#000000">17:</font> ...
<font color="#000000">18:</font> ==23726==ABORTING
<font color="#000000">19:</font> </tt></pre>
</div>

oops! The code uses a lot of punning between <code>int</code>
and <code>int*</code>. These assumptions break now that we're in 64-bit. The patch to
get this to work is:
<h4><a id=the-patch href='#the-patch'> § </a> the patch</h4>
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> diff --git a/incunabulum.c b/incunabulum.c
<font color="#000000">03:</font> index 2cae744..778e35a 100644
<font color="#000000">04:</font> --- a/incunabulum.c
<font color="#000000">05:</font> +++ b/incunabulum.c
<font color="#000000">06:</font> @@ -1,11 +1,11 @@
<font color="#000000">07:</font> -typedef char C;typedef long I;
<font color="#000000">08:</font> +typedef char C;typedef long long I;
<font color="#000000">09:</font>  typedef struct a{I t,r,d[3],p[2];}*A;
<font color="#000000">10:</font>  #define P printf
<font color="#000000">11:</font>  #define R return
<font color="#000000">12:</font>  #define V1(f) A f(w)A w;
<font color="#000000">13:</font>  #define V2(f) A f(a,w)A a,w;
<font color="#000000">14:</font>  #define DO(n,x) {I i=0,_n=(n);for(;i&lt;_n;++i){x;}}
<font color="#000000">15:</font> -I *ma(n){R(I*)malloc(n*4);}mv(d,s,n)I *d,*s;{DO(n,d[i]=s[i]);}
<font color="#000000">16:</font> +I *ma(n){R(I*)malloc(n*8);}mv(d,s,n)I *d,*s;{DO(n,d[i]=s[i]);}
<font color="#000000">17:</font>  tr(r,d)I *d;{I z=1;DO(r,z=z*d[i]);R z;}
<font color="#000000">18:</font>  A ga(t,r,d)I *d;{A z=(A)ma(5+tr(r,d));z-&gt;t=t,z-&gt;r=r,mv(z-&gt;d,d,r);
<font color="#000000">19:</font>   R z;}
<font color="#000000">20:</font> @@ -34,9 +34,10 @@ I st[26]; qp(a){R  a&gt;='a'&amp;&amp;a&lt;='z';}qv(a){R a&lt;'a';}
<font color="#000000">21:</font>  A ex(e)I *e;{I a=*e;
<font color="#000000">22:</font>   if(qp(a)){if(e[1]=='=')R st[a-'a']=ex(e+2);a= st[ a-'a'];}
<font color="#000000">23:</font>   R qv(a)?(*vm[a])(ex(e+1)):e[1]?(*vd[e[1]])(a,ex(e+2)):(A)a;}
<font color="#000000">24:</font> -noun(c){A z;if(c&lt;'0'||c&gt;'9')R 0;z=ga(0,0,0);*z-&gt;p=c-'0';R z;}
<font color="#000000">25:</font> -verb(c){I i=0;for(;vt[i];)if(vt[i++]==c)R i;R 0;}
<font color="#000000">26:</font> +I noun(c){A z;if(c&lt;'0'||c&gt;'9')R 0;z=ga(0,0,0);*z-&gt;p=c-'0';R z;}
<font color="#000000">27:</font> +I verb(c){I i=0;for(;vt[i];)if(vt[i++]==c)R i;R 0;}
<font color="#000000">28:</font>  I *wd(s)C *s;{I a,n=strlen(s),*e=ma(n+1);C c;
<font color="#000000">29:</font>   DO(n,e[i]=(a=noun(c=s[i]))?a:(a=verb(c))?a:c);e[n]=0;R e;}
<font color="#000000">30:</font> 
<font color="#000000">31:</font>  main(){C s[99];while(gets(s))pr(ex(wd(s)));}
<font color="#000000">32:</font> +
<font color="#000000">33:</font> </tt></pre>
</div>

<h4><a id=it-runs href='#it-runs'> § </a> It runs!</h4>
After applying the patch, we manage to get the interpreter to run!
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> ./bin/incunabulum
<font color="#000000">3:</font> a=~3
<font color="#000000">4:</font> 3
<font color="#000000">5:</font> 0 1 2
<font color="#000000">6:</font> </tt></pre>
</div>

<h4><a id=the-lock-screen href='#the-lock-screen'> § </a> The lock screen</h4>
I liked it so much that I took a screenshot and made it my lock screen.
<img width=500 src="./static/screenshot-j-incunabulum.png">
<h4><a id=thoughts href='#thoughts'> § </a> Thoughts</h4>
I'm really fascinated by the code. I loved I could simply stare the screenshot
to absorb the code. There was no scrolling involved.  The variables are
well-named (to the extent I understand the code), and it's clearly extremely
well thought out. If there's someone who understands some of the thorny
aspects of the code:
<ul>
<li>
 What is the <code>t</code> variable really tracking?
</li>
<li>
 How does one create a multi-dimensional array easily?
</li>
<li>
 What are some interesting programs one can run with this mini-interpreter?
</li>

</ul>

I'd be really glad to know the details. Please leave 
<a href=https://github.com/bollu/bollu.github.io/issues/new>
an issue or a pull request against the repo</a>
.
I'm going write a dissection of the code once I fully understand it, since I
couldn't find explanaing the code on the internet.
Until then, enjoy the monolith of code!
<h3><a id=an-example-of-a-sequence-whose-successive-terms-get-closer-together-but-isnt-cauchy-does-not-converge href='#an-example-of-a-sequence-whose-successive-terms-get-closer-together-but-isnt-cauchy-does-not-converge'> § </a> <a href=#an-example-of-a-sequence-whose-successive-terms-get-closer-together-but-isnt-cauchy-does-not-converge>
An example of a sequence whose successive terms get closer together but isn't Cauchy (does not converge)</a>
</h3>
<h4><a id=the-problem href='#the-problem'> § </a> The problem</h4>
Provide an example of a sequence <span class='latexinline'>
<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>: &#X2115; &#X2192; &#X211D;</span>
such that <span class='latexinline'>
lim<sub><span style="font-style:italic">n</span> &#X2192; &#X221E;</sub> | <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span>+1</sub> &#X2212; <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub> | &#X2192; 0</span>,
but <span class='latexinline'>
lim<sub><span style="font-style:italic">n</span>, <span style="font-style:italic">m</span> &#X2192; &#X221E;, <span style="font-style:italic">m</span> &gt; <span style="font-style:italic">n</span></sub> |<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub> &#X2212; <span style="font-style:italic">a</span><sub><span style="font-style:italic">m</span></sub>| &#X2260; 0</span>. That is,
proide a series where the distances between successive terms converges to zero,
but where distances between terms that are "farther apart than 1" does
not converge to 0. That is, the sequence is not <i>Cauchy</i>.
<h4><a id=regular-solution-harmonic-numbers href='#regular-solution-harmonic-numbers'> § </a> Regular solution: Harmonic numbers</h4>
The usual solution is to take the harmonic numbers,
<span class='latexinline'>
<span style="font-style:italic">H</span><sub><span style="font-style:italic">n</span></sub> &#X2261; &#X2211;<sub><span style="font-style:italic">i</span>=1</sub><sup><span style="font-style:italic">n</span></sup> 1/<span style="font-style:italic">i</span></span>. Then, we show that:
<div class='latexblock'><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center">lim</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>&#XA0;&#X2192;&#XA0;&#X221E;</td></tr>
</table></td><td class="dcell">&#XA0;</td><td class="dcell">&#X23AA;<br>
&#X23AA;</td><td class="dcell"><span style="font-style:italic">H</span><sub><span style="font-style:italic">n</span>+1</sub>&#XA0;&#X2212;&#XA0;<span style="font-style:italic">H</span><sub><span style="font-style:italic">n</span></sub>&#XA0;</td><td class="dcell">&#X23AA;<br>
&#X23AA;</td></tr>
</table></td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">=&#XA0;</td><td class="dcell">&#X23AA;<br>
&#X23AA;<br>
&#X23AA;<br>
&#X23AA;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>+1</td></tr>
</table></td><td class="dcell">&#XA0;&#X2212;&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
</table></td><td class="dcell">&#XA0;</td><td class="dcell">&#X23AA;<br>
&#X23AA;<br>
&#X23AA;<br>
&#X23AA;</td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">=&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">n</span>+1)<span style="font-style:italic">n</span></td></tr>
</table></td><td class="dcell">&#XA0;&#X2192;&#XA0;0
</td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table>
</div>
<div class='latexblock'><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center">lim</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>&#XA0;&#X2192;&#XA0;&#X221E;</td></tr>
</table></td><td class="dcell">&#XA0;</td><td class="dcell">&#X23AA;<br>
&#X23AA;</td><td class="dcell"><span style="font-style:italic">H</span><sub>2<span style="font-style:italic">n</span></sub>&#XA0;&#X2212;&#XA0;<span style="font-style:italic">H</span><sub><span style="font-style:italic">n</span></sub>&#XA0;</td><td class="dcell">&#X23AA;<br>
&#X23AA;</td></tr>
</table></td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">=&#XA0;</td><td class="dcell">&#X23AA;<br>
&#X23AA;<br>
&#X23AA;<br>
&#X23AA;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2<span style="font-style:italic">n</span></td></tr>
</table></td><td class="dcell">&#XA0;&#X2212;&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
</table></td><td class="dcell">&#XA0;</td><td class="dcell">&#X23AA;<br>
&#X23AA;<br>
&#X23AA;<br>
&#X23AA;</td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">=&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">2<span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">&#X2211;</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">i</span>=<span style="font-style:italic">n</span>+1</td></tr>
</table></td><td class="dcell">&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>+1</td></tr>
</table></td><td class="dcell">&#XA0;+&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>+2</td></tr>
</table></td><td class="dcell">&#XA0;+&#XA0;&#X2026;&#XA0;+&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2<span style="font-style:italic">n</span></td></tr>
</table></td><td class="dcell">&#XA0;</td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">&#X2265;&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">2<span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">&#X2211;</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">i</span>=<span style="font-style:italic">n</span>+1</td></tr>
</table></td><td class="dcell">&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2<span style="font-style:italic">n</span></td></tr>
</table></td><td class="dcell">&#XA0;+&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2<span style="font-style:italic">n</span></td></tr>
</table></td><td class="dcell">&#XA0;+&#XA0;&#X2026;&#XA0;+&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2<span style="font-style:italic">n</span></td></tr>
</table></td><td class="dcell">&#XA0;</td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">&#X2265;&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2<span style="font-style:italic">n</span></td></tr>
</table></td><td class="dcell">&#XA0;=&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">&#XA0;&#X2260;&#XA0;0&#XA0;on&#XA0;<span style="font-style:italic">x</span>&#XA0;&#X2192;&#XA0;&#X221E;
</td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table>
</div>
<h4><a id=memorable-solution-logarithm href='#memorable-solution-logarithm'> § </a> Memorable solution: logarithm</h4>
We can much more simply choose <span class='latexinline'>
<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub> = log(<span style="font-style:italic">n</span>)</span>. This yields the simple
calculation:
<div class='latexblock'><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center">lim</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>&#XA0;&#X2192;&#XA0;&#X221E;</td></tr>
</table></td><td class="dcell">&#XA0;<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span>+1</sub>&#XA0;&#X2212;&#XA0;<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>&#XA0;=&#XA0;log(<span style="font-style:italic">n</span>+1)&#XA0;&#X2212;&#XA0;log(<span style="font-style:italic">n</span>)
=&#XA0;log((<span style="font-style:italic">n</span>+1)/<span style="font-style:italic">n</span>))
=&#XA0;log(1&#XA0;+&#XA0;1/<span style="font-style:italic">n</span>)&#XA0;</td><td class="dcell"><table class="display" style="width:100%;"><tr><td class="dcell"  colspan="2"  style="font-size:smaller;;text-align:center">&#XA0;&#XA0;<span style="font-style:italic">n</span>&#XA0;&#X2192;&#XA0;&#X221E;&#XA0;&#XA0;</td></tr>
<tr><td class="dcell"   style="width:99%;;text-align:center"><hr class="hbar"></td><td class="dcell"   style="width:1%;;text-align:center">&#X25B8;</td></tr>
<tr><td class="dcell"  colspan="2"  style="font-size:smaller;;text-align:center">&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;</td></tr>
</table></td><td class="dcell">log(1)&#XA0;=&#XA0;0
</td></tr>
</table></td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table>
</div>
while on the other hand,
<div class='latexblock'><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center">lim</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>&#XA0;&#X2192;&#XA0;&#X221E;</td></tr>
</table></td><td class="dcell">&#XA0;<span style="font-style:italic">a</span><sub>2<span style="font-style:italic">n</span></sub>&#XA0;&#X2212;&#XA0;<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>
=&#XA0;log(2<span style="font-style:italic">n</span>)&#XA0;&#X2212;&#XA0;log(<span style="font-style:italic">n</span>)
=&#XA0;log(2)&#XA0;+&#XA0;log(<span style="font-style:italic">n</span>)&#XA0;&#X2212;&#XA0;log(<span style="font-style:italic">n</span>)
=&#XA0;log2&#XA0;&#X2260;&#XA0;0
</td></tr>
</table></td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table>
</div>
I find this far cleaner conceptually, since it's "obvious" to everyone
that <span class='latexinline'>
<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub> = log(<span style="font-style:italic">n</span>)</span> diverges, while the corresponding fact for <span class='latexinline'>
<span style="font-style:italic">H</span><sub><span style="font-style:italic">n</span></sub></span>
is hardly convincing. We also get straightforward equalities everywhere,
instead of inequalities.
I still feel that I don't grok what precisely fails here, in that, my intuition
still feels that the local condition <i>ought</i> to imply the Cauchy condition:
if <span class='latexinline'>
<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub></span> tells <span class='latexinline'>
<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span>+1</sub></span> to not be too far, and <span class='latexinline'>
<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span>+1</sub></span> tells <span class='latexinline'>
<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span>+2</sub></span>,
surely this <i>must</i> be transitive?
I have taught my instincts to not trust my instincts on analysis, which is a
shitty solution :) I hope to internalize this someday.
<b>EDIT:</b> I feel I now understand what's precisely happening
after ruminating a bit.
The Cauchy convergence criterion allows us to drop a finite number
of terms, and then capture <i>everything after that point</i> in a ball
of radius <span class='latexinline'>
&#X454;</span>. As <span class='latexinline'>
&#X454;</span> shrinks, <i>all</i> the terms in the
sequence are "squeezed togeher".
In the <span class='latexinline'>
<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span>+1</sub> &#X2212; <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub></span> case, only successive terms must maintain
an <span class='latexinline'>
&#X454;</span> distance. But as the <span class='latexinline'>
log</span> example shows, you can steadily
plod along, keeping <span class='latexinline'>
&#X454;</span> ball next to <span class='latexinline'>
&#X454;</span> ball, to reach:
<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center">lim</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>&#XA0;&#X2192;&#XA0;&#X221E;</td></tr>
</table></td><td class="dcell">&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center">lim</td></tr>
<tr><td class="dcell" style="text-align:center">&#X454;&#XA0;&#X2192;&#XA0;0</td></tr>
</table></td><td class="dcell">&#XA0;<span style="font-style:italic">f</span>(<span style="font-style:italic">n</span>)&#XA0;&#XB7;&#XA0;&#X454;
</td></tr>
</table></div>
whose behaviour can do unexpected things depending on the choice of <span class='latexinline'>
</span>.
<h3><a id=krylov-subspace-method href='#krylov-subspace-method'> § </a> <a href=#krylov-subspace-method>
Krylov subspace method</a>
</h3>

This is a class of methods used to solve <span class='latexinline'>
<span style="font-style:italic">Ax</span> = <span style="font-style:italic">b</span></span>, where <span class='latexinline'>
<span style="font-style:italic">A</span></span> is sparse.
Krylov subspace methods are a class of methods which use the idea of a
Krylov subspace. There is conjugate gradient (CG), GMRES (Generalized minimal
residual method).
<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">K</span><sub><span style="font-style:italic">m</span></sub>(<span style="font-style:italic">A</span>,&#XA0;<span style="font-style:italic">v</span>)&#XA0;&#X2261;&#XA0;<span style="font-style:italic">span</span>&#XA0;{&#XA0;<span style="font-style:italic">v</span>,&#XA0;<span style="font-style:italic">Av</span>,&#XA0;<span style="font-style:italic">A</span><sup>2</sup><span style="font-style:italic">v</span>,&#XA0;&#X2026;,&#XA0;<span style="font-style:italic">A</span><sup><span style="font-style:italic">m</span></sup>&#XA0;<span style="font-style:italic">v</span>}
</td></tr>
</table></div>
Clearly, <span class='latexinline'>
<span style="font-style:italic">K</span><sub><span style="font-style:italic">m</span></sub> &#X2286; <span style="font-style:italic">K</span><sub><span style="font-style:italic">m</span>+1</sub></span>, and there is a maximum <span class='latexinline'>
<span style="font-style:italic">K</span><sub><span style="font-style:italic">N</span></sub></span> that we can span
(the full vector space). We are interested in the smallest index <span class='latexinline'>
<span style="font-style:italic">M</span></span>
such that <span class='latexinline'>
<span style="font-style:italic">K</span><sub><span style="font-style:italic">M</span></sub> = <span style="font-style:italic">K</span><sub><span style="font-style:italic">M</span>+1</sub></span>.
We notice that <span class='latexinline'>
<span style="font-style:italic">K</span><sub><span style="font-style:italic">M</span></sub></span> is invariant under the action of <span class='latexinline'>
<span style="font-style:italic">A</span></span>.
Now, let's consider:
<div class='latexblock'><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">K</span><sub><span style="font-style:italic">m</span></sub>(<span style="font-style:italic">A</span>,&#XA0;<span style="font-style:italic">x</span>)</td><td style="text-align:left;white-space:nowrap" >&#X2261;&#XA0;<span style="font-style:italic">span</span>&#XA0;{<span style="font-style:italic">x</span>,&#XA0;<span style="font-style:italic">Ax</span>,&#XA0;<span style="font-style:italic">A</span><sup>2</sup><span style="font-style:italic">x</span>,&#XA0;&#X2026;&#XA0;<span style="font-style:italic">A</span><sup><span style="font-style:italic">m</span></sup>&#XA0;<span style="font-style:italic">x</span>&#XA0;}&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >=&#XA0;<span style="font-style:italic">span</span>&#XA0;{&#XA0;<span style="font-style:italic">A</span><sup>&#X2212;1</sup>&#XA0;<span style="font-style:italic">b</span>,&#XA0;<span style="font-style:italic">b</span>,&#XA0;<span style="font-style:italic">Ab</span>,&#XA0;&#X2026;&#XA0;<span style="font-style:italic">A</span><sup><span style="font-style:italic">m</span>&#X2212;1</sup>&#XA0;<span style="font-style:italic">x</span>&#XA0;}&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;(substitute <span style="font-style:italic">x</span> = <span style="font-style:italic">A</span><sup>&#X2212;1</sup><span style="font-style:italic">b</span>)&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >=&#XA0;<span style="font-style:italic">A</span>&#XA0;<span style="font-style:italic">span</span>&#XA0;{&#XA0;<span style="font-style:italic">A</span><sup>&#X2212;1</sup>&#XA0;<span style="font-style:italic">b</span>,&#XA0;<span style="font-style:italic">b</span>,&#XA0;<span style="font-style:italic">Ab</span>,&#XA0;&#X2026;&#XA0;<span style="font-style:italic">A</span><sup><span style="font-style:italic">m</span>&#X2212;1</sup>&#XA0;<span style="font-style:italic">b</span>}&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;(Invariance of Krylov subspace)&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >=&#XA0;<span style="font-style:italic">span</span>&#XA0;{<span style="font-style:italic">b</span>,&#XA0;<span style="font-style:italic">Ab</span>,&#XA0;&#X2026;&#XA0;<span style="font-style:italic">A</span><sup><span style="font-style:italic">m</span></sup>&#XA0;<span style="font-style:italic">b</span>}&#XA0;&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >=&#XA0;<span style="font-style:italic">K</span><sub><span style="font-style:italic">m</span></sub>(<span style="font-style:italic">A</span>,&#XA0;<span style="font-style:italic">b</span>)
</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table>
</div>
We learnt that <span class='latexinline'>
<span style="font-style:italic">Ax</span> = <span style="font-style:italic">b</span></span> has a solution in <span class='latexinline'>
<span style="font-style:italic">K</span><sub><span style="font-style:italic">m</span></sub>(<span style="font-style:italic">A</span>, <span style="font-style:italic">b</span>)</span>. Using this, we can build
solvers that exploit the Krylov subspace. We will describe GMRES and CG.
<h3><a id=generalized-minimal-residual--gmres href='#generalized-minimal-residual--gmres'> § </a> Generalized minimal residual --- GMRES</h3>
We wish to solve <span class='latexinline'>
<span style="font-style:italic">Ax</span> = <span style="font-style:italic">b</span></span> where <span class='latexinline'>
<span style="font-style:italic">A</span></span> is sparse and <span class='latexinline'>
<span style="font-style:italic">b</span></span> is normalized. The <span class='latexinline'>
<span style="font-style:italic">n</span></span>th
Krylov subspace is <span class='latexinline'>
<span style="font-style:italic">K</span><sub><span style="font-style:italic">n</span></sub>(<span style="font-style:italic">A</span>, <span style="font-style:italic">b</span>) &#X2261; <span style="font-style:italic">span</span>&#XA0;{<span style="font-style:italic">b</span>, <span style="font-style:italic">Ab</span>, <span style="font-style:italic">A</span><sup>2</sup><span style="font-style:italic">b</span>, &#X2026;, <span style="font-style:italic">A</span><sup><span style="font-style:italic">n</span></sup><span style="font-style:italic">b</span> }</span>.
We approximate the actual solution with a vector <span class='latexinline'>
<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub> &#X2208; <span style="font-style:italic">K</span><sub><span style="font-style:italic">n</span></sub>(<span style="font-style:italic">A</span>, <span style="font-style:italic">b</span>)</span>. We
define the <i>residual</i> as <span class='latexinline'>
<span style="font-style:italic">r</span><sub><span style="font-style:italic">n</span></sub> &#X2261; <span style="font-style:italic">A</span> <span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub> &#X2212; <span style="font-style:italic">b</span></span>.
<h3><a id=conjugate-gradient-descent href='#conjugate-gradient-descent'> § </a> Conjugate gradient descent</h3>
<h3><a id=good-reference-to-the-rete-pattern-matching-algorithm href='#good-reference-to-the-rete-pattern-matching-algorithm'> § </a> <a href=#good-reference-to-the-rete-pattern-matching-algorithm>
Good reference to the Rete pattern matching algorithm</a>
</h3>
The <a href=https://en.wikipedia.org/wiki/Rete_algorithm>
Rete pattern matching algorithm</a>

is an algorithm that allows matching a huge number of rules with a huge database
of "facts".
MLIR ("multi-language intermediate representation") is a new technology that
hopes to centralize much of the research and development of various compilers
into a single authoritative source. The major claim-to-fame is that it allows
one to mix various "dialects" (much as Racket does). So, to a first order
approximation, MLIR is "JSON for compiler intermediate representations".
What MLIR gets right is <i>tooling</i>. They take the experience that the LLVM project
has mined for the last decade and a half, and bake many of the good stuff that
came with LLVM right in. For example, MLIR comes in-built with a pretty printer,
a notion of types, a notion of "attributes", SSA, enforced provenance
tracking of code (so one can <i>always</i> know what the original source code was
that led to some assembly). Sound engineering might see MLIR succeed where
many others failed.
I was reminded of Rete since the MLIR folks are trying to solve the pattern
matching problem in general for their <a href=https://mlir.llvm.org/docs/GenericDAGRewriter/>
Generic DAG Rewriter</a>
.
They currently just use a worklist based algorithm. I'm trying to understand
if Rete can be used instead. Rete is famous for being hard to understand,
so I began a quest to look for good sources to implement it. I found a great
<a href=http://reports-archive.adm.cs.cmu.edu/anon/1995/CMU-CS-95-113.pdf>
PhD thesis written by Robert B. Doorenboos</a>
,
which quips:
<blockquote> Since the Rete match algorithm provides the starting point for much of the work in this thesis, this chapter describes Rete. Unfortunately, most of the descriptions of Rete in the literature are not particularly lucid,1 which is perhaps why Rete has acquired \a reputation for extreme differentialculty."(Perlin, 1990b) To remedy this situation, this chapter describes Rete in a tutorial style, rather than just briey reviewing it and referring the reader to the literature for a full description. We will first give an overview of Rete, and then discuss the principle data structures and procedures commonly used to implement it. High-level pseudocode will be given for many of the structures and procedures, so that this chapter may serve as a guide to readers who want to implement rete (or some variant) in their own systems.</blockquote>
I now have a reference to an accessible description of this stuff. I might
implement Rete to understand it, so that it's part of my toolkit if I ever
need it.
<h3><a id=leapfrog-integration href='#leapfrog-integration'> § </a> <a href=#leapfrog-integration>
Leapfrog Integration</a>
</h3>
We have a system we wish to simulate using hamilton's equations:
<div class='latexblock'><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">q</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
</table></td><td class="dcell">&#XA0;=&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">H</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">p</span></td></tr>
</table></td><td class="dcell">|<sub>(<span style="font-style:italic">p</span><sub>0</sub>,&#XA0;<span style="font-style:italic">q</span><sub>0</sub>)</sub>&#XA0;</td></tr>
</table></td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">p</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
</table></td><td class="dcell">&#XA0;=&#XA0;&#X2212;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">H</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">q</span></td></tr>
</table></td><td class="dcell">|<sub>(<span style="font-style:italic">p</span><sub>0</sub>,&#XA0;<span style="font-style:italic">q</span><sub>0</sub>)</sub>&#XA0;</td></tr>
</table></td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table>
</div>
We want to simulate a system using these differential equations. We will begin
with some initial position and momentum <span class='latexinline'>
(<span style="font-style:italic">q</span><sub>0</sub>, <span style="font-style:italic">p</span><sub>0</sub>)</span>, evaluate
<span class='latexinline'>
&#X2202; <span style="font-style:italic">q</span>/&#X2202; <span style="font-style:italic">t</span> |<sub>(<span style="font-style:italic">q</span><sub>0</sub>, <span style="font-style:italic">p</span><sub>0</sub>)</sub></span>, <span class='latexinline'>
&#X2202; <span style="font-style:italic">p</span>/&#X2202; <span style="font-style:italic">t</span> |<sub>(<span style="font-style:italic">q</span><sub>0</sub>, <span style="font-style:italic">p</span><sub>0</sub>)</sub></span>, and use
these to find <span class='latexinline'>
(<span style="font-style:italic">q</span><sub><span style="font-style:italic">next</span></sub>, <span style="font-style:italic">p</span><sub><span style="font-style:italic">next</span></sub>)</span>. An integrator is a general algorithm
that produces the next position and momentum using current information:
<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(<span style="font-style:italic">q</span><sub><span style="font-style:italic">next</span></sub>,&#XA0;<span style="font-style:italic">p</span><sub><span style="font-style:italic">next</span></sub>)&#XA0;=
<span style="font-style:italic">I</span>&#XA0;</td><td class="dcell">&#X239B;<br>
&#X239C;<br>
&#X239C;<br>
&#X239D;</td><td class="dcell"><span style="font-style:italic">q</span><sub>0</sub>,
<span style="font-style:italic">p</span><sub>0</sub>,
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">q</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
</table></td><td class="dcell">|<sub>(<span style="font-style:italic">q</span><sub>0</sub>,&#XA0;<span style="font-style:italic">p</span><sub>0</sub>)</sub>,
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">p</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
</table></td><td class="dcell">|<sub>(<span style="font-style:italic">q</span><sub>0</sub>,&#XA0;<span style="font-style:italic">p</span><sub>0</sub>)</sub>&#XA0;</td><td class="dcell">&#X239E;<br>
&#X239F;<br>
&#X239F;<br>
&#X23A0;</td></tr>
</table></div>
The design of <span class='latexinline'>
<span style="font-style:italic">I</span></span> is crucial: different choices of <span class='latexinline'>
<span style="font-style:italic">I</span></span> will have different
trade-offs for accuracy and performance. Another interesting property
we might want is for <span class='latexinline'>
<span style="font-style:italic">I</span></span> to be a <i>symplectic integrator</i> --- that is,
it preserves the total energy of the system. For example, here's a plot
of the orbits of planets using two integrators, one that's symplectic (leapfrog)
and one that isn't (Euler)
<img width=400  src="./static/leapfrog-vs-euler.png">
Notice that since leapfrog attempts to keep energy conserved, the orbits stay
as orbits! On the other hand, the euler integrator quickly spirals out, since
we lose energy during the integration. Note that this is 
<i>not an issue of numerical precision</i>: The euler integrator is ineherently 
such that over long timescales, it will lose energy. On the other hand, the
leapfrog integrator will <i>always remain stable</i>, even with very large timesteps
and low precision.
I present the equations of the leapfrog integrator, a proof sketch that it
is symplectic, and the code listing that was used to generate the above plot.
Often, code makes most ideas very clear!
<h4><a id=the-integrator href='#the-integrator'> § </a> The integrator</h4>
<h4><a id=code-listing href='#code-listing'> § </a> Code listing</h4>
<h4><a id=incantations href='#incantations'> § </a> Incantations</h4>
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> <i><font color="#222222">## Run HMC with a particular choice of potential</font></i>
<font color="#000000">3:</font> <b><u><font color="#000000">import</font></u></b> numpy as np
<font color="#000000">4:</font> <b><u><font color="#000000">from</font></u></b> matplotlib.animation <b><u><font color="#000000">import</font></u></b> FuncAnimation
<font color="#000000">5:</font> <b><u><font color="#000000">import</font></u></b> matplotlib.pyplot as plt
<font color="#000000">6:</font> <b><u><font color="#000000">import</font></u></b> numpy.linalg
<font color="#000000">7:</font> </tt></pre>
</div>

<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> <i><font color="#222222">## dq/dt = dH/dp|_{p0, q0}</font></i>
<font color="#000000">03:</font> <i><font color="#222222">## dp/dt = -dH/dq|_{p0, q0}</font></i>
<font color="#000000">04:</font> <b><u><font color="#000000">def</font></u></b> leapfrog(dhdp, dhdq, q0, p0, dt):
<font color="#000000">05:</font>     p0 += -dhdq(q0, p0) * <font color="#000000">0.5</font> * dt
<font color="#000000">06:</font> 
<font color="#000000">07:</font>     <i><font color="#222222"># full step position</font></i>
<font color="#000000">08:</font>     <i><font color="#222222"># q += dt * p</font></i>
<font color="#000000">09:</font>     q0 += dhdp(q0, p0) * dt
<font color="#000000">10:</font> 
<font color="#000000">11:</font>     <i><font color="#222222"># half step position</font></i>
<font color="#000000">12:</font>     p0 += -dhdq(q0, p0) * <font color="#000000">0.5</font> * dt
<font color="#000000">13:</font>     <b><u><font color="#000000">return</font></u></b> (q0, p0)
<font color="#000000">14:</font> </tt></pre>
</div>

For reference, we also implement an euler integrator, that uses the derivative
to compute the position and momentum of the next timestep independently.
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> <b><u><font color="#000000">def</font></u></b> euler(dhdp, dhdq, q, p, dt):
<font color="#000000">3:</font>     pnew = p + -dhdq(q, p) * dt
<font color="#000000">4:</font>     qnew = q + dhdp(q, p) * dt
<font color="#000000">5:</font>     <b><u><font color="#000000">return</font></u></b> (qnew, pnew)
<font color="#000000">6:</font> </tt></pre>
</div>

Finally, we implement <code>planet(integrator, n, dt)</code> which simulates gravitational
potential and usual kinetic energy, using the integrator given by <code>integrator</code>
for <code>n</code> steps, with each timestep taking <code>dt</code>.
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> <b><u><font color="#000000">def</font></u></b> planet(integrator, n, dt):
<font color="#000000">03:</font>     STRENGTH = <font color="#000000">0.5</font>
<font color="#000000">04:</font> 
<font color="#000000">05:</font>     <i><font color="#222222"># minimise potential V(q): q, K(p, q) p^2</font></i>
<font color="#000000">06:</font>     q = np.array([<font color="#000000">0.0</font>, <font color="#000000">1.0</font>])
<font color="#000000">07:</font>     p = np.array([-<font color="#000000">1.0</font>, <font color="#000000">0.0</font>])
<font color="#000000">08:</font> 
<font color="#000000">09:</font>     <i><font color="#222222"># H = STRENGTH * |q| (potential) + p^2/2 (kinetic)</font></i>
<font color="#000000">10:</font>     <b><u><font color="#000000">def</font></u></b> H(qcur, pcur): <b><u><font color="#000000">return</font></u></b> STRENGTH * np.linalg.norm(q) + np.dot(p, p) / <font color="#000000">2</font>
<font color="#000000">11:</font>     <b><u><font color="#000000">def</font></u></b> dhdp(qcur, pcur): <b><u><font color="#000000">return</font></u></b> p
<font color="#000000">12:</font>     <b><u><font color="#000000">def</font></u></b> dhdq(qcur, pcur): <b><u><font color="#000000">return</font></u></b> STRENGTH * <font color="#000000">2</font> * q / np.linalg.norm(q)
<font color="#000000">13:</font> 
<font color="#000000">14:</font>     qs = []
<font color="#000000">15:</font>     <b><u><font color="#000000">for</font></u></b> i <b><u><font color="#000000">in</font></u></b> range(n):
<font color="#000000">16:</font>         <b><u><font color="#000000">print</font></u></b>(<font color="#808080">"q: %10s | p: %10s | H: %6.4f"</font> % (q, p, H(q, p)))
<font color="#000000">17:</font>         (q, p) = integrator(dhdp, dhdq, q, p, dt)
<font color="#000000">18:</font>         qs.append(q.copy())
<font color="#000000">19:</font>     <b><u><font color="#000000">return</font></u></b> np.asarray(qs)
<font color="#000000">20:</font> </tt></pre>
</div>

We plot the simulations using <code>matplotlib</code> and save them.
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> NITERS = <font color="#000000">15</font>
<font color="#000000">03:</font> TIMESTEP = <font color="#000000">1</font>
<font color="#000000">04:</font> 
<font color="#000000">05:</font> <b><u><font color="#000000">print</font></u></b>(<font color="#808080">"planet simulation with leapfrog"</font>)
<font color="#000000">06:</font> planet_leapfrog = planet(leapfrog, NITERS, TIMESTEP)
<font color="#000000">07:</font> 
<font color="#000000">08:</font> plt.rcParams.update({<font color="#808080">'font.size'</font>: <font color="#000000">12</font>, <font color="#808080">'font.family'</font>:<font color="#808080">'monospace'</font>})
<font color="#000000">09:</font> fig, ax = plt.subplots()
<font color="#000000">10:</font> <b><u><font color="#000000">print</font></u></b>(planet_leapfrog)
<font color="#000000">11:</font> ax.plot(planet_leapfrog[:, <font color="#000000">0</font>], planet_leapfrog[:, <font color="#000000">1</font>], label=<font color="#808080">'leapfrog'</font>,
<font color="#000000">12:</font>         linewidth=<font color="#000000">3</font>, color=<font color="#808080">'#00ACC1'</font>)
<font color="#000000">13:</font> <b><u><font color="#000000">print</font></u></b>(<font color="#808080">"planet simulation with euler"</font>)
<font color="#000000">14:</font> planet_euler = planet(euler, NITERS, TIMESTEP)
<font color="#000000">15:</font> ax.plot(planet_euler[:, <font color="#000000">0</font>], planet_euler[:, <font color="#000000">1</font>], label=<font color="#808080">'euler'</font>,
<font color="#000000">16:</font>         linewidth=<font color="#000000">3</font>, color=<font color="#808080">'#D81B60'</font>)
<font color="#000000">17:</font> 
<font color="#000000">18:</font> legend = plt.legend(frameon=False)
<font color="#000000">19:</font> ax.set_title(<font color="#808080">"leapfrog v/s euler: NITERS=%s dt=%s"</font> % (NITERS, TIMESTEP))
<font color="#000000">20:</font> ax.spines[<font color="#808080">'top'</font>].set_visible(False)
<font color="#000000">21:</font> ax.spines[<font color="#808080">'right'</font>].set_visible(False)
<font color="#000000">22:</font> ax.spines[<font color="#808080">'bottom'</font>].set_visible(False)
<font color="#000000">23:</font> ax.spines[<font color="#808080">'left'</font>].set_visible(False)
<font color="#000000">24:</font> plt.savefig(<font color="#808080">"leapfrog-vs-euler.png"</font>)
<font color="#000000">25:</font> plt.show()
<font color="#000000">26:</font> </tt></pre>
</div>

<h3><a id=comparison-of-forward-and-reverse-mode-ad href='#comparison-of-forward-and-reverse-mode-ad'> § </a> <a href=#comparison-of-forward-and-reverse-mode-ad>
Comparison of forward and reverse mode AD</a>
</h3>
Quite a lot of ink has been spilt on this topic. My favourite reference
is the one by <a href=https://rufflewind.com/2016-12-30/reverse-mode-automatic-differentiation>
Rufflewind</a>
.
However, none of these examples have a good stock of examples for the diference.
So here, I catalogue the explicit computations between computing forward
mode AD and reverse mode AD.
In general, in forward mode AD, we fix how much the inputs wiggle with
respect to a parameter <span class='latexinline'>
<span style="font-style:italic">t</span></span>. We figure out how much the output wiggles
with respect to <span class='latexinline'>
<span style="font-style:italic">t</span></span>. If <span class='latexinline'>
<span style="font-style:italic">output</span> = <span style="font-style:italic">f</span>(<span style="font-style:italic">input</span><sub>1</sub>, <span style="font-style:italic">input</span><sub>2</sub>, &#X2026; <span style="font-style:italic">input</span><sub><span style="font-style:italic">n</span></sub>)</span>,
then <span class='latexinline'>
&#X2202; <span style="font-style:italic">output</span>/&#X2202; <span style="font-style:italic">t</span> = &#X2211;<sub><span style="font-style:italic">i</span></sub> &#X2202; <span style="font-style:italic">f</span>/&#X2202; <span style="font-style:italic">input</span><sub><span style="font-style:italic">i</span></sub> &#X2202; <span style="font-style:italic">input</span><sub><span style="font-style:italic">i</span></sub>/&#X2202; <span style="font-style:italic">dt</span></span>.
In reverse mode AD, we fix how much the parameter <span class='latexinline'>
<span style="font-style:italic">t</span></span> wiggles with
respect to the output. We figure out how much the parameter <span class='latexinline'>
<span style="font-style:italic">t</span></span>
wiggles with respect to the inputs.
If <span class='latexinline'>
<span style="font-style:italic">output</span><sub><span style="font-style:italic">i</span></sub> = <span style="font-style:italic">f</span><sub><span style="font-style:italic">i</span></sub>(<span style="font-style:italic">input</span>, &#X2026;)</span>, then <span class='latexinline'>
&#X2202; <span style="font-style:italic">t</span>/&#X2202; <span style="font-style:italic">input</span> = &#X2211;<sub><span style="font-style:italic">i</span></sub> &#X2202; <span style="font-style:italic">t</span>/&#X2202; <span style="font-style:italic">output</span><sub><span style="font-style:italic">i</span></sub> &#X2202; <span style="font-style:italic">f</span><sub><span style="font-style:italic">i</span></sub>/<span style="font-style:italic">input</span></span>.
This is a much messier expression, since we need to accumulate the data
over all outputs.
Essentially, deriving output from input is easy, since how to compute an output
from an input is documented in one place. deriving input from output is
annoying, since many outputs can depent on a single output.
The upshot is that if we have few "root outputs" (like a loss function),
we need to run AD once with respect to this, and we will get the wiggles
of <i>all inputs</i> at the same time with respect to this output, since we
compute the wiggles output to input.
The first example of <code>z = max(x, y)</code> captures the essential difference
between the two approached succinctly. Study this, and everything else will make
sense.
<h4><a id=z-maxx-y href='#z-maxx-y'> § </a> Maximum: <code>z = max(x, y)</code></h4>
<ul>
<li>
 Forward mode equations:
</li>

</ul>

<div class='latexblock'><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">z</span></td><td style="text-align:left;white-space:nowrap" >=&#XA0;<span style="font-style:italic">max</span>(<span style="font-style:italic">x</span>,&#XA0;<span style="font-style:italic">y</span>)&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">x</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
</table></td></tr>
</table></td><td style="text-align:left;white-space:nowrap" >=&#XA0;?&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">y</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
</table></td></tr>
</table></td><td style="text-align:left;white-space:nowrap" >=&#XA0;?&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">z</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
</table></td></tr>
</table></td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">=&#XA0;</td><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell">&#X23A7;<br>
&#X23AA;<br>
&#X23AA;<br>
&#X23AA;<br>
&#X23AA;<br>
&#X23A8;<br>
&#X23AA;<br>
&#X23AA;<br>
&#X23AA;<br>
&#X23AA;<br>
&#X23A9;</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">x</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
</table></td></tr>
</table></td><td style="text-align:left;white-space:nowrap" >if <span style="font-style:italic">x</span> &gt; <span style="font-style:italic">y</span>&#XA0;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">y</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
</table></td></tr>
</table></td><td style="text-align:left;white-space:nowrap" >otherwise&#XA0;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&#XA0;&#XA0;&#XA0;&#XA0;</td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table>
</div>
We can compute <span class='latexinline'>
&#X2202; <span style="font-style:italic">z</span>/&#X2202; <span style="font-style:italic">x</span></span> by setting <span class='latexinline'>
<span style="font-style:italic">t</span> = <span style="font-style:italic">x</span></span>.
That is, <span class='latexinline'>
&#X2202; <span style="font-style:italic">x</span>/&#X2202; <span style="font-style:italic">t</span> = 1, &#X2202; <span style="font-style:italic">y</span>/&#X2202; <span style="font-style:italic">t</span> = 0</span>.
Similarly, can compute <span class='latexinline'>
&#X2202; <span style="font-style:italic">z</span>/&#X2202; <span style="font-style:italic">y</span></span> by setting <span class='latexinline'>
<span style="font-style:italic">t</span> = <span style="font-style:italic">y</span></span>.
That is, <span class='latexinline'>
&#X2202; <span style="font-style:italic">x</span>/&#X2202; <span style="font-style:italic">t</span> = 1, &#X2202; <span style="font-style:italic">y</span>/&#X2202; <span style="font-style:italic">t</span> = 0</span>.
If we want both gradients <span class='latexinline'>
&#X2202; <span style="font-style:italic">z</span>/&#X2202; <span style="font-style:italic">x</span>, &#X2202; <span style="font-style:italic">z</span>/&#X2202; <span style="font-style:italic">y</span></span>,
we will have to <b>rerun the above equations twice</b> with the two initializations.
In our equations, we are saying that we know how sensitive
the inputs <span class='latexinline'>
<span style="font-style:italic">x</span>, <span style="font-style:italic">y</span></span> are to a given parameter <span class='latexinline'>
<span style="font-style:italic">t</span></span>. We are deriving how sensitive
the output <span class='latexinline'>
<span style="font-style:italic">z</span></span> is to the parameter <span class='latexinline'>
<span style="font-style:italic">t</span></span> as a composition of <span class='latexinline'>
<span style="font-style:italic">x</span>, <span style="font-style:italic">y</span></span>. If
<span class='latexinline'>
<span style="font-style:italic">x</span> &gt; <span style="font-style:italic">y</span></span>, then we know that <span class='latexinline'>
<span style="font-style:italic">z</span></span> is as sensitive to <span class='latexinline'>
<span style="font-style:italic">t</span></span> as <span class='latexinline'>
<span style="font-style:italic">x</span></span> is.
<ul>
<li>
 Reverse mode equations:
</li>

</ul>

<div class='latexblock'><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">z</span></td><td style="text-align:left;white-space:nowrap" >=&#XA0;<span style="font-style:italic">max</span>(<span style="font-style:italic">x</span>,&#XA0;<span style="font-style:italic">y</span>)&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">z</span></td></tr>
</table></td></tr>
</table></td><td style="text-align:left;white-space:nowrap" >=&#XA0;?&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">x</span></td></tr>
</table></td></tr>
</table></td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">=&#XA0;</td><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell">&#X23A7;<br>
&#X23AA;<br>
&#X23AA;<br>
&#X23A8;<br>
&#X23AA;<br>
&#X23AA;<br>
&#X23A9;</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">&#XA0;&#XA0;&#XA0;&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">z</span></td></tr>
</table></td></tr>
</table></td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">if</span> <span style="font-style:italic">x</span> &gt; <span style="font-style:italic">y</span>&#XA0;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&#XA0;&#XA0;&#XA0;&#XA0;0</td><td style="text-align:left;white-space:nowrap" >otherwise
</td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">y</span></td></tr>
</table></td></tr>
</table></td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">=&#XA0;</td><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell">&#X23A7;<br>
&#X23AA;<br>
&#X23AA;<br>
&#X23A8;<br>
&#X23AA;<br>
&#X23AA;<br>
&#X23A9;</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">&#XA0;&#XA0;&#XA0;&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">z</span></td></tr>
</table></td></tr>
</table></td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">if</span> <span style="font-style:italic">y</span> &gt; <span style="font-style:italic">x</span>&#XA0;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&#XA0;&#XA0;&#XA0;&#XA0;0</td><td style="text-align:left;white-space:nowrap" >otherwise
</td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table>
</div>
We can compute <span class='latexinline'>
&#X2202; <span style="font-style:italic">z</span>/&#X2202; <span style="font-style:italic">x</span>, &#X2202; <span style="font-style:italic">z</span>/&#X2202; <span style="font-style:italic">y</span></span>
<b>in one shot</b> by setting <span class='latexinline'>
<span style="font-style:italic">t</span> = <span style="font-style:italic">z</span></span>. That is, <span class='latexinline'>
&#X2202; <span style="font-style:italic">z</span>/&#X2202; <span style="font-style:italic">t</span> = 1</span>.
In our equations, we are saying that we know how sensitive
the parameter <span class='latexinline'>
<span style="font-style:italic">t</span></span> is to a given output <span class='latexinline'>
<span style="font-style:italic">z</span></span>. We are trying to see
how sensitive <span class='latexinline'>
<span style="font-style:italic">t</span></span> is to the inputs <span class='latexinline'>
<span style="font-style:italic">x</span>, <span style="font-style:italic">y</span></span>. If <span class='latexinline'>
<span style="font-style:italic">x</span></span> is active (ie, <span class='latexinline'>
<span style="font-style:italic">x</span> &gt; <span style="font-style:italic">y</span></span>),
then <span class='latexinline'>
<span style="font-style:italic">t</span></span> is indeed sensitive to <span class='latexinline'>
<span style="font-style:italic">x</span></span> and <span class='latexinline'>
&#X2202; <span style="font-style:italic">t</span>/&#X2202; <span style="font-style:italic">x</span> = 1</span>.
Otherwise, it is not sensitive, and <span class='latexinline'>
&#X2202; <span style="font-style:italic">t</span>/&#X2202; <span style="font-style:italic">x</span> = 0</span>.
<h4><a id=z-sinx href='#z-sinx'> § </a> sin: <code>z = sin(x)</code></h4>
<ul>
<li>
 Forward mode equations:
</li>

</ul>

<div class='latexblock'><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">z</span></td><td style="text-align:left;white-space:nowrap" >=&#XA0;<span style="font-style:italic">sin</span>(<span style="font-style:italic">x</span>)&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">x</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
</table></td></tr>
</table></td><td style="text-align:left;white-space:nowrap" >=&#XA0;?&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">z</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
</table></td></tr>
</table></td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">=&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">z</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">x</span></td></tr>
</table></td><td class="dcell">&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">x</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
</table></td><td class="dcell">&#XA0;</td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">=&#XA0;<span style="font-style:italic">cos</span>(<span style="font-style:italic">x</span>)&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">x</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
</table></td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table>
</div>
We can compute <span class='latexinline'>
&#X2202; <span style="font-style:italic">z</span>/&#X2202; <span style="font-style:italic">x</span></span> by setting <span class='latexinline'>
<span style="font-style:italic">t</span> = <span style="font-style:italic">x</span></span>.
That is, setting <span class='latexinline'>
&#X2202; <span style="font-style:italic">x</span>/&#X2202; <span style="font-style:italic">t</span> = 1</span>.
<ul>
<li>
 Reverse mode equations:
</li>

</ul>

<div class='latexblock'><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">z</span></td><td style="text-align:left;white-space:nowrap" >=&#XA0;<span style="font-style:italic">sin</span>(<span style="font-style:italic">x</span>)&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">z</span></td></tr>
</table></td></tr>
</table></td><td style="text-align:left;white-space:nowrap" >=&#XA0;?&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">x</span></td></tr>
</table></td></tr>
</table></td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">=&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">z</span></td></tr>
</table></td><td class="dcell">&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">z</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">x</span></td></tr>
</table></td><td class="dcell">&#XA0;</td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">=&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">z</span></td></tr>
</table></td><td class="dcell">&#XA0;<span style="font-style:italic">cos</span>(<span style="font-style:italic">x</span>)
</td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table>
</div>
We can compute <span class='latexinline'>
&#X2202; <span style="font-style:italic">z</span>/&#X2202; <span style="font-style:italic">x</span></span> by setting <span class='latexinline'>
<span style="font-style:italic">t</span> = <span style="font-style:italic">z</span></span>.
That is, setting <span class='latexinline'>
&#X2202; <span style="font-style:italic">z</span>/&#X2202; <span style="font-style:italic">t</span> = 1</span>.
<h4><a id=x-y- href='#x-y-'> § </a> addition: <code>z = x + y</code>:</h4>
<ul>
<li>
 Forward mode equations:
</li>

</ul>

<div class='latexblock'><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">z</span></td><td style="text-align:left;white-space:nowrap" >=&#XA0;<span style="font-style:italic">x</span>&#XA0;+&#XA0;<span style="font-style:italic">y</span>&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">x</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
</table></td></tr>
</table></td><td style="text-align:left;white-space:nowrap" >=&#XA0;?&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">y</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
</table></td></tr>
</table></td><td style="text-align:left;white-space:nowrap" >=&#XA0;?&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">z</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
</table></td></tr>
</table></td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">=&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">z</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">x</span></td></tr>
</table></td><td class="dcell">&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">x</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
</table></td><td class="dcell">&#XA0;+
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">z</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">y</span></td></tr>
</table></td><td class="dcell">&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">y</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
</table></td><td class="dcell">&#XA0;</td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">=&#XA0;1&#XA0;&#XB7;&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">x</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
</table></td><td class="dcell">&#XA0;+&#XA0;1&#XA0;&#XB7;&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">y</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
</table></td><td class="dcell">
=&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">x</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
</table></td><td class="dcell">&#XA0;+&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">y</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
</table></td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table>
</div>
<ul>
<li>
 Reverse mode equations:
</li>

</ul>

<div class='latexblock'><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">z</span></td><td style="text-align:left;white-space:nowrap" >=&#XA0;<span style="font-style:italic">x</span>&#XA0;+&#XA0;<span style="font-style:italic">y</span>&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">z</span></td></tr>
</table></td></tr>
</table></td><td style="text-align:left;white-space:nowrap" >=&#XA0;?&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">x</span></td></tr>
</table></td></tr>
</table></td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">=&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">z</span></td></tr>
</table></td><td class="dcell">&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">z</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">x</span></td></tr>
</table></td><td class="dcell">&#XA0;</td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">=&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">z</span></td></tr>
</table></td><td class="dcell">&#XA0;&#XB7;&#XA0;1&#XA0;=&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">z</span></td></tr>
</table></td><td class="dcell">&#XA0;</td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">y</span></td></tr>
</table></td></tr>
</table></td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">=&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">z</span></td></tr>
</table></td><td class="dcell">&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">z</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">y</span></td></tr>
</table></td><td class="dcell">&#XA0;</td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">=&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">z</span></td></tr>
</table></td><td class="dcell">&#XA0;&#XB7;&#XA0;1&#XA0;=&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">z</span></td></tr>
</table></td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table>
</div>
<h4><a id=z-xyplication- href='#z-xyplication-'> § </a> multiplication: <code>z = xy</code></h4>
<ul>
<li>
 Forward mode equations:
</li>

</ul>

<div class='latexblock'><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">z</span></td><td style="text-align:left;white-space:nowrap" >=&#XA0;<span style="font-style:italic">x</span>&#XA0;<span style="font-style:italic">y</span>&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">x</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
</table></td></tr>
</table></td><td style="text-align:left;white-space:nowrap" >=&#XA0;?&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">y</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
</table></td></tr>
</table></td><td style="text-align:left;white-space:nowrap" >=&#XA0;?&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">z</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
</table></td></tr>
</table></td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">=&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">z</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">x</span></td></tr>
</table></td><td class="dcell">&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">x</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
</table></td><td class="dcell">&#XA0;+
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">z</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">y</span></td></tr>
</table></td><td class="dcell">&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">y</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
</table></td><td class="dcell">&#XA0;</td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">=&#XA0;<span style="font-style:italic">y</span>&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">x</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
</table></td><td class="dcell">&#XA0;+&#XA0;<span style="font-style:italic">x</span>&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">y</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
</table></td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table>
</div>
<ul>
<li>
 Reverse mode equations:
</li>

</ul>

<div class='latexblock'><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">z</span></td><td style="text-align:left;white-space:nowrap" >=&#XA0;<span style="font-style:italic">x</span>&#XA0;<span style="font-style:italic">y</span>&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">z</span></td></tr>
</table></td></tr>
</table></td><td style="text-align:left;white-space:nowrap" >=&#XA0;?&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">x</span></td></tr>
</table></td></tr>
</table></td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">=&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">z</span></td></tr>
</table></td><td class="dcell">&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">z</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">x</span></td></tr>
</table></td><td class="dcell">
=&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">z</span></td></tr>
</table></td><td class="dcell">&#XA0;&#XB7;&#XA0;<span style="font-style:italic">y</span>&#XA0;</td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">y</span></td></tr>
</table></td></tr>
</table></td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">=&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">z</span></td></tr>
</table></td><td class="dcell">&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">z</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">y</span></td></tr>
</table></td><td class="dcell">
=&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">z</span></td></tr>
</table></td><td class="dcell">&#XA0;&#XB7;&#XA0;<span style="font-style:italic">x</span>
</td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table>
</div>
<h4><a id=x--yion- href='#x--yion-'> § </a> subtraction: <code>z = x - y</code>:</h4>
<ul>
<li>
 Forward mode equations:
</li>

</ul>

<div class='latexblock'><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">z</span></td><td style="text-align:left;white-space:nowrap" >=&#XA0;<span style="font-style:italic">x</span>&#XA0;+&#XA0;<span style="font-style:italic">y</span>&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">x</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
</table></td></tr>
</table></td><td style="text-align:left;white-space:nowrap" >=&#XA0;?&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">y</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
</table></td></tr>
</table></td><td style="text-align:left;white-space:nowrap" >=&#XA0;?&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">z</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
</table></td></tr>
</table></td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">=&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">z</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">x</span></td></tr>
</table></td><td class="dcell">&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">x</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
</table></td><td class="dcell">&#XA0;&#X2212;
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">z</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">y</span></td></tr>
</table></td><td class="dcell">&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">y</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
</table></td><td class="dcell">&#XA0;</td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">=&#XA0;1&#XA0;&#XB7;&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">x</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
</table></td><td class="dcell">&#XA0;&#X2212;&#XA0;1&#XA0;&#XB7;&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">y</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
</table></td><td class="dcell">
=&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">x</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
</table></td><td class="dcell">&#XA0;&#X2212;&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">y</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
</table></td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table>
</div>
<ul>
<li>
 Reverse mode equations:
</li>

</ul>

<div class='latexblock'><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">z</span></td><td style="text-align:left;white-space:nowrap" >=&#XA0;<span style="font-style:italic">x</span>&#XA0;&#X2212;&#XA0;<span style="font-style:italic">y</span>&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">z</span></td></tr>
</table></td></tr>
</table></td><td style="text-align:left;white-space:nowrap" >=&#XA0;?&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">x</span></td></tr>
</table></td></tr>
</table></td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">=&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">z</span></td></tr>
</table></td><td class="dcell">&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">z</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">x</span></td></tr>
</table></td><td class="dcell">&#XA0;</td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">=&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">z</span></td></tr>
</table></td><td class="dcell">&#XA0;&#XB7;&#XA0;1&#XA0;=&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">z</span></td></tr>
</table></td><td class="dcell">&#XA0;</td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">y</span></td></tr>
</table></td></tr>
</table></td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">=&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">z</span></td></tr>
</table></td><td class="dcell">&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">z</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">y</span></td></tr>
</table></td><td class="dcell">&#XA0;</td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">=&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">z</span></td></tr>
</table></td><td class="dcell">&#XA0;&#XB7;&#XA0;&#X2212;1&#XA0;=&#XA0;&#X2212;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">t</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&#X2202;&#XA0;<span style="font-style:italic">z</span></td></tr>
</table></td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table>
</div>
<h3><a id=an-invitation-to-homology-and-cohomology-part-1--homology href='#an-invitation-to-homology-and-cohomology-part-1--homology'> § </a> <a href=#an-invitation-to-homology-and-cohomology-part-1--homology>
An invitation to homology and cohomology, Part 1 --- Homology</a>
</h3>
There are many introductions to homology on the internet, but none of them
really met my criteria for being simple, picture filled, and getting the
basic ideas across. I feel that Hatcher might come closest to what I want
(and where I originally learnt the material), but their description of homology
is surrounded by the context of Algebraic Topology, while really, simplicial
homology is accessible to anyone who has seen some linear algebra and group
theory. This is my attempt to get the ideas across.
Let's first try to understand what we're trying to do here. We want to detect
holes in a space, broadly construed. We focus in <i>simplicial complexes</i>, which
are collections of triangles and triangle-like objects in higher (and lower)
dimensions. We define what holes are for these simplicial complexes, and we then
try to find algebraic objects that allow us to "detect" these holes.
<h4><a id=simplices href='#simplices'> § </a> Simplices</h4>
<ul>
<li>
 A 0-simplex is a point
</li>

</ul>

<img src="static/simplices/0-simplex.svg">
<ul>
<li>
 A 1-simplex is a line
</li>

</ul>

<img src="static/simplices/1-simplex.svg">
<ul>
<li>
 A 2-simplex is a filled triangle
</li>

</ul>

<img src="static/simplices/2-simplex.svg">
<ul>
<li>
 A 3-simplex is a solid tetrahedra
</li>

</ul>

<img src="static/simplices/3-simplex.svg">
<ul>
<li>
 A <span class='latexinline'>
<span style="font-style:italic">k</span></span>-dimensional simplex is the convex hull of <span class='latexinline'>
<span style="font-style:italic">k</span>+1</span>
  linearly independent points <span class='latexinline'>
(<span style="font-style:italic">u</span><sub><span style="font-style:italic">i</span></sub> &#X2208; &#X211D;<sup><span style="font-style:italic">k</span>+1</sup>)</span>
  in <span class='latexinline'>
<span style="font-style:italic">k</span>+1</span> dimensional space.
  <span class='latexinline'>
 <span style="font-style:italic">S</span><sub><span style="font-style:italic">k</span></sub> &#X2261; <br>
 &#X2211;&#X3B8;<sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">u</span><sub><span style="font-style:italic">i</span></sub> &#XA0;&#X2223;&#XA0; &#X3B8;<sub><span style="font-style:italic">i</span></sub> &#X2265; 0, &#XA0; &#X2211;<sub><span style="font-style:italic">i</span></sub> &#X3B8;<sub><span style="font-style:italic">i</span></sub> = 1 <br>
 </span>
</li>

</ul>

<h4><a id=simplicial-complexes href='#simplicial-complexes'> § </a> Simplicial complexes</h4>
A simplicial complex <span class='latexinline'>
<span style="font-style:italic">K</span></span> is a collection of simplices where:
<ul>
<li>
 (1) Every boundary of a simplex from <span class='latexinline'>
<span style="font-style:italic">K</span></span> is in <span class='latexinline'>
<span style="font-style:italic">K</span></span>
</li>
<li>
 (2) The intersection of any two simplices in <span class='latexinline'>
<span style="font-style:italic">K</span></span> is also in <span class='latexinline'>
<span style="font-style:italic">K</span></span>
</li>

</ul>

Examples of simplicial complexes:
<ul>
<li>
 Every simplex is trivially a simplicial complex.
</li>

</ul>

<img width=200 height=200 src="static/simplices/complex-0-simplices.svg">
<ul>
<li>
 A collection of points is a simplicial complex with all simplices of degree <span class='latexinline'>
0</span>.
</li>

</ul>

<img width=200 height=200 src="static/simplices/complex-unfilled-triangle.svg">
<ul>
<li>
 An unfilled triangle is a simplicial complex with simplices of degree <span class='latexinline'>
0</span>, <span class='latexinline'>
1</span>.
</li>

</ul>

<img width=200 height=200 src="static/simplices/complex-unfilled-butterfly.svg">
<ul>
<li>
 Non-triangular shapes such  as this "butterfly" are also simplicial complexes,
  this one of degree <span class='latexinline'>
0</span>, <span class='latexinline'>
1</span>.
</li>

</ul>

<img width=200 height=200 src="static/simplices/complex-half-filled-butterfly.svg">
<ul>
<li>
 This is the same shape as the unfilled butterly, except now containing a
  simplex of degree 2: the filling in of the bottom of the butterfly.
</li>

</ul>

Non-examples of simplicial complexes are:
<img width=200 height=200 src="static/simplices/non-simplex-1.svg">
<ul>
<li>
 This does not contain the point at the lower-left corner, which should exist
  since it is a boundary of the straight line. This violates rule (1):
  Every boundary of a simplex from <span class='latexinline'>
<span style="font-style:italic">K</span></span> is in <span class='latexinline'>
<span style="font-style:italic">K</span></span>
</li>

</ul>

<img width=200 height=200 src="static/simplices/non-simplex-2.svg">
<ul>
<li>
 This does not contain the points which are at the intersection of the
  triangle and the line. This violates rule (2):
  The intersection of any two simplices in <span class='latexinline'>
<span style="font-style:italic">K</span></span> is also in <span class='latexinline'>
<span style="font-style:italic">K</span></span>.
</li>

</ul>

<h4><a id=holes-in-a-space-homology-of-a-triangle href='#holes-in-a-space-homology-of-a-triangle'> § </a> Holes in a space: Homology of a triangle</h4>
Let's consider the simplest possible case of computing the homlogy, and we
do so, we will expand on what homology <i>is</i>, and what we're trying to do.
<img width=200 height=200 src="static/simplices/homology-triangle-edges.svg">
Look at the triangle above. We have the red, green, and blue vertices, which
I'll notate <span class='latexinline'>
<span style="font-style:italic">r</span>, <span style="font-style:italic">g</span>, <span style="font-style:italic">b</span></span>. We also have the edges that are orange (<span class='latexinline'>
<span style="font-style:italic">o</span></span>), cyan (<span class='latexinline'>
<span style="font-style:italic">c</span></span>), and
magenta (<span class='latexinline'>
<span style="font-style:italic">m</span></span>).
What we are interested in doing is to be able to detect the "hole" in the
triangle in between the edges <code>o-m-c</code>. That is, we want some algorithm which
when offered the representation of the triangle, can somehow detect the hole.
Note that the hole doesn't really depend on the length of the edges. We can
"bend and stretch" the triangle, and the hole will still exist. The only way
to destroy the hole is to either <i>cut</i> the triangle, or <i>fill in</i> the triangle.
We first need to agree on an abstract <i>representation</i> of the triangle,
which ideally does not change if we were to stretch out the edges,
before we can discuss how we can detect the existence of the hole.
<h4><a id=representation-of-the-triangle-boundary-operators href='#representation-of-the-triangle-boundary-operators'> § </a> Representation of the triangle: boundary operators</h4>
We first describe the shape of the triangle in terms
of two sets, <span class='latexinline'>
<span style="font-style:italic">E</span></span> and <span class='latexinline'>
<span style="font-style:italic">V</span></span> representing the edges and the vertices, and
a function <span class='latexinline'>
&#X2202;<sub><span style="font-style:italic">EV</span></sub></span>, called as the
boundary operator, which tells us how edges
are glued to vertices.
We first have a ground set of edges <span class='latexinline'>
<span style="font-style:italic">E</span> &#X2261; <br>
<span style="font-style:italic">o</span>, <span style="font-style:italic">m</span>, <span style="font-style:italic">c</span><br>
</span> and a set of
vertices <span class='latexinline'>
<span style="font-style:italic">V</span> &#X2261; <br>
<span style="font-style:italic">r</span>, <span style="font-style:italic">g</span>, <span style="font-style:italic">b</span> <br>
</span>.
What we now need is to know how the edges are connected to the vertices,
since that's what really makes a triangle. We would like to say something
like "the boundary of the edge <span class='latexinline'>
<span style="font-style:italic">o</span></span> has points <span class='latexinline'>
<span style="font-style:italic">r</span>, <span style="font-style:italic">g</span></span>". In fact, we have
slightly more information than that: the <i>orientation</i>. So what we
really ought to be saying is "the edge <span class='latexinline'>
<span style="font-style:italic">o</span></span> points from <span class='latexinline'>
<span style="font-style:italic">g</span></span> to <span class='latexinline'>
<span style="font-style:italic">r</span></span>".
To do this, we create a map from <span class='latexinline'>
<span style="font-style:italic">o</span></span> to <span class='latexinline'>
<span style="font-style:italic">r</span> &#X2212; <span style="font-style:italic">g</span></span>, where we think of <span class='latexinline'>
<span style="font-style:italic">o</span></span>
as a "vector", pointing from <span class='latexinline'>
<span style="font-style:italic">g</span></span> to <span class='latexinline'>
<span style="font-style:italic">r</span></span>. But hang on, what <i>is</i> <span class='latexinline'>
<span style="font-style:italic">r</span> &#X2212; <span style="font-style:italic">g</span></span>?
we don't have a mathematical structure on <span class='latexinline'>
<span style="font-style:italic">V</span></span> that lets us add and subtract
vertices. So, we <i>create</i> a new set <span class='latexinline'>
<span style="color:red"><span style="font-style:italic">V</span></span></span>, which represents linear
combinations of vertices in <span class='latexinline'>
<span style="font-style:italic">V</span></span>. Similarly, anticipating some future
development, we also <i>create</i> a new set <span class='latexinline'>
<span style="color:red"><span style="font-style:italic">E</span></span></span> of linear combinations
of edges <span class='latexinline'>
<span style="font-style:italic">E</span></span>.
<h4><a id=formal-definition-of-the-boundary-operator href='#formal-definition-of-the-boundary-operator'> § </a> Formal definition of the boundary operator</h4>
We define <span class='latexinline'>
<span style="color:red"><span style="font-style:italic">E</span></span> &#X2261; &#X2124; &#XD7; &#X2124; &#XD7; &#X2124;</span>
that represents linear combinations of edges. For example, <span class='latexinline'>
(1, 2, 3) &#X2208; <span style="color:red"><span style="font-style:italic">E</span></span></span>
represents <span class='latexinline'>
<span style="font-style:italic">o</span> + 2<span style="font-style:italic">m</span> + 3<span style="font-style:italic">c</span></span> --- that is, take 1 copy of the orange edge, 2
copies of the magenta edge, and 3 copies of the cyan edge.
We define <span class='latexinline'>
<span style="color:red"><span style="font-style:italic">V</span></span> &#X2261; &#X2124; &#XD7; &#X2124; &#XD7; &#X2124;</span>
which represents linear combinations of vertices. For example,
<span class='latexinline'>
(1, &#X2212;1, 2) &#X2208; <span style="font-style:italic">V</span></span> represents <span class='latexinline'>
<span style="font-style:italic">r</span> &#X2212; <span style="font-style:italic">g</span> + 2<span style="font-style:italic">b</span></span> --- that is, take a copy of the
red vertex, subtract the green vertex, and add two copies of the blue vertex.
The boundary operator <span class='latexinline'>
&#X2202;<sub><span style="font-style:italic">EV</span></sub>: <span style="color:red"><span style="font-style:italic">E</span></span> &#X2192; <span style="color:red"><span style="font-style:italic">V</span></span></span> is
depicted in the picture. This operator sends edges to their <i>boundary</i>, and is
therefore called the <i>boundary operator</i>.  The <i>boundary</i> of an edge describes
the edge in terms of vertices, just like we would describe a direction vector
(to borrow physics parlance) by subtracting points.
The action of the operator on a linear combination of edges is:
<div class='latexblock'><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&#X2202;<sub><span style="font-style:italic">EV</span></sub>:&#XA0;<span style="color:red"><span style="font-style:italic">E</span></span>&#XA0;&#X2192;&#XA0;<span style="color:red"><span style="font-style:italic">V</span></span>&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&#X2202;<sub><span style="font-style:italic">EV</span></sub>(1,&#XA0;0,&#XA0;0)&#XA0;&#X2261;&#XA0;(1,&#XA0;&#X2212;1,&#XA0;0)&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;<span style="font-style:italic">o</span>&#XA0;&#X21A6;&#XA0;<span style="font-style:italic">r</span>&#XA0;&#X2212;&#XA0;<span style="font-style:italic">g</span>&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&#X2202;<sub><span style="font-style:italic">EV</span></sub>(0,&#XA0;1,&#XA0;0)&#XA0;&#X2261;&#XA0;(&#X2212;1,&#XA0;0,&#XA0;1)&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;<span style="font-style:italic">m</span>&#XA0;&#X21A6;&#XA0;<span style="font-style:italic">b</span>&#XA0;&#X2212;&#XA0;<span style="font-style:italic">r</span>&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&#X2202;<sub><span style="font-style:italic">EV</span></sub>(0,&#XA0;0,&#XA0;1)&#XA0;&#X2261;&#XA0;(0,&#XA0;1,&#XA0;&#X2212;1)&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;<span style="font-style:italic">c</span>&#XA0;&#X21A6;&#XA0;<span style="font-style:italic">b</span>&#XA0;&#X2212;&#XA0;<span style="font-style:italic">g</span>&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >(Extend using linearity)&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&#X2202;<sub><span style="font-style:italic">EV</span></sub>(<span style="font-style:italic">s</span>,&#XA0;<span style="font-style:italic">t</span>,&#XA0;<span style="font-style:italic">u</span>)&#XA0;&#X2261;
<span style="font-style:italic">s</span>&#XA0;&#X2202;<sub><span style="font-style:italic">EV</span></sub>(1,&#XA0;0,&#XA0;0)&#XA0;+
<span style="font-style:italic">t</span>&#XA0;&#X2202;<sub><span style="font-style:italic">EV</span></sub>(0,&#XA0;1,&#XA0;0)&#XA0;+
<span style="font-style:italic">u</span>&#XA0;&#X2202;<sub><span style="font-style:italic">EV</span></sub>(0,&#XA0;0,&#XA0;1)&#XA0;=&#XA0;(<span style="font-style:italic">s</span>&#XA0;&#X2212;&#XA0;<span style="font-style:italic">t</span>,&#XA0;<span style="font-style:italic">u</span>&#XA0;&#X2212;&#XA0;<span style="font-style:italic">s</span>,&#XA0;<span style="font-style:italic">t</span>&#XA0;&#X2212;&#XA0;<span style="font-style:italic">u</span>)
</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table>
</div>
Now, notice that to traverse the cycle, we should traverse the orange edge,
then the magenta edge, then the cyan edge, in that direction. That is,
the cycle can be thought of as <span class='latexinline'>
<span style="font-style:italic">o</span> + <span style="font-style:italic">m</span> + <span style="font-style:italic">c</span></span>. However, how do we <i>detect</i> this
cycle? The key idea is that if we look at the
<i>image of the cycle <span class='latexinline'>
<span style="font-style:italic">o</span> + <span style="font-style:italic">m</span> + <span style="font-style:italic">c</span></span> under the boundary operator</i> <span class='latexinline'>
&#X2202;<sub><span style="font-style:italic">EV</span></sub></span>,
we will get <span class='latexinline'>
0</span>! For us to have completed a cycle, we must have both
entered and exited each vertex, so the total sum must be <span class='latexinline'>
0</span>.
Formally:
<div class='latexblock'><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&#X2202;<sub><span style="font-style:italic">EV</span></sub>(<span style="font-style:italic">s</span>,&#XA0;<span style="font-style:italic">t</span>,&#XA0;<span style="font-style:italic">u</span>)&#XA0;&#X2261;&#XA0;(<span style="font-style:italic">s</span>&#XA0;&#X2212;&#XA0;<span style="font-style:italic">t</span>,&#XA0;<span style="font-style:italic">u</span>&#XA0;&#X2212;&#XA0;<span style="font-style:italic">s</span>,&#XA0;<span style="font-style:italic">t</span>&#XA0;&#X2212;&#XA0;<span style="font-style:italic">u</span>)&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">o</span>&#XA0;+&#XA0;<span style="font-style:italic">m</span>&#XA0;+&#XA0;<span style="font-style:italic">c</span>&#XA0;=&#XA0;(1,&#XA0;1,&#XA0;1)&#XA0;&#X2208;&#XA0;<span style="color:red"><span style="font-style:italic">E</span></span>&#XA0;&#XA0;&#XA0;
&#X2202;<sub><span style="font-style:italic">EV</span></sub>((1,&#XA0;1,&#XA0;1)&#XA0;=&#XA0;(1&#XA0;&#X2212;&#XA0;1,&#XA0;1&#XA0;&#X2212;&#XA0;1,&#XA0;1&#XA0;&#X2212;&#XA0;1)&#XA0;=&#XA0;(0,&#XA0;0,&#XA0;0)
</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table>
</div>
<h4><a id=formal-definition-of-cycles href='#formal-definition-of-cycles'> § </a> Formal definition of cycles</h4>
This is very nice, since we have converted the topological invariant
of a <i>hole in the space</i> into an algebraic invariant of "linear combination
of edges that map to 0". That is, we want to consider all thoose loops
that belong to the <i>kernel</i> of <span class='latexinline'>
&#X2202;<sub><span style="font-style:italic">EV</span></sub></span>. (Terminology:
the kernel of a linear transformation is the set of all things in the domain
which map to zero)
So, we define (tentatively) the first homology group:
<div class='latexblock'><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">H</span><sub>1</sub>&#XA0;&#X2261;&#XA0;<span style="font-style:italic">Kernel</span>(&#X2202;<sub><span style="font-style:italic">EV</span></sub>)&#XA0;&#X2261;
</td><td class="dcell">&#X23A7;<br>
&#X23A8;<br>
&#X23A9;</td><td class="dcell">(<span style="font-style:italic">a</span>,&#XA0;<span style="font-style:italic">b</span>,&#XA0;<span style="font-style:italic">c</span>)&#XA0;&#X2208;&#XA0;<span style="color:red"><span style="font-style:italic">E</span></span>&#XA0;&#X2223;&#XA0;&#X2202;<sub><span style="font-style:italic">E</span></sub><span style="font-style:italic">V</span>((<span style="font-style:italic">a</span>,&#XA0;<span style="font-style:italic">b</span>,&#XA0;<span style="font-style:italic">c</span>))&#XA0;=&#XA0;(0,&#XA0;0,&#XA0;0)&#XA0;</td><td class="dcell">&#X23AB;<br>
&#X23AC;<br>
&#X23AD;</td><td class="dcell">&#X2282;&#XA0;<span style="color:red"><span style="font-style:italic">E</span></span>
</td></tr>
</table></td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table>
</div>
If we try to compute this, we will have to have:
<div class='latexblock'><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">H</span><sub>1</sub></td><td style="text-align:left;white-space:nowrap" >&#X2261;&#XA0;<span style="font-style:italic">Kernel</span>(&#X2202;<sub><span style="font-style:italic">EV</span></sub>)&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >=&#XA0;{&#XA0;(<span style="font-style:italic">s</span>,&#XA0;<span style="font-style:italic">t</span>,&#XA0;<span style="font-style:italic">u</span>)&#XA0;&#XA0;&#X2223;&#XA0;&#XA0;&#X2202;<sub><span style="font-style:italic">EV</span></sub>(<span style="font-style:italic">s</span>,&#XA0;<span style="font-style:italic">t</span>,&#XA0;<span style="font-style:italic">u</span>)&#XA0;=&#XA0;(0,&#XA0;0,&#XA0;0)&#XA0;&#XA0;&#XA0;<span style="font-style:italic">s</span>,&#XA0;<span style="font-style:italic">t</span>,&#XA0;<span style="font-style:italic">u</span>&#XA0;&#X2208;&#XA0;&#X2124;&#XA0;}&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >=&#XA0;{&#XA0;(<span style="font-style:italic">s</span>,&#XA0;<span style="font-style:italic">t</span>,&#XA0;<span style="font-style:italic">u</span>)&#XA0;&#XA0;&#X2223;&#XA0;&#XA0;(<span style="font-style:italic">s</span>&#X2212;<span style="font-style:italic">t</span>,&#XA0;<span style="font-style:italic">u</span>&#X2212;<span style="font-style:italic">s</span>,&#XA0;<span style="font-style:italic">t</span>&#X2212;<span style="font-style:italic">u</span>)&#XA0;=&#XA0;(0,&#XA0;0,&#XA0;0)&#XA0;&#XA0;&#XA0;<span style="font-style:italic">s</span>,&#XA0;<span style="font-style:italic">t</span>,&#XA0;<span style="font-style:italic">u</span>&#XA0;&#X2208;&#XA0;&#X2124;&#XA0;&#XA0;}&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >=&#XA0;{&#XA0;(<span style="font-style:italic">s</span>,&#XA0;<span style="font-style:italic">t</span>,&#XA0;<span style="font-style:italic">u</span>)&#XA0;&#XA0;&#X2223;&#XA0;&#XA0;<span style="font-style:italic">s</span>&#XA0;=&#XA0;<span style="font-style:italic">t</span>&#XA0;=&#XA0;<span style="font-style:italic">u</span>&#XA0;&#XA0;&#XA0;&#XA0;<span style="font-style:italic">s</span>,&#XA0;<span style="font-style:italic">t</span>,&#XA0;<span style="font-style:italic">u</span>&#XA0;&#X2208;&#XA0;&#X2124;&#XA0;}&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >=&#XA0;{&#XA0;(<span style="font-style:italic">x</span>,&#XA0;<span style="font-style:italic">x</span>,&#XA0;<span style="font-style:italic">x</span>)&#XA0;&#XA0;&#X2223;&#XA0;&#XA0;<span style="font-style:italic">x</span>&#XA0;&#X2208;&#XA0;&#X2124;&#XA0;}&#XA0;&#X2243;&#XA0;&#X2124;
</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table>
</div>
So, we know that we have a <span class='latexinline'>
&#X2124;</span> worth of cycles in our triangle, which
makes sense: We can go clockwise (positive numbers)
and counter-clockwise (negative numbers) around the triangle,
and we can go as many times as we wish, so we have <span class='latexinline'>
&#X2124;</span> as the
number of cycles.
that is, it's the linear combination of edges that map to zero through the
boundary map. Note that this also includes combinations such as <i>two</i> loops
around the triangle, such as <span class='latexinline'>
<span style="font-style:italic">o</span> + <span style="font-style:italic">m</span> + <span style="font-style:italic">c</span> + <span style="font-style:italic">o</span> + <span style="font-style:italic">m</span> + <span style="font-style:italic">c</span></span>.
<h4><a id=trianglees-in-a-space-homology-of-a- href='#trianglees-in-a-space-homology-of-a-'> § </a> (No) Holes in a space: Homology of a <i>filled</i> triangle</h4>
<img width=200 height=200 src="static/simplices/homology-triangle-faces.svg">
In this case, notice that the triangle is <i>filled</i> with a face <span class='latexinline'>
<span style="font-style:italic">f</span></span>.
Therefore, the "hole" that we had previously is now filled up, and does not
count anymore. So, we now need to amend our previous definition of <span class='latexinline'>
<span style="font-style:italic">H</span><sub>1</sub></span> to
kill the hole we had detected.
The idea is that the hole we had previously is now the
<i>boundary of the new face <span class='latexinline'>
<span style="font-style:italic">f</span></span></i>.
Since it is the boundary of a "filled in" region, it does not count anymore,
since we can "shrink the hole" across the face to make it a non-loop.
Hence, we need to quotient our <span class='latexinline'>
<span style="font-style:italic">H</span><sub>1</sub></span> with the boundary of the face.
Formally, what we do is we create another group <span class='latexinline'>
<span style="color:red"><span style="font-style:italic">F</span></span> &#X2261; &#X2124;</span>,
which counts copies of our face <span class='latexinline'>
<span style="font-style:italic">f</span></span>, and we define another boundary operator,
such that the boundary of the face <span class='latexinline'>
<span style="font-style:italic">f</span></span> is <span class='latexinline'>
<span style="font-style:italic">o</span> + <span style="font-style:italic">m</span> + <span style="font-style:italic">c</span></span>.
<div class='latexblock'><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&#X2202;<sub><span style="font-style:italic">FE</span></sub>&#XA0;:&#XA0;<span style="color:red"><span style="font-style:italic">F</span></span>&#XA0;&#X2192;&#XA0;<span style="color:red"><span style="font-style:italic">E</span></span>&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&#X2202;<sub><span style="font-style:italic">FE</span></sub>(1)&#XA0;&#X2261;&#XA0;(1,&#XA0;1,&#XA0;1)&#XA0;&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >(Extend using linearity)&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&#X2202;<sub><span style="font-style:italic">FE</span></sub>(<span style="font-style:italic">c</span>)&#XA0;&#X2261;&#XA0;<span style="font-style:italic">c</span>&#XA0;&#X2202;(1)&#XA0;=&#XA0;(<span style="font-style:italic">c</span>,&#XA0;<span style="font-style:italic">c</span>,&#XA0;<span style="font-style:italic">c</span>)
</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table>
</div>
Now, we should notice that the <i>image</i> of <span class='latexinline'>
&#X2202;<sub><span style="font-style:italic">FE</span></sub></span> is a loop
<span class='latexinline'>
(<span style="font-style:italic">o</span> + <span style="font-style:italic">m</span> + <span style="font-style:italic">c</span>)</span>, which lies ie the <i>kernel</i> of <span class='latexinline'>
&#X2202;<sub><span style="font-style:italic">EV</span></sub></span>. This is a
general feature of homology, so it bears repeating:
<ul>
<li>
 <span class='latexinline'>
<span style="font-style:italic">Image</span>(&#X2202;<sub><span style="font-style:italic">FE</span></sub>) &#X2282; <span style="font-style:italic">Kernel</span>(&#X2202;<sub><span style="font-style:italic">EV</span></sub>)</span>
</li>
<li>
 <span class='latexinline'>
&#X2202;<sub><span style="font-style:italic">FE</span></sub> &#X2218; &#X2202;<sub><span style="font-style:italic">EV</span></sub> = 0</span>
</li>
<li>
 The above equation is sometimes stylishly (somewhat misleadingly) written as
  <span class='latexinline'>
&#X2202;<sup>2</sup> = 0</span>. More faithfully, one can write <span class='latexinline'>
&#X2202;<sub><span style="font-style:italic">EV</span></sub> &#X2218; &#X2202;<sub><span style="font-style:italic">FE</span></sub> = 0</span>.
</li>

</ul>

Now, since the image of <span class='latexinline'>
&#X2202;<sub><span style="font-style:italic">FE</span></sub></span> lies entirely in the kernel of <span class='latexinline'>
&#X2202;<sub><span style="font-style:italic">EV</span></sub></span>,
we can construct <span class='latexinline'>
<span style="font-style:italic">H</span><sub>1</sub></span> as:
<ul>
<li>
 <span class='latexinline'>
<span style="font-style:italic">H</span><sub>1</sub> &#X2261; <span style="font-style:italic">Kernel</span>(&#X2202;<sub><span style="font-style:italic">EV</span></sub>) / <span style="font-style:italic">Image</span>(&#X2202;<sub><span style="font-style:italic">FE</span></sub>) &#X2282; <span style="font-style:italic">E</span></span>
</li>

</ul>

<h4><a id=a-complicated-space-homology-of-a-butterfly href='#a-complicated-space-homology-of-a-butterfly'> § </a> A complicated space: Homology of a butterfly</h4>
<h3><a id=an-invitation-to-homology-and-cohomology-part-2--cohomology href='#an-invitation-to-homology-and-cohomology-part-2--cohomology'> § </a> <a href=#an-invitation-to-homology-and-cohomology-part-2--cohomology>
An invitation to homology and cohomology, Part 2 --- Cohomology</a>
</h3>

<img width=200 height=200 src="static/simplices/cohomology-triangle-vertices.svg">
Once again, we have our humble triangle with vertices <span class='latexinline'>
<span style="font-style:italic">V</span> = {<span style="font-style:italic">r</span>, <span style="font-style:italic">g</span>, <span style="font-style:italic">b</span>}</span>,
edges <span class='latexinline'>
<span style="font-style:italic">E</span> = {<span style="font-style:italic">o</span>, <span style="font-style:italic">m</span>, <span style="font-style:italic">c</span> }</span>, faces <span class='latexinline'>
<span style="font-style:italic">F</span> = { <span style="font-style:italic">f</span> }</span> with boundary maps <span class='latexinline'>
&#X2202;<sub><span style="font-style:italic">EV</span></sub></span>,
<span class='latexinline'>
&#X2202;<sub><span style="font-style:italic">FE</span></sub></span>:
<ul>
<li>
 <span class='latexinline'>
&#X2202;<sub><span style="font-style:italic">FE</span></sub>(<span style="font-style:italic">f</span>)= <span style="font-style:italic">o</span> + <span style="font-style:italic">m</span> + <span style="font-style:italic">c</span></span>
</li>
<li>
 <span class='latexinline'>
&#X2202;<sub><span style="font-style:italic">EV</span></sub>(<span style="font-style:italic">o</span>) = <span style="font-style:italic">r</span> &#X2212; <span style="font-style:italic">g</span></span>
</li>
<li>
 <span class='latexinline'>
&#X2202;<sub><span style="font-style:italic">EV</span></sub>(<span style="font-style:italic">m</span>) = <span style="font-style:italic">b</span> &#X2212; <span style="font-style:italic">r</span></span>
</li>
<li>
 <span class='latexinline'>
&#X2202;<sub><span style="font-style:italic">EV</span></sub>(<span style="font-style:italic">c</span>)= <span style="font-style:italic">g</span> &#X2212; <span style="font-style:italic">b</span></span>
</li>

</ul>

We define a function <span class='latexinline'>
<span style="font-style:italic">h</span><sub><span style="font-style:italic">v</span></sub>: <span style="font-style:italic">V</span> &#X2192; &#X211D;</span> on the vertices as:
<ul>
<li>
  <span class='latexinline'>
<span style="font-style:italic">h</span><sub><span style="font-style:italic">v</span></sub>(<span style="font-style:italic">r</span>) = 3</span>, <span class='latexinline'>
<span style="font-style:italic">h</span><sub><span style="font-style:italic">v</span></sub>(<span style="font-style:italic">g</span>) = 4</span>, <span class='latexinline'>
<span style="font-style:italic">h</span><sub><span style="font-style:italic">v</span></sub>(<span style="font-style:italic">b</span>) = 10</span>.
</li>

</ul>

We now learn how to <i>extend</i> this function to the higher dimensional objects,
the edges and the faces of the triangle.
To extend this function to the edges, we define a new function:
<ul>
<li>
 <span class='latexinline'>
<span style="font-style:italic">h</span><sub><span style="font-style:italic">e</span></sub>: <span style="font-style:italic">E</span> &#X2192; <span style="font-style:italic">R</span></span>
</li>
<li>
 <span class='latexinline'>
<span style="font-style:italic">h</span><sub><span style="font-style:italic">e</span></sub>(<span style="font-style:italic">e</span>) &#X2261; &#X2211;<sub><span style="font-style:italic">i</span></sub> &#X3B1;<sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">h</span><sub><span style="font-style:italic">v</span></sub>(<span style="font-style:italic">v</span><sub><span style="font-style:italic">i</span></sub>)</span> where <span class='latexinline'>
&#X2202;<sub><span style="font-style:italic">EV</span></sub> <span style="font-style:italic">e</span> = &#X2211;<sub><span style="font-style:italic">i</span></sub> &#X3B1;<sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">v</span><sub><span style="font-style:italic">i</span></sub></span>
</li>

</ul>

Expanded out on the example, we evaluate <span class='latexinline'>
<span style="font-style:italic">h</span><sub><span style="font-style:italic">v</span></sub></span> as:
<ul>
<li>
 <span class='latexinline'>
<span style="font-style:italic">h</span><sub><span style="font-style:italic">e</span></sub>(<span style="font-style:italic">o</span>) &#X2261; <span style="font-style:italic">d</span> <span style="font-style:italic">h</span><sub><span style="font-style:italic">v</span></sub>(<span style="font-style:italic">o</span>) = <span style="font-style:italic">h</span><sub><span style="font-style:italic">v</span></sub>(<span style="font-style:italic">r</span>) &#X2212; <span style="font-style:italic">h</span><sub><span style="font-style:italic">v</span></sub>(<span style="font-style:italic">g</span>) = 3 &#X2212; 4 = &#X2212;1</span>
</li>
<li>
 <span class='latexinline'>
<span style="font-style:italic">h</span><sub><span style="font-style:italic">e</span></sub>(<span style="font-style:italic">m</span>) &#X2261; <span style="font-style:italic">d</span> <span style="font-style:italic">h</span><sub><span style="font-style:italic">v</span></sub>(<span style="font-style:italic">m</span>) = <span style="font-style:italic">h</span><sub><span style="font-style:italic">v</span></sub>(<span style="font-style:italic">b</span>) &#X2212; <span style="font-style:italic">h</span><sub><span style="font-style:italic">v</span></sub>(<span style="font-style:italic">r</span>) = 10 &#X2212; 3 = +7</span>
</li>
<li>
 <span class='latexinline'>
<span style="font-style:italic">h</span><sub><span style="font-style:italic">e</span></sub>(<span style="font-style:italic">c</span>) &#X2261; <span style="font-style:italic">d</span> <span style="font-style:italic">h</span><sub><span style="font-style:italic">v</span></sub>(<span style="font-style:italic">c</span>) = <span style="font-style:italic">h</span><sub><span style="font-style:italic">v</span></sub>(<span style="font-style:italic">g</span>) &#X2212; <span style="font-style:italic">h</span><sub><span style="font-style:italic">v</span></sub>(<span style="font-style:italic">b</span>) = 4 &#X2212; 10 = &#X2212;6</span>
</li>

</ul>

More conceptually, we have created an <i>operator</i> called <span class='latexinline'>
<span style="font-style:italic">d</span></span> (the <b>coboundary operator</b>)
which takes functions defined on vertices to functions defined on edges. This
uses the boundary map on the edges to "lift" a function on the vertices to a
function on the edges.  It does so by assigning the "potential difference" of
the vertices to the edges.
<ul>
<li>
 <span class='latexinline'>
<span style="font-style:italic">d</span>: (<span style="font-style:italic">V</span> &#X2192; &#X211D;) &#X2192; (<span style="font-style:italic">E</span> &#X2192; &#X211D;)</span>
</li>
<li>
 <span class='latexinline'>
<span style="font-style:italic">d</span>(<span style="font-style:italic">h</span><sub><span style="font-style:italic">v</span></sub>) &#X2261; <span style="font-style:italic">h</span><sub><span style="font-style:italic">e</span></sub></span>, <span class='latexinline'>
<span style="font-style:italic">h</span><sub><span style="font-style:italic">e</span></sub>(<span style="font-style:italic">e</span>) &#X2261; &#X2211;<sub><span style="font-style:italic">i</span></sub> &#X3B1;<sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">f</span>(<span style="font-style:italic">v</span><sub><span style="font-style:italic">i</span></sub>)</span> where <span class='latexinline'>
&#X2202;<sub><span style="font-style:italic">EV</span></sub> <span style="font-style:italic">e</span> = &#X2211;<sub><span style="font-style:italic">i</span></sub> &#X3B1;<sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">v</span><sub><span style="font-style:italic">i</span></sub></span>
</li>

</ul>

We can repeat the construction we performed above, to construct another operator
<span class='latexinline'>
<span style="font-style:italic">d</span> : (<span style="font-style:italic">E</span> &#X2192; &#X211D;) &#X2192; (<span style="font-style:italic">F</span> &#X2192; &#X211D;)</span>, defined
in <i>exactly the same way</i> as we did before. For example, we can evaluate:
<ul>
<li>
 <span class='latexinline'>
<span style="font-style:italic">h</span><sub><span style="font-style:italic">f</span></sub> &#X2261; <span style="font-style:italic">d</span>(<span style="font-style:italic">h</span><sub><span style="font-style:italic">e</span></sub>)</span>
</li>
<li>
 <span class='latexinline'>
<span style="font-style:italic">h</span><sub><span style="font-style:italic">f</span></sub>(<span style="font-style:italic">f</span>) &#X2261; <span style="font-style:italic">d</span> <span style="font-style:italic">h</span><sub><span style="font-style:italic">e</span></sub>(<span style="font-style:italic">f</span>) = <span style="font-style:italic">h</span><sub><span style="font-style:italic">e</span></sub>(<span style="font-style:italic">o</span>) + <span style="font-style:italic">h</span><sub><span style="font-style:italic">e</span></sub>(<span style="font-style:italic">m</span>) + <span style="font-style:italic">h</span><sub><span style="font-style:italic">e</span></sub>(<span style="font-style:italic">c</span>) = &#X2212;1 + 7 &#X2212;6 = 0</span>
</li>

</ul>

What we have is a chain:
<ul>
<li>
 <span class='latexinline'>
<span style="font-style:italic">h</span><sub><span style="font-style:italic">v</span></sub> &#X2192;<sup><span style="font-style:italic">d</span></sup> <span style="font-style:italic">h</span><sub><span style="font-style:italic">e</span></sub> &#X2192;<sup><span style="font-style:italic">d</span></sup> <span style="font-style:italic">h</span><sub><span style="font-style:italic">f</span></sub></span>
</li>

</ul>

Where we notice that <span class='latexinline'>
<span style="font-style:italic">d</span><sup>2</sup> = <span style="font-style:italic">d</span> &#X2218; <span style="font-style:italic">d</span> = 0</span>, since the function <span class='latexinline'>
<span style="font-style:italic">h</span><sub><span style="font-style:italic">f</span></sub></span> that we have gotten
evaluates to zero on the face <span class='latexinline'>
<span style="font-style:italic">f</span></span>. We can prove this will happen <i>in general</i>,
for any choice of <span class='latexinline'>
<span style="font-style:italic">h</span><sub><span style="font-style:italic">v</span></sub></span>.
(it's a good exercise in definition chasing).
Introducing some terminology, A differential form <span class='latexinline'>
<span style="font-style:italic">f</span></span> is said to be a <b>closed differential form</b>
iff <span class='latexinline'>
<span style="font-style:italic">df</span> = 0</span>.
In our case, <span class='latexinline'>
<span style="font-style:italic">h</span><sub><span style="font-style:italic">e</span></sub></span> <b>is closed</b>, since <span class='latexinline'>
<span style="font-style:italic">d</span> <span style="font-style:italic">h</span><sub><span style="font-style:italic">e</span></sub> = <span style="font-style:italic">h</span><sub><span style="font-style:italic">f</span></sub> = 0</span>. On the other hand
<span class='latexinline'>
<span style="font-style:italic">h</span><sub><span style="font-style:italic">v</span></sub></span> is <b>not closed</b>, since <span class='latexinline'>
<span style="font-style:italic">d</span> <span style="font-style:italic">h</span><sub><span style="font-style:italic">v</span></sub> = <span style="font-style:italic">h</span><sub><span style="font-style:italic">e</span></sub> &#X2260; 0</span>.
The intuition for why this is called "closed" is that its coboundary vanishes.
<h3><a id=exploring-the-structure-of-functions-defined-on-the-edges href='#exploring-the-structure-of-functions-defined-on-the-edges'> § </a> Exploring the structure of functions defined on the edges</h3>
Here, we try to understand what functions defined on the edges can look like,
and their relationship with the <span class='latexinline'>
<span style="font-style:italic">d</span></span> operator. We discover that there are
some functions <span class='latexinline'>
<span style="font-style:italic">g</span><sub><span style="font-style:italic">e</span></sub>: <span style="font-style:italic">E</span> &#X2192; &#X211D;</span> which can be realised as the differential
of another function <span class='latexinline'>
<span style="font-style:italic">g</span><sub><span style="font-style:italic">v</span></sub>: <span style="font-style:italic">V</span> &#X2192; &#X211D;</span>. The differential
forms such as <span class='latexinline'>
<span style="font-style:italic">g</span><sub><span style="font-style:italic">e</span></sub></span> which can be generated a <span class='latexinline'>
<span style="font-style:italic">g</span><sub><span style="font-style:italic">v</span></sub></span> through the <span class='latexinline'>
<span style="font-style:italic">d</span></span> operator
are called as <b>exact differential forms</b>. That is, <span class='latexinline'>
<span style="font-style:italic">g</span><sub><span style="font-style:italic">e</span></sub> = <span style="font-style:italic">d</span> <span style="font-style:italic">g</span><sub><span style="font-style:italic">v</span></sub></span> <i>exactly</i>,
such that there is no "remainder term" on applying the <span class='latexinline'>
<span style="font-style:italic">d</span></span> operator.
<img width=200 height=200 src="static/simplices/cohomology-triangle-edges.svg">
We take an example of a differential form that is <i>not exact</i>, which has been
defined on the edges of the triangle above. Let's call it <span class='latexinline'>
<span style="font-style:italic">h</span><sub><span style="font-style:italic">e</span></sub></span>.
It is defined on the edges as:
<ul>
<li>
 <span class='latexinline'>
<span style="font-style:italic">h</span><sub><span style="font-style:italic">e</span></sub>(<span style="font-style:italic">c</span>) = 3</span>
</li>
<li>
 <span class='latexinline'>
<span style="font-style:italic">h</span><sub><span style="font-style:italic">e</span></sub>(<span style="font-style:italic">m</span>) = 2</span>
</li>
<li>
 <span class='latexinline'>
<span style="font-style:italic">h</span><sub><span style="font-style:italic">e</span></sub>(<span style="font-style:italic">o</span>) = 1</span>
</li>

</ul>

We can calcuate <span class='latexinline'>
<span style="font-style:italic">h</span><sub><span style="font-style:italic">f</span></sub> = <span style="font-style:italic">d</span> <span style="font-style:italic">h</span><sub><span style="font-style:italic">e</span></sub></span> the same way we had before:
<ul>
<li>
 <span class='latexinline'>
<span style="font-style:italic">h</span><sub><span style="font-style:italic">f</span></sub>(<span style="font-style:italic">f</span>) &#X2261; <span style="font-style:italic">d</span> <span style="font-style:italic">h</span><sub><span style="font-style:italic">e</span></sub>(<span style="font-style:italic">f</span>) = <span style="font-style:italic">h</span><sub><span style="font-style:italic">e</span></sub>(<span style="font-style:italic">o</span>) + <span style="font-style:italic">h</span><sub><span style="font-style:italic">e</span></sub>(<span style="font-style:italic">m</span>) + <span style="font-style:italic">h</span><sub><span style="font-style:italic">e</span></sub>(<span style="font-style:italic">c</span>) = 3 + 1 + 2 = 6</span>.
</li>

</ul>

Since <span class='latexinline'>
<span style="font-style:italic">d</span> <span style="font-style:italic">h</span><sub><span style="font-style:italic">e</span></sub> &#X2260; 0</span>, this form is not exact.
Let's also try to generate <span class='latexinline'>
<span style="font-style:italic">h</span><sub><span style="font-style:italic">e</span></sub></span> from a potential. We arbitrarily fix the
potential of <span class='latexinline'>
<span style="font-style:italic">b</span></span> to <span class='latexinline'>
0</span>. That is, we fix <span class='latexinline'>
<span style="font-style:italic">h</span><sub><span style="font-style:italic">v</span></sub>(<span style="font-style:italic">b</span>) = 0</span>, and we then try to
see what values we are forced to values of <span class='latexinline'>
<span style="font-style:italic">h</span><sub><span style="font-style:italic">v</span></sub></span> across the rest of the triangle.
<ul>
<li>
 <span class='latexinline'>
<span style="font-style:italic">h</span><sub><span style="font-style:italic">v</span></sub> <span style="font-style:italic">b</span> = 0</span>
</li>
<li>
 <span class='latexinline'>
<span style="font-style:italic">h</span><sub><span style="font-style:italic">e</span></sub>(<span style="font-style:italic">c</span>) = <span style="font-style:italic">h</span><sub><span style="font-style:italic">v</span></sub>(<span style="font-style:italic">g</span>) &#X2212; <span style="font-style:italic">h</span><sub><span style="font-style:italic">v</span></sub>(<span style="font-style:italic">b</span>)</span>. <span class='latexinline'>
<span style="font-style:italic">h</span><sub><span style="font-style:italic">v</span></sub>(<span style="font-style:italic">g</span>) = <span style="font-style:italic">h</span><sub><span style="font-style:italic">v</span></sub>(<span style="font-style:italic">b</span>) + <span style="font-style:italic">h</span><sub><span style="font-style:italic">e</span></sub>(<span style="font-style:italic">c</span>) = 0 + 3 = 3</span>.
</li>
<li>
 <span class='latexinline'>
<span style="font-style:italic">h</span><sub><span style="font-style:italic">e</span></sub>(<span style="font-style:italic">o</span>) = <span style="font-style:italic">h</span><sub><span style="font-style:italic">v</span></sub>(<span style="font-style:italic">r</span>) &#X2212; <span style="font-style:italic">h</span><sub><span style="font-style:italic">v</span></sub>(<span style="font-style:italic">g</span>)</span>. <span class='latexinline'>
<span style="font-style:italic">h</span><sub><span style="font-style:italic">v</span></sub>(<span style="font-style:italic">r</span>) = <span style="font-style:italic">h</span><sub><span style="font-style:italic">v</span></sub>(<span style="font-style:italic">g</span>) + <span style="font-style:italic">h</span><sub><span style="font-style:italic">e</span></sub>(<span style="font-style:italic">o</span>) = 3 + 1 = 4</span>.
</li>
<li>
 <span class='latexinline'>
<span style="font-style:italic">h</span><sub><span style="font-style:italic">e</span></sub>(<span style="font-style:italic">m</span>) = <span style="font-style:italic">h</span><sub><span style="font-style:italic">v</span></sub>(<span style="font-style:italic">b</span>) &#X2212; <span style="font-style:italic">h</span><sub><span style="font-style:italic">v</span></sub>(<span style="font-style:italic">r</span>)</span> <span class='latexinline'>
2 = 0 &#X2212; 4</span>. This is a contradiction!
</li>
<li>
 Ideally, we need <span class='latexinline'>
<span style="font-style:italic">h</span><sub><span style="font-style:italic">v</span></sub>(<span style="font-style:italic">b</span>) = 6</span> for the values to work out.
</li>

</ul>

Hence, there can exist no such <span class='latexinline'>
<span style="font-style:italic">h</span><sub><span style="font-style:italic">v</span></sub></span> such that <span class='latexinline'>
<span style="font-style:italic">h</span><sub><span style="font-style:italic">e</span></sub> &#X2261; <span style="font-style:italic">d</span> <span style="font-style:italic">h</span><sub><span style="font-style:italic">v</span></sub></span>.
The interesting thing is, when we started out by assigning <span class='latexinline'>
<span style="font-style:italic">h</span><sub><span style="font-style:italic">v</span></sub>(<span style="font-style:italic">b</span>) = 0</span>,
we could make <i>local choices</i> of potentials that seemed like they would fit
together, but they failed to fit <i>globally</i> throughout the triangle. This
failure of <i>locally consistent choices</i> to be <i>globally consistent</i> is
the essence of cohomology.
<h3><a id=cohomology-of-half-filled-butterfly href='#cohomology-of-half-filled-butterfly'> § </a> Cohomology of half-filled butterfly</h3>
<img width=400 src="static/simplices/cohomology-half-filled-butterfly.svg">
Here, we have vertices <span class='latexinline'>
<span style="font-style:italic">V</span> &#X2261; <br>
 <span style="font-style:italic">r</span>, <span style="font-style:italic">g</span>, <span style="font-style:italic">b</span>, <span style="font-style:italic">b</span>, <span style="font-style:italic">p</span> <br>
</span>, edges
<span class='latexinline'>
<span style="font-style:italic">E</span> &#X2261; <br>
<span style="font-style:italic">rb</span>, <span style="font-style:italic">gr</span>, <span style="font-style:italic">bg</span>, <span style="font-style:italic">m</span>, <span style="font-style:italic">o</span>, <span style="font-style:italic">c</span> <br>
</span> and faces <span class='latexinline'>
<span style="font-style:italic">F</span> &#X2261; <br>
 <span style="font-style:italic">f</span> <br>
</span>.
Here, we see a differential form <span class='latexinline'>
<span style="font-style:italic">h</span><sub><span style="font-style:italic">e</span></sub></span> that is defined on the edges,
and also obeys the equation <span class='latexinline'>
<span style="font-style:italic">dh</span><sub><span style="font-style:italic">e</span></sub> = 0</span> (Hence is closed). However, it
<i>does not have an associated potential energy</i> to derive it from. That is,
there cannot exist a certain <span class='latexinline'>
<span style="font-style:italic">h</span><sub><span style="font-style:italic">v</span></sub></span> such that <span class='latexinline'>
<span style="font-style:italic">d</span> <span style="font-style:italic">h</span><sub><span style="font-style:italic">v</span></sub> = <span style="font-style:italic">h</span><sub><span style="font-style:italic">e</span></sub></span>.
So, while every exact form is closed, <i>not every</i> closed form is exact.
Hence, this <span class='latexinline'>
<span style="font-style:italic">g</span></span> that we have found is a non-trivial element of <span class='latexinline'>
<span style="font-style:italic">Kernel</span>(<span style="font-style:italic">d</span><sub><span style="font-style:italic">FE</span></sub>) / <span style="font-style:italic">Image</span>(<span style="font-style:italic">d</span><sub><span style="font-style:italic">EV</span></sub>)</span>,
since <span class='latexinline'>
<span style="font-style:italic">dh</span><sub><span style="font-style:italic">e</span></sub> = 0</span>, hence <span class='latexinline'>
<span style="font-style:italic">h</span><sub><span style="font-style:italic">e</span></sub> &#X2208; <span style="font-style:italic">Kernel</span>(<span style="font-style:italic">d</span><sub><span style="font-style:italic">FE</span></sub>)</span>, while there does not exist
a <span class='latexinline'>
<span style="font-style:italic">h</span><sub><span style="font-style:italic">v</span></sub></span> such that <span class='latexinline'>
<span style="font-style:italic">d</span> <span style="font-style:italic">h</span><sub><span style="font-style:italic">v</span></sub> = <span style="font-style:italic">h</span><sub><span style="font-style:italic">e</span></sub></span>, hence it is <i>not quotiented</i> by the image of
<span class='latexinline'>
<span style="font-style:italic">d</span><sub><span style="font-style:italic">EV</span></sub></span>.
So the failure of the space to be fully filled in (ie, the space has a hole),
is measured by the <i>existence of a function <span class='latexinline'>
<span style="font-style:italic">h</span><sub><span style="font-style:italic">e</span></sub></span> that is closed but not exact!</i>
This reveals a deep connection between homology and cohomology, which is
made explicit by the <a href=TODO>
Universal Coefficient Theorem</a>

<h3><a id=stuff-i-learnt-in-2019 href='#stuff-i-learnt-in-2019'> § </a> <a href=#stuff-i-learnt-in-2019>
Stuff I learnt in 2019</a>
</h3>
I write these retrospective blog posts every year since 2017. I tend to post a
collection of papers, books, and ideas I've stumbled across that year.
Unfortunately, this year, the paper list will be sparser, since I lost some
data along the way to the year, and hence I don't have links to everything I
read. So this is going to be a sparser list, consisting of things that I found
<i>memorable</i>.
I also re-organised my website, letting the link die, since keeping it up was
taking far too many cycles (In particular, CertBot was far too annoying to
maintain, and the feedback of hugo was also very annoying). I now have a
<i>single</i> file, the
<a href=https://github.com/bollu/bollu.github.io>
<code>README.md</code>of the <code>bollu/bollu.github.io</code></a>

repo,
to which I add notes on things I find interesting. I've bound the <code>i</code> alias
(for idea) on all my shells everywhere, to open the <code>README.md</code> file, wait
for me to write to it, run a <code>git commit</code> so I can type out a commit, and
then push. This has been <i>massive</i> for what I manage to write down: I feel
like I've managed to write down a lot of one-liners / small facts that I've
picked up which I would not otherwise. I'm attempting to similarly pare down
other friction-inducing parts of my workflow. Suggestions here would be very
welcome!
If there's a theme of the year (insofar as my scattered reading has a
theme...), it's "lattices and geometry". Geometry in terms of differential
geometry, topology, and topoi. Lattices in the sense of a bunch of abstract
interpretation and semantics.
<h4><a id=course-work-optimisation-theory-quantum-computation-statistics href='#course-work-optimisation-theory-quantum-computation-statistics'> § </a> Course work: optimisation theory, quantum computation, statistics</h4>
My course work was less interesting to me this time, due to the fact that I had
chosen to study some wild stuff earlier on, and now have to take reasonable stuff
to graduate. However, there were courses that filled in a lot of gaps in my
self-taught knowledge for me, and the ones I listed were the top ones in that
regard.
I wound up reading
<a href=https://web.stanford.edu/~boyd/cvxbook/>
Boyd on optimisation theory</a>
,
<a href=http://mmrc.amss.cas.cn/tlb/201702/W020170224608149940643.pdf>
Nielsen and Chuang</a>
 for quantum computation,
where I also
<a href=https://github.com/bollu/quantum-course-exercises>
solved a bunch of exercises in Q#</a>

which was very fun and rewarding. I'm beginning to feel that learning quantum
computation is the right route to grokking things like entanglement and
superposition, unlike the physics which is first of all much harder due to
infinite dimensionality, and less accessible since we can't <i>program</i> it.
<h4><a id=formal-research-work-compilers-formal-verification-programming-languages href='#formal-research-work-compilers-formal-verification-programming-languages'> § </a> Formal research work: Compilers, Formal verification, Programming languages</h4>
My research work is on the above topics, so I try to stay abreast of what's
going on in the field. What I've read over the past year on these topics is:
<ul>
<li>
 <a href=https://popl19.sigplan.org/details/POPL-2019-Research-Papers/71/A-2-I-Abstract-2-Interpretation>
<code>A^2I</code>: meta-abstract interpretation</a>
.
  This paper extends the theory of abstract interpretation to perform abstract
  interpretation on program analyses themselves. I'm not sure how <i>useful</i> this
  is going to be, as I still hold on to the belief that AI as a framework is
  too general to allow one to prove complex results. But I am still interested
  in trying to adapt this to some problems I have at hand. Perhaps it's going
  to work.
</li>

</ul>

<ul>
<li>
 <a href=https://dl.acm.org/citation.cfm?id=3341691>
Cubicial Agda</a>
. This paper introduces
  cubical type theory and its implementation in Agda. It appears to solve many
  problems that I had struggled with during my formalization of loop
  optimisations: In particular, dealing with Coinductive types in Coq, and that
  of defining quotient types / setoids. Supposedly, cubical Agda makes dealing
  with Coinduction far easier. It allows allows the creation of "real" quotient
  types that respect equality, without having to deal with <code>setoid</code> style
  objects that make for large Gallina terms. I don't fully understand how the
  <i>theory</i> works: In particular, as far as I can tell, the synthetic interval
  type <code>I</code> allows one to only access the start and end points (<code>0</code> and <code>1</code>),
  but not anything in between, so I don't really see how it allows for
  interpolation.  I also don't understand how this allows us to make Univalence
  computable.  I feel I need to practice with this new technology before I'm
  well versed, but it's definitely a paper I'm going to read many, many times
  till I grok it.
</li>

</ul>

<ul>
<li>
 <a href=https://arxiv.org/abs/1911.05844>
Naive Cubical type theory</a>
. This paper
  promises a way to perform informal reasoning with cubical type theory, the
  way we are able to do so with, say, a polymorphic type theory for lambda
  calculus. The section names such as "how do we think of paths",
  "what can we do with paths", inspire confidence
</li>

</ul>

<ul>
<li>
 <a href=https://icfp19.sigplan.org/details/icfp-2019-papers/26/Call-By-Need-is-Clairvoyant-Call-By-Value>
Call by need is Clairvoyant call by value</a>
. This key insight is to notice that call by need
  is "just" call by value, when we evaluate only those values that are
  eventually forced, and throw away the rest. Thus, if we had an oracle that
  tells us which values are eventually forced, we can convert call by need into
  call by value, relative to this oracle. This cleans up many proofs in the
  literature, and might make it far more intuitive to teach call by need to
  people as well. Slick paper, I personally really enjoyed reading this.
</li>

</ul>

<ul>
<li>
 <a href=https://arxiv.org/abs/1803.10228>
Shift/Reset the Penultimate Backpropagator</a>

  This paper describes how to implement backprop using delimited continuations.
  Also, supposedly, using staging / building a compiler out of this paradigm
  allows one to write high performance compilers for backprop without having
  to suffer, which is always nice.
</li>

</ul>

<ul>
<li>
 <a href=https://www.cs.princeton.edu/~zkincaid/pub/popl19a.pdf>
Closed forms for numerical loops</a>

  This paper introduces a new algebra of polynomials with exponentials. It then
  studies the eigenvalues of the matrix that describes the loop, and tries to
  find closed forms in terms of polynomials and exponentials. They choose
  to only work with rationals, but not extensions of rational numbers
  (in terms of field extensions of the rationals). Supposedly, this is easier
  to implement and reason about. Once again, this is a paper I'd like to
  reimplement to understand fully, but the paper is well-done!
</li>

</ul>

<ul>
<li>
 <a href=https://engineering.purdue.edu/Papers/Sundararajah.pdf>
Composable, sound transformations of Nested recursion and loops</a>
.
  This paper attempts to bring ideas from polyhedral compilation
  into working with nested recursion. They create a representation using
  multitape finite automata, using which they provide a representation for
  nested recursion. I was somewhat disappointed that it does not handle
  mutual recursion, since my current understanding is that one can always
  convert nested recursion into a "reasonable" straight line program by
  simply inlining calls and then re-using polyhedral techniques.
</li>

</ul>

<ul>
<li>
 <a href=https://github.com/bollu/blaze/blob/master/notebooks/tutorial.ipynb>
Reimplementation of <code>STOKE</code> at <code>bollu/blaze</code>.</a>

  I reimplemented the <a href=http://stoke.stanford.edu/>
STOKE: stochastic superoptimisation</a>

  paper, and much to my delight, it was super-effective at regenerating common
  compiler transformations. I want to use this to generate loop optimisations
  as well, by transforming a polyhedral model of the original program.
</li>

</ul>

<h4><a id=webassembly-compilerng-on-asterius-haskell-- href='#webassembly-compilerng-on-asterius-haskell--'> § </a> Internship at <a href=http://tweag.io/>
Tweag.io</a>
 over the summer: Hacking on Asterius (Haskell -> WebAssembly compiler)</h4>
<ul>
<li>
 <a href=https://www.tweag.io/posts/2019-09-12-webassembly-internship.html>
Blog post on the progress made by me hacking on Austerius over at Tweag</a>

</li>

</ul>

I really enjoyed my time at Tweag! It was fun, and
<a href=https://github.com/TerrorJack>
Shao Cheng</a>

was a great mentor. I must admit that I was somewhat distracted, by all the new
and shiny things I was learning thanks to all the cool people there <code>:)</code> In
particular, I wound up bugging
<a href=http://assert-false.net/arnaud/>
Arnaud Spiwack</a>
,
<a href=http://simeon-carstens.com/>
Simeon Carstens</a>
,
and <a href=https://github.com/mmesch>
Matthias Meschede</a>

quite a bit, about type theory, MCMC sampling, and signal processing of storm
clouds.
I wound up reading a decent chunk of GHC source code, and while I can't link
to specifics here, I understood a lot of the RTS much better than I did before.
It was an enlightening experience, to say the least, and being paid to hack on
a GHC backend was a really fun way to spend the summer.
It also led me to fun discoveries, such as
<a href=https://github.com/ghc/ghc/blob/535a26c90f458801aeb1e941a3f541200d171e8f/compiler/cmm/Debug.hs#L458>
how does one debug debug info?</a>

I also really loved Paris as a city. My AirBnb host was a charming artist who
suggest spots for me around the city, which I really appreciated. Getting
around was disorienting for the first week or so, due to the fact that I could
not (and still do not) really understand how to decide in which direction to
walk inside the subways to find a particular line 
<i>going in a particular direction</i>.
The city has some great spots for quiet work, though! In particular, the
<a href=https://www.anticafe.eu/lieux/louvre-paris-75001/>
Louvre Anticafe</a>

was a really nice place to hang out and grab coffee. The model is great: you
pay for hours spent at the Anticafe, with coffee and snacks free. They also
had a discount for students which I gratefully used.
I bumped into interesting artists, programmers, and students who were open for
conversation there. I highly recommend hanging out there.
<h4><a id=probabilistic-programming-giving-a-talk-at-functionalconf href='#probabilistic-programming-giving-a-talk-at-functionalconf'> § </a> Probabilistic programming & giving a talk at FunctionalConf</h4>
This was the first talk I'd ever given, and it was on probabilistic programming
in haskell. In particular, I explained the
<a href=https://github.com/adscib/monad-bayes>
<code>monad-bayes</code></a>
 approach of
doing this, and why this was profitable.
<a href=https://github.com/bollu/functionalconf-2019-slides-probabilistic-programming/blob/master/slides.pdf>
The slides are available here</a>
.
It was a fun experience giving a talk, and I'd like to do more of it, since I
got a lot out of attempting to explain the ideas to people. I wish I had more
time, and had a clearer idea of who the audience was. I got quite a bit of
help from <a href=https://www.snoyman.com/>
Michael Snoyman</a>
 to whip the talk into
shape, which I greatly appreciated.
The major ideas of probabilistic programming as I described it are
from Adam Scibior's thesis:
<ul>
<li>
 <a href=https://www.cs.ubc.ca/~ascibior/assets/pdf/thesis.pdf>
Adam Scibior: Formally justified and modular Bayesian inference for probabilistic programs</a>

</li>

</ul>

Along the way, I and others at tweag read the other major papers in the space,
including:
<ul>
<li>
 <a href=https://arxiv.org/pdf/1206.3255>
Church, a language for generative models</a>
,
  which is nice since it describes it's semantics in terms of sampling. This is
  unlike Adam's thesis, where they define the denotational semantics in terms
  of measure theory, which is then approximated by sampling.
</li>
<li>
 <a href=https://pdfs.semanticscholar.org/16c5/06c5bb253f7528ddcc80c72673fabf584f32.pdf>
Riemann Manifold Langevin and Hamiltonian Monte Carlo</a>

  which describes how to perform Hamiltonian Monte Carlo on the 
  <i>information geometry</i> manifold.  So, for example, if we are trying to sample 
  from gaussians, we sample from a 2D Riemannian manifold with parameters mean 
  and varince, and metric as the <a href=https://en.wikipedia.org/wiki/Fisher_information_metric>
Fisher information metric</a>
.
  This is philosophically the "correct" manifold to sample from, since it
  represents the intrinsic geometry of the space we want to sample from.
</li>
<li>
 <a href=https://arxiv.org/pdf/1808.08271.pdf>
An elementary introduction to Information geometry by Frank Nielsen</a>

  something I stumbled onto as I continued reading about sampling from
  distributions. The above description about the "correct" manifold for
  gaussians comes from this branch of math, but generalises it quite a bit
  further. I've tried to reread it several times as I gradually gained maturity
  in differential geometry. I can't say I understand it just yet, but I hope to
  do so in a couple of months. I need more time for sure to meditate on the
  objects.
</li>
<li>
 <a href=https://github.com/bollu/shakuni>
Reimplementation of <code>monad-bayes</code></a>
.
  This repo holds the original implementation on which the talk is based on.
  I read through the <code>monad-bayes</code> source code, and then re-implemented the
  bits I found interesting. It was a nice exercise, and you can see
  the git history tell a tale of my numerous mis-understandings of MCMC methods,
  till I finally got what the hell was going on.
</li>

</ul>

<h4><a id=presburger-arithmetic href='#presburger-arithmetic'> § </a> Presburger Arithmetic</h4>
Since we use a bunch of <a href=https://en.wikipedia.org/wiki/Presburger_arithmetic>
presburger arithmetic</a>

for <a href=http://polyhedral.info/>
polyhedral compilation</a>

which is a large research interest of mine, I've been trying to build a
"complete" understanding of this space. So this time, I wanted to learn
how to build good solvers:
<ul>
<li>
 <a href=https://github.com/bollu/gutenberger>
<code>bollu/gutenberger</code></a>
 is a decision
  procedure for Presburger arithmetic that exploits their encoding as finite
  automata. One thing that I was experimenting with was that we only use
  numbers of finite bit-width, so we can explore the entire state space
  of the automata and then perform NFA reduction using
  <a href=https://en.wikipedia.org/wiki/DFA_minimization>
DFA minimisation</a>
. The
  reference I used for this was the excellent textbook
  <a href=https://www7.in.tum.de/~esparza/autoskript.pdf>
Automata theory: An algorithmic approach, Chapter 10</a>

</li>
<li>
 <a href=http://www.lsv.fr/~haase/documents/ch16.pdf>
The taming of the semi-linear set</a>

  This uses a different encoding of presburger sets, which allows them to bound
  a different quantity (the norm) rather than the bitwidth descriptions. This allows
  them to compute <i>exponentially</i> better bounds for some operations than
  were known before, which is quite cool. This is a paper I keep trying to
  read and failing due to density. I should really find a week away from civilization
  to just plonk down and meditate upon this.
</li>

</ul>

<h4><a id=open-questions-for-which-i-want-answers href='#open-questions-for-which-i-want-answers'> § </a> Open questions for which I want answers</h4>
I want better references to being able to <i>regenerate</i> the inequalities
description from a given automata which accepts the presburger set automata.
This will allow one to smoothly switch between the <i>geometric</i> description
and the <i>algebraic</i> description. There are some operations that only work
well on the geometry (such as optimisation), and others that only work well on
the algebraic description (such as state-space minimisation). I have not found
any good results for this, only scattered fragments of partial results.
If nothing else, I would like some kind of intuition for <i>why this is hard</i>.
Having tried my stab at it, the general impression that I have is that the
space of automata is much larger than the things that can be encoded as
presburger sets. Indeed, it was shown that automata accept numbers which
are ultimately periodic.
<ul>
<li>
  first order logic + "arithmetic with +" + (<i>another operation I cannot recall</i>).
   I'm going to fill this in once I re-find the reference.
</li>

</ul>

But yes, it's known that automata accept a language that's broader than just
first order logic + "arithmetic with +", which means it's hard to dis-entangle
the presburger gits from the non-presburger bits of the automata.
<h4><a id=prolog href='#prolog'> § </a> Prolog</h4>
I wanted to get a better understading of how prolog works under the hood, so I began
re-implementing the <a href=http://wambook.sourceforge.net/>
WAM: warren abstract machine</a>
.
It's really weird, this is the <i>only stable reference</i> I can find to implementing
high-performance prolog interpreters. I don't really understand how to chase the
paper-trail in this space, I'd greatly appreciate references. My implementation
is at <a href=https://github.com/bollu/warren-cpp/>
<code>bollu/warren-cpp</code></a>
. Unfortunately,
I had to give up due to a really hard-to-debug bug.
It's crazy to debug this abstract machine, since the internal representation gets
<i>super convoluted</i> and hard to track, due to the kind of optimised encoding it
uses on the heap.
If anyone has a better/cleaner design for implementing good prologs, I'd love
to know.
Another fun paper I found in this space thanks to Edward Kmett was
<a href=http://www.drdobbs.com/architecture-and-design/the-rete-matching-algorithm/184405218>
the Rete matching algorithm</a>
,
which allows one to declare many many pattern matches, which are then "fused"
together into an optimal matcher that tries to reuse work across failed
matchers.
<h4><a id=general-relativity href='#general-relativity'> § </a> General Relativity</h4>
This was on my "list of things I want to understand before I die", so I wound
up taking up an Independent Study in university, which basically means that
I study something on my own, and visit a professor once every couple weeks,
and am graded at the end of the term. For GR, I wound up referencing a wide
variety of sources, as well as a bunch of pure math diffgeo books. I've read
everything referenced to various levels. I feel I did take away the core
ideas of differential and Riemannian geometry. I'm much less sure I've grokked
general relativity, but I can at least read the equations and I know all the
terms, so that's something.
<ul>
<li>
 <a href=https://theoreticalminimum.com/courses/general-relativity/2012/fall>
The theoretical minimum by Leonard Susskind</a>
.
  The lectures are breezy in style, building up the minimal theory (and no proofs)
  for the math, and a bunch of lectures spent analysing the physics. While I wish
  it were a little more proof heavy, it was a really great reference to learn the
  basic theory! I definitely recommend following this and then reading other
  books to fill in the gaps.
</li>
<li>
 <a href=https://en.wikipedia.org/wiki/Gravitation_(book>
Gravitation by Misner Thorne and Wheeler</a>
)
  This is an imposing book. I first read through the entire thing (Well, the parts I thought I needed),
  to be able to get a vague sense of what they're going for. They're rigorous in
  a very curious way: It has a bunch of great <i>physics</i> perspectives of looking
  at things, and that was invaluable to me. Their view of forms as "slot machines"
  is also fun. In general, I found myself repeatedly consulting this book for
  the "true physical" meaning of a thing, such as curvature, parallel transport,
  the equation of a geodesic, and whatnot.
</li>
<li>
 <a href=http://www2.ing.unipi.it/griff/files/dC.pdf>
Differential Geometry of Curves and Surfaces by do Carmo</a>

  This is the best book to intro differential geometry I found. It throws away
  all of the high powered definitions that "modern" treatments offer, and
  starts from the ground up, building up the theory in 2D and 3D. This is amazing,
  since it gives you small, computable examples for things like
  "the Jacobian represents how tangents on a surface are transformed locally".
</li>
<li>
 <a href=https://www.youtube.com/watch?v=pXGTevGJ01o&list=PLDfPUNusx1EoVnrQcCRishydtNBYU6A0c>
Symplectic geometry & classical mechanics by Tobias Osborne</a>

  This lecture series was great, since it re-did a lot of the math I'd seen
  in a more physicist style, especially around vector fields, flows, and
  Lie brackets. Unfortunately for me, I never even <i>got</i> to the classical
  mechanics part by the time the semester ended. I began
  <a href=https://github.com/bollu/notes/blob/master/diffgeo/main.pdf>
taking down notes in my repo</a>
,
  which I plan to complete.
</li>
<li>
 <a href=https://sites.math.washington.edu/~lee/Books/ISM/>
Introduction to Smooth manifolds: John Lee</a>

  This was a very well written <i>mathematical</i> introduction to differential geometry.
  So it gets to the physically important bits (metrics, covariant derivatives)
  far later, so I mostly used it as a reference for problems and more rigour.
</li>
<li>
 <a href=http://hermes.ffn.ub.es/luisnavarro/nuevo_maletin/Einstein_GRelativity_1916.pdf>
Einstein's original paper introducing GR, translated</a>

  finally made it click as to <i>why</i>
  he wanted to use tensor equations: tensor equations of the form <code>T = 0</code> are
  invariant in <i>any coordinate system</i>, since on change of coordinates, <code>T</code>
  changes by a multiplicative factor! It's a small thing in hindsight, but it
  was nice to see it explicitly spelled out, since as I understand, no one
  among the physicists knew tensor calculus at the time, so he had to introduce
  all of it.
</li>

</ul>

<h4><a id=discrete-differential-geometry href='#discrete-differential-geometry'> § </a> Discrete differential geometry</h4>
I can't recall how I ran across this: I think it was because I was trying to
get a better understanding of Cohomology, which led me to Google for
"computational differential geometry", that finally led me to Discrete
differential geometry.
It's a really nice collection of theories that show us how to discretize
differential geometry in low dimensions, leading to rich intuitions and
a myriad of applications for computer graphics.
<ul>
<li>
 <a href=https://www.cs.cmu.edu/~kmcrane/Projects/DDG/paper.pdf>
The textbook by Kennan Crane on the topic</a>

  which I read over the summer when I was stuck (more often than I'd like) in
  the Paris metro. The book is very accessible, and requires just some
  imagination to grok. Discretizing differential geometry leads to most things
  being linear algebra, which means one can calculate things on paper easily.
  That's such a blessing.
</li>
<li>
 <a href=https://arxiv.org/pdf/1204.6216>
Geodesics in Heat</a>

  explores a really nice way to discover geodesics by simulating the heat
  equation for a short time. The intuition is that we should think of the heat
  equation as describing the evolution of particles that are performing random
  walks. Now, if we simulate this system for a short while and then look at the
  distribution, particles that reach a particular location on the graph 
  <i>must have taken the shortest path</i>, since any longer path would not have 
  allowed particles to reach there. Thus, the distribution of particles at 
  time <code>dt</code> does truly represent distances from a given point.  The paper
  explores this analogy to find accurate geodesics on complex computational
  grids. This is aided by the use of differential geometry, appropriately
  discretized.
</li>
<li>
 <a href=https://arxiv.org/pdf/1805.09170.pdf>
The vector heat method</a>

  explores computing the parallel transport of a vector across a discrete
  manifold efficiently, borrowing techniques from the 'Geodesics in Heat'
  paper.
</li>
<li>
 <a href=https://www.cs.cmu.edu/~kmcrane/Projects/LieGroupIntegrators/paper.pdf>
Another paper by Kennan Crane: Lie group integrators for animation and control of vehicles</a>

  This paper describes a general recipe to tailor-make integrators for a system
  of constraints, by directly integrating over the lie group of the
  configuration space.  This leads to much more stable integrators. I have some
  misguided hope that we can perhaps adapt these techniques to build better FRP
  (functional reactive programming) systems, but I need to meditate on this a
  lot more to say anything definitively.
</li>

</ul>

<h4><a id=synthetic-differential-geometry href='#synthetic-differential-geometry'> § </a> Synthetic differential geometry</h4>
It was <a href=http://assert-false.net/arnaud/>
Arnaud Spiwack</a>

who pointed me to this. It's a nice axiomatic
system of differential geometry, where we can use physicist style proofs of
"taking stuff upto order <code>dx</code>", and having everything work upto mathematical
rigor.
The TL;DR is that we want to add a new number called <code>dx</code> into the reals,
such that <code>dx^2 = 0</code>. But if such a number did exist, then clearly <code>dx = 0</code>.
However, the punchline is that to prove that <code>dx^2 = 0 => dx = 0</code> requires
the use of contradiction!
So, if we banish the law of excluded middle (and therefore no longer use
proof by contradiction), we are able to postulate the existence of a new
element <code>dx</code>, which obeys <code>dx^2 = 0</code>. Using this, we can build up the
whole theory of differential geometry in a pleasing way, without having to
go through the horror that is real analysis. (I am being hyperbolic, but really,
real analytic proofs are not pleasant).
<a href=https://www.github.com/bollu/diffgeo>
I began formalizing this in Coq and got a formalism going: <code>bollu/diffgeo</code></a>
.
Once I was done with that, I realised I don't know how to exhibit <i>models</i> of
the damn thing! So, reading up on that made me realise that I need around 8
chapters worth of a grad level textbook (the aptly named
<a href=https://link.springer.com/book/10.1007/978-1-4757-4143-8>
Models of Smooth Infinitesimal Analysis</a>
).
I was disheartened, so I <a href=https://mathoverflow.net/questions/346385/constructing-computable-synthetic-differential-geometry>
asked on <code>MathOverflow</code></a>

(also my first ever question there), where I learnt about tangent categories and
differential lambda calculus. Unfortunately, I don't have the bandwidth to read
another 150-page tome, so this has languished.
<h4><a id=optimisation-on-manifolds href='#optimisation-on-manifolds'> § </a> Optimisation on Manifolds</h4>
I began reading
<a href=http://www.eeci-institute.eu/GSC2011/Photos-EECI/EECI-GSC-2011-M5/book_AMS.pdf>
Absil: Optimisation on matrix manifolds</a>

which describes how to perform optimisation / gradient descent on
<i>arbitrary Riemannian manifolds</i>, as well as closed forms for well-known
manifolds. The exposition in this book is really good, since it picks a
concrete manifold and churns out all the basic properties of it manually. The
only problem I had with the books was that there were quite a few gaps (?) in
the proofs -- perhaps I missed a bunch.
This led me to learn Lie theory to some degree, since that was the natural
setting for many of the proofs. I finally saw <i>why</i> anyone gives a shit about
the tangent space at the identity: because it's <i>easier to compute!</i> For a
flavour of this, 
<a href=https://math.stackexchange.com/questions/3389983/explicit-description-of-tangent-spaces-of-on>
consider this question on <code>math.se</code> by me that asks about computing tangent spaces of <span class='latexinline'>
<span style="font-style:italic">O</span>(<span style="font-style:italic">n</span>)</span></a>
.
<h4><a id=aircs-workshop href='#aircs-workshop'> § </a> AIRCS workshop</h4>
I attended the
<a href=https://intelligence.org/ai-risk-for-computer-scientists/>
AI risk for computer scientists</a>

workshop hosted by
<a href=https://intelligence.org/>
MIRI (Machine intelligence research institute)</a>
 in
December. Here, a bunch of people were housed at a bed & breakfast for a
week, and we discussed AI risk, why it's potentially the most important thing
to work on, and anything our hearts desired, really. I came away with new
branches of math I wanted to read, a better appreciation of the AI risk
community and a sense of what their "risk timelines" were, and some
explanations about sheaves and number theory that I was sorely lacking. All in
all, it was a great time, and I'd love to go back.
<h4><a id=p-adic-numbers href='#p-adic-numbers'> § </a> P-adic numbers</h4>
While I was on a particularly rough flight back from the USA to India when
coming back from the AIRCS workshop, I began to read the textbook
<a href=https://www.springer.com/gp/book/9783540629115>
Introduction to p-adic numbers by Fernando Gouvea</a>
,
which fascinated me, so I then
<a href=http://bollu.github.io/#a-motivation-for-p-adic-analysis>
wrote up the cool parts introduced in the first two chapters as a blog post</a>
.
I wish to learn more about the p-adics and p-adic analysis, since they
seem to be deep objects in number theory.
In particular, a question that I thought might have a somewhat trivial answer
(<a href=https://math.stackexchange.com/questions/3482489/why-does-the-p-adic-norm-use-base-p>
why do the p-adics use base p in defining norm</a>
)
turned out to have answers that were quite deep, which was something
unexpected and joyful!
<h4><a id=topology-of-functional-programs href='#topology-of-functional-programs'> § </a> Topology of functional programs</h4>
<ul>
<li>
 <a href=http://cs.ioc.ee/ewscs/2012/escardo/slides.pdf>
Slides by Martın Escardo</a>

</li>
<li>
 <a href=https://pdf.sciencedirectassets.com/272990/1-s2.0-S1571066104X00177/1-s2.0-S1571066104051357/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEJP%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLWVhc3QtMSJHMEUCIGQAb828p1io4csznEej60j0PwJteuXf7OoHLSCDhkUTAiEA9ITs1JrUEOE%2Ft%2Fl5TI9ZkNLUfBIx42IZ%2FoAqQpdX4twq2AII6%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARACGgwwNTkwMDM1NDY4NjUiDBQOxJ3s3HCbVxSheCqsAt65yorZMMtIhLF7ML5sJQ9S5wZxBayKDrRkUKOjSzXxtQWebXs70FXhhpToXKvJoDrLgsqDzdF%2FAshZY%2FkDUep6KILxKnYxCBrBINhjFqxDlRZH0s1Y991RgCyNNnwmFI%2BrH70lSrV0OxQ9Z5WdXXPDkTLXv8512Xz%2BJn5DqEqdqD49FLbOuHl6PRM0TnYyNJkLBXNVwt75kkGkaTfdgmgiqh7YpcXcHlbqI2oqNcaxFDewXwKDCC7qWD6ECclLgszoeOXOtRI91nvNac8%2BLV4bXkKLXpd99H94N2vXPUPz99p6oqfdY9ixtcfI9POFX8agUilYjXKVhAWk4FSzzzMqbtZLBfkCZT4ffDTxRgL52yD%2FmL5E0Pe4mczVlUoB5DKoB8Lkitrt0BumQzDr4ffvBTrQAjVRuzG5V0CC%2Fd1t%2BUMPkrywaYytbrXCZ%2BkDo0xDBqsljY8DaGIiFINr8BEEpT7UX42GRhcDzpnOnztdAOTea3qZ3SmXJwgEoh0aiz%2B87MmsC57s0Q%2F%2B%2FDDvHBY3zLCrz7rdewXOgk6VxI9d5mhG3Du1dwPRbgOe798S2waDCD8LQA3rw7w5wNGa9Uv3xtNVH%2BHw%2FXcQ6OiubO4GL9mK8U5g7TVPh1hLB26XBQooKJ564VGf4J9VqWxjlx3NicVhqnFlGevNJNKyVLiyRsRCyQGMV59%2BXqUwdEMQZYWLbfUwELNz1NKfWumvu9BXC5jjsJgNx%2FRERSb7hqT1svMJU91o%2FHtatGAnPvVjYaNthha9O9jm%2BG9nw1vMsdyJ0asI5w5SrlsEyb5C7Vk7aLBcHAEi3XPRhivY1Q4hZAN0xY9VfEZrF%2FoM9HCGxr5cYs%2BP9w%3D%3D&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Date=20191221T113658Z&X-Amz-SignedHeaders=host&X-Amz-Expires=300&X-Amz-Credential=ASIAQ3PHCVTY6QRXTPOC%2F20191221%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Signature=8a26656e8f8c8772afdc2ae6caa9b583fd59a8ee6303d9770d25b4a3d8a6291f&hash=42518d3e5cc1e77ed961c359d0ea8f59bd582d1e5f13d69c3eeb2563a6c82abd&host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&pii=S1571066104051357&tid=spdf-584e8188-4806-44bb-a118-9b63a53caaff&sid=f53691052392834d3e18a62484e2909639a9gxrqb&type=client>
Synthetic topology of data types and classical spaces</a>

</li>

</ul>

Both of these describe a general method to transfer all topological ideas as
statements about <i>computability</i> in a way that's far more natural (at least for
me, as a computer scientist). The notion of what a continuous function "should
be" (keeping inverse images of open sets open) arises naturally from this
computational viewpoint, and many proofs of topology amount to finding
functional programs that fit a certain type. It's a great read, and I feel gave
me a much better sense of what topology is trying to do.
<ul>
<li>
 <a href=http://bollu.github.io/#topology-is-really-about-computation--part-1>
I've written some exposition on this topic</a>
,
  which maybe a more accessible read than the links above, since it tries to
  distill the fundamental idea into a blog post.
</li>

</ul>

<h4><a id=philosophy href='#philosophy'> § </a> Philosophy</h4>
I've wanted to understand philosophy as a whole for a while now, at least
enough to get a general sense of what happened in each century. The last year,
I meandered through some philosophy of science, which led me to some really
wild ideas (such as that of
<a href=https://en.wikipedia.org/wiki/Epistemological_anarchism>
Paul Feyerabend's 'science as an anarchic enterprise'</a>

which I really enjoyed).
I also seem to get a lot more out of audio and video than text in general, so
I've been looking for podcasts and video lectures. I've been following:
<ul>
<li>
 <a href=https://historyofphilosophy.net/>
The history of philosophy without any gaps</a>

  for a detailed exposition on, say, the greeks, or the arabic philosophers.
  Unfortunately, this podcast focuses on far too much detail for me to have been
  able to use it as a way to get a broad idea about <i>philosophy</i> in itself.
</li>

</ul>

<ul>
<li>
 <a href=http://philosophizethis.org/>
Philosophize This! by Stephen West</a>

  Is a good philosophy podcast for a <i>broad</i> overview of different areas
  of Philosophy. I got a lot out of this, since I was able to get a sense
  of the progression of ideas in (Western) Philosophy. So I now know what
  <a href=https://plato.stanford.edu/entries/phenomenology/>
Phenomenology</a>
 is,
  or what Foucault was reacting against.
</li>

</ul>

I also attempted to read a bunch of philosophers, but the only ones I could
make a good dent on were the ones listed below. I struggled in writing this
section, since it's much harder to sanity check my understanding of philosophy,
versus mathematics, since there seems to be a range of interpretations of the
same philosophical work, and the general imprecise nature of language doesn't
help here at all. So please take all the descriptions below with some salt
to taste.
<ul>
<li>
 <a href=https://en.wikipedia.org/wiki/Discipline_and_Punish>
Discipline and Punish by Michel Foucault</a>

  Here, Foucault traces the history of the criminal justice system of society,
  and how it began as something performed 'on the body' (punishment),
  which was then expanded to a control 'of the mind' (reform). As usual,
  the perspective is fun, and I'm still going through the book.
</li>

</ul>

<ul>
<li>
 <a href=https://en.wikipedia.org/wiki/Madness_and_Civilization>
Madness and Civilization by Michel Foucault</a>

  which attempts to chronicle how our view of madness evolved as society did.
  It describes how madmen, who were on the edges of society, but still
  "respected" (for exmaple, considered as 'being touched by the gods') were
  pathologized by the Renaissance, and were seen as requiring treatment. I'm
  still reading it, but it's enjoyable so far, as a new perspective for me.
</li>

</ul>

<ul>
<li>
 <a href=https://en.wikipedia.org/wiki/The_Value_of_Science>
The value of science by Henri Poincare</a>
.
  Here, he defends the importance of experimentation, as well as the value of
  intuition to mathematics, along with the importance of what we consider
  formal logic. It's a tough read sometimes, but I think I got something out of
  it, at least in terms of perspective about science and mathematics.
</li>

</ul>

<h4><a id=information-theory href='#information-theory'> § </a> Information theory</h4>
I've been on a quest to understand information theory far better than I
currently do. In general, I feel like this might be a much better way to
internalize probability theory, since it feels like it states probabilistic
objects in terms of "couting" / "optimisation of encodings", which is a
perspective I find far more natural.
Towards this aim, I wound up reading:
<ul>
<li>
 <a href=http://www.inference.org.uk/mackay/itila/book.html>
Information theory, Learning, and inference algorithms</a>

  This book attempts to provide the holistic view I was hoping for. It has
  great illustrations of the basic objects of information theory. However,
  I was hoping that the three topics would be more "unified" in the book,
  rather than being presented as three separate sections with some amount
  of back-and-forth-referencing among them. Even so, it was a really fun read.
</li>

</ul>

<ul>
<li>
 <a href=http://www.cs-114.org/wp-content/uploads/2015/01/Elements_of_Information_Theory_Elements.pdf>
Elements of information theory</a>

</li>

</ul>

<h4><a id=building-intuition-for-sheaves-topoi-logic href='#building-intuition-for-sheaves-topoi-logic'> § </a> Building intuition for Sheaves, Topoi, Logic</h4>
I don't understand the trifecta of sheaves, topoi, geometry, and logic, and
I'm trying to attack this knot from multiple sides at once.
<ul>
<li>
 <a href=https://arxiv.org/pdf/1308.4621>
Understanding networks and their behaviours using sheaf theory</a>

</li>
<li>
 <a href=https://www.sciencedirect.com/science/article/pii/S1571066108005264>
Sheaves, objects, and distributed systems</a>

</li>
<li>
 <a href=https://arxiv.org/pdf/1603.01446.pdf>
Sheaves are the canonical data strucure for sensor integration</a>

</li>
<li>
 <a href=https://www.math.upenn.edu/~ghrist/EAT/EATchapter9.pdf>
Elementary applied topology, Chapter 9: Sheaves</a>

</li>
<li>
 <a href=https://news.ycombinator.com/item?id=13677308>
Sheaf theory: The mathematics of data fusion (video) (link to HackerNews)</a>

</li>

</ul>

All of these provide geometric viewpoints of what sheaves are, in low-dimensional
examples of graphs which are easy to visualize. I'm also trudging through the
tome:
<ul>
<li>
 <a href=https://www.springer.com/gp/book/9780387977102>
Sheaves in geometry and logic: A first introduction to Topos theory</a>

</li>

</ul>

which appears to follow the "correct path" of the algebraic geometers, but this
requires a lot of bandwidth.
<ul>
<li>
 <a href=http://math.stanford.edu/~vakil/216blog/FOAGnov1817public.pdf>
The Rising Sea: foundations of algebraic geometry by Ravi Vakil</a>

</li>

</ul>

This is a hardcore algebraic geometry textbook, and is arguably
<i>great for studying sheaves</i> because of it. Sheaves are Chapter 2, and allows
one to see them be developed in their "true setting" as it were. In that
Grothendeick first invented sheaves for algebraic geometry, so it's good to
see them in the home they were born in. Once again, this is a book I lack
bandwidth for except to breezily read it as I go to bed. I did get something
out from doing this. I'm considering taking this book up as an independent
study, say the first four chapters. I'll need someone who knows algebraic
geometry to supervise me, though, which is hard to find in an institute geared
purely for computer science. (If anyone on the internet is kind enough to
volunteer some of their time to answer questions, I'll be very glad! Please
email me at <code>rot13(fvqqh.qehvq@tznvy.pbz)</code>)
<h4><a id=the-attic href='#the-attic'> § </a> The attic</h4>
This section contains random assortments that I don't recall how I stumbled
across, but too cool to not include on the list. I usually read these in bits
and pieces, or as bedtime reading right before I go to bed to skim.  I find
that skimming such things gives me access to knowing about tools I would not
have known otherwise. I like knowing the existence of things, even if I don't
recall the exact thing, since knowing that something like <code>X</code> exists has saved me
from having to reinvent <code>X</code> from scratch.
<ul>
<li>
 <a href=http://www.cns.gatech.edu/GroupTheory/version9.0/GroupTheory.pdf>
Group Theory: Birdtracks, Lie's and Exceptional Groups by Predrag Cvitanovic</a>

  is an exposition of Lie theory using some notation called as "Birdtrack notation",
  which is supposedly a very clean way of computing invariants, inspired by
  Feynmann notation. The writing style is informal and pleasant, and I decided
  to save the book purely because the first chapter begins with
  "Basic Concepts: A typical quantum theory is constructed from a few building blocks...".
  If a book considers building quantum theories as its starting point, I really
  want to see where it goes.
</li>

</ul>

<ul>
<li>
 <a href=https://www.math.upenn.edu/~ghrist/notes.html>
Elementary Applied topology by Robert M Ghirst</a>

  I wouldn't classify the book as elementary because it skims over too much to be
  useful as a reference, but it's great to gain an intuition for what, say,
  homology or cohomology is. I am currently reading the section on Sheaf theory,
  and I'm getting a lot out of it, since it describes how to write down, say,
  min-cut-max-flow or niquist-shannon in terms of sheaves. I don't grok it yet,
  but even knowing this can be done is very nice. The book is a wonderful
  walkthrough in general.
</li>

</ul>

<ul>
<li>
 <a href=https://icerm.brown.edu/video_archive/?play=2034>
On polysemous mathematical illustration by Robert M Ghirst</a>

  This is a talk on the wonderful illustrations by the above author, about
  the different types of mathematical illustrations one can have, and different
  "levels of abstraction".
</li>

</ul>

<ul>
<li>
 <a href=http://chronologia.org/en/math_impressions/poster016.html>
Mathematical Impressions: The illustrations of AT Femenko</a>

  These are <i>beautiful</i> illustrated pictures of various concepts in math, which
  tend to <i>evoke</i> the feeling of the object, without being too direct about it.
  For example, consider "gradient descent" below. I highly recommend going
  through the full gallery.
</li>

</ul>

<ul>
<li>
 <a href=http://chronologia.org/art/math/123a176.jpg>
Gradient Descent</a>

  <img width=200 height=200 src="http://chronologia.org/art/math/123a176.jpg">
</li>

</ul>

<ul>
<li>
 <a href=http://chronologia.org/art/math/077a011.jpg>
Topological Zoo</a>

  <img width=200 height=200 src="http://chronologia.org/art/math/077a011.jpg">
</li>

</ul>

<ul>
<li>
 <a href=https://bastian.rieck.me/research/Dissertation_Rieck_2017.pdf>
Persistent Homology in Multivariate Data Visualization</a>

  This is the PhD dissertation of <a href=https://bastian.rieck.me/>
Bastian Rieck</a>
,
  who's now a postdoc at ETH. I deeply enjoyed reading it, since it pays
  a lot of attention to the <i>design</i> of analyses, and how to interpret
  topological data. I really enjoyed getting a good sense of how one can
  use persistent homology to understand data, and the trade-offs between
  <a href=https://en.wikipedia.org/wiki/Vietoris%E2%80%93Rips_complex>
Vietoris-Rips complex</a>

  and the <a href=https://en.wikipedia.org/wiki/%C4%8Cech_complex>
Cech complex</a>
.
</li>

</ul>

<ul>
<li>
 <a href=https://arxiv.org/pdf/1205.5935.pdf>
An introduction to Geometric algebra</a>

  I fell in love with geometric algebra, since it provides a really clean way
  to talk about <i>all possible subspaces</i> of a given vector space. This provides
  super slick solutions to many geometry and linear algebra problems. The
  way I tend to look at it is that when one does linear algebra, there's a strict
  separation between "vectors" (which are elements of the vector space), and,
  say, "hyperplanes" (which are <i>subspaces</i> of the vector space), as well as
  objects such as "rotations" (which are <i>operators</i> on the vector space).
  Geometric algebra provides a rich enough <i>instruction set</i> to throw all
  these three distinct things into a blender. This gives a really concise
  language to describe all phenomena that occurs in the vector space world ---
  which, let's be honest, is <i>most</i> tractable phenomena! I had a blast
  reading about GA and the kinds of operators it provides.
</li>

</ul>

<ul>
<li>
 <a href=https://arxiv.org/pdf/1807.07159>
Circuits via Topoi</a>
. This paper attempts
  to provide an introduction to topos theory by providing a semantics for
  both combinational and sequential circuits under a unifying framework. I keep
  coming back to this article as I read more topos theory. Unfortunately, I'm
  not "there yet" in my understanding of topoi. I hope to be next year!
</li>

</ul>

<ul>
<li>
 <a href=https://press.princeton.edu/books/paperback/9780691138718/fearless-symmetry>
Fearless Symmetry</a>

  This is definitely my favourite non-fiction book that I've read in 2019, hands
  down. The book gives a great account of the mathematical objects that went
  into Wiles' book of Fermat's last theorem. It starts with things like
  "what is a permutation" and ends at questions like "what's a reciprocity law"
  or "what's the absolute galois group". While at points, I do believe the book
  goes far too rapidly, all in all, it's a solid account of number theory
  that's distilled, but not in any way diluted. I really recommend reading this
  book if you have any interest in number theory (or, like me, a passing
  distaste due to a course on elementary number theory I took, with proofs that
  looked very unmotivated). This book made me decide that I should, indeed,
  definitely learn algebraic number theory, upto at least
  <a href=https://en.wikipedia.org/wiki/Artin_reciprocity_law>
Artin Reciprocity</a>
.
</li>

</ul>

<ul>
<li>
 <a href=https://en.wikipedia.org/wiki/Remembrance_of_Earth%27s_Past>
Rememberance of Earth's past trilogy by Liu Cixin</a>

  While I would not classify this as "mind-blowing" (which I do classify Greg
  Egan books as), they were still a solidly fun read into how humanity would
  evolve and interact with alien races. It also poses some standard solutions
  to the Fermi Paradox, but it's done well. I felt that the fact that it was
  translated was painfully obvious in certain parts of the translation, which
  I found quite unfortunate. However, I think book 3 makes up in grandeur for
  whatever was lost in translation.
</li>

</ul>

<ul>
<li>
 <a href=https://en.wikipedia.org/wiki/Walkaway_(Doctorow_novel>
Walkaway by Cory Doctorow</a>
)
  The book is set in a dystopian nightmare, where people are attempting to
  "walk away" from society and set up communes, where they espouse having
  a post-scarcity style economy based on gifting. It was a really great
  description of what such a society could look like. I took issue with some
  weird love-triangle-like-shenanigans in the second half of the book, but
  the story arc more than makes up for it. Plus, the people throw a party
  called as a "communist party" in the first page of the book, which grabbed
  my attention immediately!
</li>

</ul>

<ul>
<li>
 <a href=http://www.cs.unipr.it/purrs/>
PURRS: Parma University Recurrence Relation Solver</a>

  I wanted better tactics for solving recurrences in Coq, which led me into
  a rabbit hole of the technology of recurrence relation solving. This was the
  newest <i>stable</i> reference to a complete tool that I was able to find. Their
  references section is invaluable, since it's been vetted by them
  actually implementing this tool!
</li>

</ul>

<ul>
<li>
 <a href=https://www21.in.tum.de/~nipkow/TRaAT/>
Term rewriting and all that</a>
.
  I read this book purely for its description of Groebner bases and the Bucchberger
  algorithm in a way that <i>made sense</i> for the first time.
  <a href=http://bollu.github.io/#what-the-hell-is-a-grobner-basis-ideals-as-rewrite-systems>
I've written about this more extensively before</a>

  so I'm not going to repeat myself here. In general, I think it's a great book
  that's worth reading, if nothing else, for at least the chapter on Groebner
  bases.
</li>

</ul>

<ul>
<li>
 <a href=http://worrydream.com/refs/Wadge%20-%20Lucid,%20the%20Dataflow%20Programming%20Language.pdf>
Lucid: The dataflow programming language</a>

  This document is the user manual of Lucid. I didn't fully understand the
  book, but what I understood as their main argument is that full access too
  looping is un-necessary to perform most of the tasks that we do. Rather,
  one can provide a "rich enough" set of combinators to manipulate streams
  that allows one to write all programs worthy of our interest.
</li>

</ul>

<ul>
<li>
 <a href=https://hal.inria.fr/inria-00548290/document>
Bundle Adjustment — A Modern Synthesis</a>

  I learnt about Bundle Adjustment from a friend taking a course on robotics.
  The general problem is to reconstruct the 3D coordinates of a point cloud
  given 2D projections of the points and the camera parameters, as the camera
  moves in time. I found the paper interesting since it winds up invoking a
  decent amount of differential geometric and gauge theoretic language to
  describe the problem at hand. I was unable to see why this vocabulary helped
  in this use-case, but perhaps I missed the point of the paper. It was hard to
  tell.
</li>

</ul>

<h4><a id=conclusions href='#conclusions'> § </a> Conclusions</h4>
I always feel a little wrong posting this at the end of every year, since I
feel that among the things I cover under "read", I've internalized some things
far better than others: For example, I feel I understannd Riemannian geometry
far better than I do General Relativity. I try to put up the caveats at the
beginning of each section, but I'd really like a way to communicate my
confidence without reducing readability.
The final thing that I wish for is some kind of reading group? It's hard
to maintain a group when my interests shift as rapidly as they do, which
was one of the reason I really loved the AIRCS workshop: They were people
who were working on formal methods, compilers, type theory, number theory,
embedded systems, temporal logic... It was very cool to be in a group of
people who had answers and intuitions to questions that had bugged me for
some time now. I wonder if attending courses at a larger research university
feels the same way. My uni is good, but we have quite small population, which
almost by construction means reduced diversity.
I also wish that I could openly add more references to repos I've been working
on for a while now, but I can't due to the nature of academia and publishing.
This one bums me out, since there's a long story of a huge number of commits
and trial-by-fire that I think I'll be too exhausted to write about once the
thing is done.
Sometimes, I also wish that I could spend the time I spend reading <i>disparate</i>
topics on <i>focused reading on one topic</i>. Unfortunately, I feel like I'm not
wired this way, and the joy I get from sampling many things at the same time
and making connections is somehow much deeper than the joy I get by deeply
reading one topic (in exclusion of all else). I don't know what this says
about my chances as a grad student in the future <code>:)</code>.
<h3><a id=a-motivation-for-p-adic-analysis href='#a-motivation-for-p-adic-analysis'> § </a> <a href=#a-motivation-for-p-adic-analysis>
A motivation for p-adic analysis</a>
</h3>
I've seen the definitions of p-adic numbers scattered around on the internet,
but this analogy as motivated by the book
<a href=https://www.springer.com/gp/book/9783540629115>
p-adic numbers by Fernando Gouvea</a>

really made me understand why one would study the p-adics, and why the
definitions are natural. So I'm going to recapitulate the material, with the
aim of having somoene who reads this post be left with a sense of why it's
profitable to study the p-adics, and what sorts of analogies are fruitful when
thinking about them.
We wish to draw an analogy between the ring <span class='latexinline'>
&#X2102;[<span style="font-style:italic">X</span>]</span>, where <span class='latexinline'>
(<span style="font-style:italic">X</span> &#X2212; &#X3B1;)</span>
are the prime ideals, and <span class='latexinline'>
&#X2124;</span> where <span class='latexinline'>
(<span style="font-style:italic">p</span>)</span> are the prime ideals. We wish
to take all operations one can perform with polynomials, such as generating
functions (<span class='latexinline'>
1/(<span style="font-style:italic">X</span> &#X2212; &#X3B1;) = 1 + <span style="font-style:italic">X</span> + <span style="font-style:italic">X</span><sup>2</sup> + &#X2026;</span> ),
taylor expansions (expanding aronund <span class='latexinline'>
(<span style="font-style:italic">X</span> &#X2212; &#X3B1;)</span>),
and see what their analogous objects will look like in <span class='latexinline'>
&#X2124;</span>
relative to a prime <span class='latexinline'>
<span style="font-style:italic">p</span></span>.
<h4><a id=perspective-taylor-series-as-writing-in-base- href='#perspective-taylor-series-as-writing-in-base-'> § </a> Perspective: Taylor series as writing in base <span class='latexinline'>
<span style="font-style:italic">p</span></span>:</h4>
Now, for example, given a prime <span class='latexinline'>
<span style="font-style:italic">p</span></span>, we can write any positive integer <span class='latexinline'>
<span style="font-style:italic">m</span></span>
in base <span class='latexinline'>
<span style="font-style:italic">p</span></span>, as <span class='latexinline'>
(<span style="font-style:italic">m</span> = &#X2211;<sub><span style="font-style:italic">i</span>=0</sub><sup><span style="font-style:italic">n</span></sup> <span style="font-style:italic">a</span><sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">p</span><sup><span style="font-style:italic">i</span></sup>)</span> where <span class='latexinline'>
(0 &#X2264; <span style="font-style:italic">a</span><sub><span style="font-style:italic">i</span></sub> &#X2264; <span style="font-style:italic">p</span> &#X2212; 1)</span>.
For example, consider <span class='latexinline'>
<span style="font-style:italic">m</span> = 72, <span style="font-style:italic">p</span> = 3</span>. The expansion of 72 is
<span class='latexinline'>
72 = 0&#XD7; 1 + 0 &#XD7; 3 + 2 &#XD7; 3<sup>2</sup> + 2 &#XD7; 3<sup>3</sup></span>.
This shows us that 72 is divisible by <span class='latexinline'>
3<sup>2</sup></span>.
This perspective to take is that this us the information local to prime <span class='latexinline'>
<span style="font-style:italic">p</span></span>,
about what order the number <span class='latexinline'>
<span style="font-style:italic">m</span></span> is divisible by <span class='latexinline'>
<span style="font-style:italic">p</span></span>,
just as the taylor expansion tells us around <span class='latexinline'>
(<span style="font-style:italic">X</span> &#X2212; &#X3B1;)</span> of a polynomial <span class='latexinline'>
<span style="font-style:italic">P</span>(<span style="font-style:italic">X</span>)</span>
tells us to what order <span class='latexinline'>
<span style="font-style:italic">P</span>(<span style="font-style:italic">X</span>)</span> vanishes at a point <span class='latexinline'>
&#X3B1;</span>.
<h4><a id=perspective-rational-numbers-and-rational-functions-as-infinite-series href='#perspective-rational-numbers-and-rational-functions-as-infinite-series'> § </a> Perspective: rational numbers and rational functions as infinite series:</h4>
Now, we investigate the behaviour of expressions such as
<ul>
<li>
 <span class='latexinline'>
<span style="font-style:italic">P</span>(<span style="font-style:italic">X</span>) = 1/(1+<span style="font-style:italic">X</span>) = 1 &#X2212; <span style="font-style:italic">X</span> + <span style="font-style:italic">X</span><sup>2</sup> &#X2212;<span style="font-style:italic">X</span><sup>3</sup> + &#X2026;</span>.
</li>

</ul>

We know that the above formula is correct formally from the theory of
generating functions.  Hence, we take inspiration to define values for
<i>rational numbers</i>.
Let's take <span class='latexinline'>
<span style="font-style:italic">p</span> &#X2261; 3</span>, and we know that <span class='latexinline'>
4 = 1 + 3 = 1 + <span style="font-style:italic">p</span></span>.
We now calculate <span class='latexinline'>
1/4</span> as:
<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">1/4&#XA0;=&#XA0;1/(1+<span style="font-style:italic">p</span>)&#XA0;=&#XA0;1&#XA0;&#X2212;&#XA0;<span style="font-style:italic">p</span>&#XA0;+&#XA0;<span style="font-style:italic">p</span><sup>2</sup>&#XA0;&#X2212;&#XA0;<span style="font-style:italic">p</span><sup>3</sup>&#XA0;+&#XA0;<span style="font-style:italic">p</span><sup>4</sup>&#XA0;&#X2212;&#XA0;<span style="font-style:italic">p</span><sup>5</sup>&#XA0;+&#XA0;<span style="font-style:italic">p</span><sup>6</sup>&#XA0;+&#XA0;&#X22EF;
</td></tr>
</table></div>
However, we don't really know how to interpret <span class='latexinline'>
(&#X2212;1 &#XB7; <span style="font-style:italic">p</span>)</span>, since we assumed
the coefficients are always non-negative. What we can do is to rewrite <span class='latexinline'>
<span style="font-style:italic">p</span><sup>2</sup> = 3<span style="font-style:italic">p</span></span>,
and then use this to make the coefficient positive. Performing this transformation
for every negative coefficient, we arrive at:
<div class='latexblock'><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >1/4</td><td style="text-align:left;white-space:nowrap" >=&#XA0;1/(1+<span style="font-style:italic">p</span>)&#XA0;=&#XA0;1&#XA0;&#X2212;&#XA0;<span style="font-style:italic">p</span>&#XA0;+&#XA0;<span style="font-style:italic">p</span><sup>2</sup>&#XA0;&#X2212;&#XA0;<span style="font-style:italic">p</span><sup>3</sup>&#XA0;+&#XA0;<span style="font-style:italic">p</span><sup>4</sup>&#XA0;+&#XA0;&#X22EF;&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >=&#XA0;1&#XA0;+&#XA0;(&#X2212;&#XA0;<span style="font-style:italic">p</span>&#XA0;+&#XA0;3<span style="font-style:italic">p</span>)&#XA0;+&#XA0;(&#X2212;&#XA0;<span style="font-style:italic">p</span><sup>3</sup>&#XA0;+&#XA0;3<span style="font-style:italic">p</span><sup>3</sup>)&#XA0;&#XA0;+&#XA0;&#XA0;&#X22EF;&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >=&#XA0;1&#XA0;+&#XA0;2<span style="font-style:italic">p</span>&#XA0;+&#XA0;2<span style="font-style:italic">p</span><sup>3</sup>&#XA0;+&#XA0;&#X22EF;
</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table>
</div>
We can verify that this is indeed correct, by multiplying with <span class='latexinline'>
4 = (1 + <span style="font-style:italic">p</span>)</span>
and checking that the result is <span class='latexinline'>
1</span>:
<div class='latexblock'><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >(1&#XA0;+&#XA0;<span style="font-style:italic">p</span>)(1&#XA0;+&#XA0;2<span style="font-style:italic">p</span>&#XA0;+&#XA0;2<span style="font-style:italic">p</span><sup>3</sup>&#XA0;+&#XA0;&#X22EF;)&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >=&#XA0;(1&#XA0;+&#XA0;<span style="font-style:italic">p</span>)&#XA0;+&#XA0;(2<span style="font-style:italic">p</span>&#XA0;+&#XA0;2<span style="font-style:italic">p</span><sup>2</sup>)&#XA0;+&#XA0;(2<span style="font-style:italic">p</span><sup>3</sup>&#XA0;+&#XA0;2<span style="font-style:italic">p</span><sup>4</sup>)&#XA0;+&#XA0;&#X22EF;&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >=&#XA0;1&#XA0;+&#XA0;3<span style="font-style:italic">p</span>&#XA0;+&#XA0;2<span style="font-style:italic">p</span><sup>2</sup>&#XA0;+&#XA0;2<span style="font-style:italic">p</span><sup>3</sup>&#XA0;+&#XA0;2<span style="font-style:italic">p</span><sup>4</sup>&#XA0;+&#XA0;&#X22EF;&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >(Rewrite 3<span style="font-style:italic">p</span> = <span style="font-style:italic">p</span> &#XB7; <span style="font-style:italic">p</span> = <span style="font-style:italic">p</span><sup>2</sup>)&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >=&#XA0;1&#XA0;+&#XA0;(<span style="font-style:italic">p</span><sup>2</sup>&#XA0;+&#XA0;2<span style="font-style:italic">p</span><sup>2</sup>)&#XA0;+&#XA0;2<span style="font-style:italic">p</span><sup>3</sup>&#XA0;+&#XA0;2<span style="font-style:italic">p</span><sup>4</sup>&#XA0;+&#XA0;&#X22EF;&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >=&#XA0;1&#XA0;+&#XA0;3<span style="font-style:italic">p</span><sup>2</sup>&#XA0;+&#XA0;2<span style="font-style:italic">p</span><sup>3</sup>&#XA0;+&#XA0;2<span style="font-style:italic">p</span><sup>4</sup>&#XA0;+&#XA0;&#X22EF;&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >(Rewrite 3<span style="font-style:italic">p</span><sup>2</sup> = <span style="font-style:italic">p</span><sup>3</sup> and collect <span style="font-style:italic">p</span><sup>3</sup>)&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >=&#XA0;1&#XA0;+&#XA0;3<span style="font-style:italic">p</span><sup>3</sup>&#XA0;+&#XA0;2<span style="font-style:italic">p</span><sup>4</sup>&#XA0;+&#XA0;&#X22EF;&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >=&#XA0;1&#XA0;+&#XA0;3<span style="font-style:italic">p</span><sup>4</sup>&#XA0;+&#XA0;&#X22EF;&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >=&#XA0;1&#XA0;+&#XA0;&#X22EF;&#XA0;=&#XA0;1
</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table>
</div>
What winds up happening is that all the numbers after <span class='latexinline'>
1</span> end up being cleared
due to the carrying of <span class='latexinline'>
(3<span style="font-style:italic">p</span><sup><span style="font-style:italic">i</span></sup> &#X21A6; <span style="font-style:italic">p</span><sup><span style="font-style:italic">i</span>+1</sup>)</span>.
This little calculation indicates that we can also define take the <span class='latexinline'>
<span style="font-style:italic">p</span></span>-adic
expansion of <i>rational numbers</i>.
<h4><a id=perspective--1-as-a-p-adic-number href='#perspective--1-as-a-p-adic-number'> § </a> Perspective: -1 as a p-adic number</h4>
We next want to find a p-adic expansion of -1, since we can then expand
out theory to work out "in general". The core idea is to "borrow" <span class='latexinline'>
<span style="font-style:italic">p</span></span>, so
that we can write -1 as <span class='latexinline'>
(<span style="font-style:italic">p</span> &#X2212; 1) &#X2212; <span style="font-style:italic">p</span></span>, and then we fix <span class='latexinline'>
&#X2212;<span style="font-style:italic">p</span></span>, just like we fixed
<span class='latexinline'>
&#X2212;1</span>. This eventually leads us to an infinite series expansion for <span class='latexinline'>
&#X2212;1</span>. Written
down formally, the calculation proceeds as:
<div class='latexblock'><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >&#X2212;1</td><td style="text-align:left;white-space:nowrap" >=&#XA0;&#X2212;1&#XA0;+&#XA0;<span style="font-style:italic">p</span>&#XA0;&#X2212;&#XA0;<span style="font-style:italic">p</span>&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;(borrow <span style="font-style:italic">p</span>, and subtract to keep equality)&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >=&#XA0;(<span style="font-style:italic">p</span>&#XA0;&#X2212;&#XA0;1)&#XA0;&#X2212;&#XA0;<span style="font-style:italic">p</span>&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;(Now we have a problem of &#X2212;<span style="font-style:italic">p</span>)&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >=&#XA0;(<span style="font-style:italic">p</span>&#XA0;&#X2212;&#XA0;1)&#XA0;&#X2212;&#XA0;<span style="font-style:italic">p</span>&#XA0;+&#XA0;<span style="font-style:italic">p</span><sup>2</sup>&#XA0;&#X2212;&#XA0;<span style="font-style:italic">p</span><sup>2</sup>&#XA0;&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >=&#XA0;(<span style="font-style:italic">p</span>&#XA0;&#X2212;&#XA0;1)&#XA0;+&#XA0;<span style="font-style:italic">p</span>(<span style="font-style:italic">p</span>&#XA0;&#X2212;&#XA0;1)&#XA0;&#X2212;&#XA0;<span style="font-style:italic">p</span><sup>2</sup>&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >=&#XA0;(<span style="font-style:italic">p</span>&#XA0;&#X2212;&#XA0;1)&#XA0;+&#XA0;<span style="font-style:italic">p</span>(<span style="font-style:italic">p</span>&#XA0;&#X2212;&#XA0;1)&#XA0;&#X2212;&#XA0;<span style="font-style:italic">p</span><sup>2</sup>&#XA0;+&#XA0;<span style="font-style:italic">p</span><sup>3</sup>&#XA0;&#X2212;&#XA0;<span style="font-style:italic">p</span><sup>3</sup>&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >=&#XA0;(<span style="font-style:italic">p</span>&#XA0;&#X2212;&#XA0;1)&#XA0;+&#XA0;<span style="font-style:italic">p</span>(<span style="font-style:italic">p</span>&#XA0;&#X2212;&#XA0;1)&#XA0;+&#XA0;<span style="font-style:italic">p</span><sup>2</sup>(<span style="font-style:italic">p</span>&#XA0;&#X2212;&#XA0;1)&#XA0;&#X2212;&#XA0;<span style="font-style:italic">p</span><sup>3</sup>&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >(Generalizing the above pattern)&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >
&#X2212;1</td><td style="text-align:left;white-space:nowrap" >=&#XA0;(<span style="font-style:italic">p</span>&#XA0;&#X2212;&#XA0;1)&#XA0;+&#XA0;<span style="font-style:italic">p</span>(<span style="font-style:italic">p</span>&#XA0;&#X2212;&#XA0;1)&#XA0;+&#XA0;<span style="font-style:italic">p</span><sup>2</sup>(<span style="font-style:italic">p</span>&#XA0;&#X2212;&#XA0;1)&#XA0;+&#XA0;<span style="font-style:italic">p</span><sup>3</sup>(<span style="font-style:italic">p</span>&#XA0;&#X2212;&#XA0;1)&#XA0;+&#XA0;<span style="font-style:italic">p</span><sup>4</sup>(<span style="font-style:italic">p</span>&#XA0;&#X2212;&#XA0;1)&#XA0;+&#XA0;&#X22EF;&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table>
</div>
This now gives us access to negative numbers, since we can formally multiply
the series of two numbers, to write <span class='latexinline'>
&#X2212;<span style="font-style:italic">a</span> = &#X2212;1 &#XB7; <span style="font-style:italic">a</span></span>.
Notice that this definition of <span class='latexinline'>
&#X2212;1</span> also curiously matches the 2s complement
definition, where we have <span class='latexinline'>
&#X2212;1 = 11&#X2026; 1</span>. In this case, the expansion is
<i>infinite</i>, while in the 2s complement case, it is finite. I would be very
interested to explore this connection more fully.
<h4><a id=what-have-we-achieved-so-far href='#what-have-we-achieved-so-far'> § </a> What have we achieved so far?</h4>
We've now managed to completely reinterpret all the numbers we care about in
the rationals as power series in base <span class='latexinline'>
<span style="font-style:italic">p</span></span>. This is pretty neat. We're next
going to try to <i>complete</i> this, just as we complete the rationals to get
the reals. We're going to show that we get a <i>different</i> number system on
completion, called <span class='latexinline'>
&#X211A;<sub><span style="font-style:italic">p</span></sub></span>.
To perform this, we first look at how the <span class='latexinline'>
<span style="font-style:italic">p</span></span>-adic numbers help us solve
congruences mod p, and how this gives rise to completions to equations such
as <span class='latexinline'>
<span style="font-style:italic">x</span><sup>2</sup> &#X2212; 2 = 0</span>, which in the reals give us <span class='latexinline'>
<span style="font-style:italic">x</span> = &#X221A;<span style="text-decoration:overline">2</span></span>, and in <span class='latexinline'>
&#X211A;<sub><span style="font-style:italic">p</span></sub></span>
give us a different answer!
<h4><a id=x2-equiv-25-mod-3n href='#x2-equiv-25-mod-3n'> § </a> Solving <span class='latexinline'>
<span style="font-style:italic">X</span><sup>2</sup> &#X2261; 25 mod 3<sup><span style="font-style:italic">n</span></sup></span></h4>
Let's start by solving an equation we already know how to solve:
<span class='latexinline'>
<span style="font-style:italic">X</span><sup>2</sup> &#X2261; 25 mod 3<sup><span style="font-style:italic">n</span></sup></span>.
We already know the solutions to <span class='latexinline'>
<span style="font-style:italic">X</span><sup>2</sup> &#X2261; 25 mod 3<sup><span style="font-style:italic">n</span></sup></span> in <span class='latexinline'>
&#X2124;</span> are
<span class='latexinline'>
<span style="font-style:italic">X</span> &#X2261; &#XB1; 5 mod 3<sup><span style="font-style:italic">n</span></sup></span>.
Explicitly, the solutions are:
<ul>
<li>
 <span class='latexinline'>
<span style="font-style:italic">X</span> &#X2261; 3 mod 3</span>
</li>
<li>
 <span class='latexinline'>
<span style="font-style:italic">X</span> &#X2261; 5 mod 9</span>
</li>
<li>
 <span class='latexinline'>
<span style="font-style:italic">X</span> &#X2261; 5 mod 27</span>
</li>
<li>
 At this point, the answer remains constant.
</li>

</ul>

This was somewhat predictable. We move to a slightly more interesting case.
<h4><a id=x--5-mod-3n href='#x--5-mod-3n'> § </a> Solving <span class='latexinline'>
<span style="font-style:italic">X</span> = &#X2212;5 mod 3<sup><span style="font-style:italic">n</span></sup></span></h4>
The solution sets are:
<ul>
<li>
 <span class='latexinline'>
<span style="font-style:italic">X</span> &#X2261; &#X2212;5 &#X2261; 1 mod 3</span>
</li>
<li>
 <span class='latexinline'>
<span style="font-style:italic">X</span> &#X2261; &#X2212;5 &#X2261; 4 = 1 + 3 mod 9</span>
</li>
<li>
 <span class='latexinline'>
<span style="font-style:italic">X</span> &#X2261; &#X2212;5 &#X2261; 22 = 1 + 3 + 2 &#XB7; 9 mod 27</span>
</li>
<li>
 <span class='latexinline'>
<span style="font-style:italic">X</span> &#X2261; &#X2212;5 &#X2261; 76 = 1 + 3 + 2 &#XB7; 9 + 2 &#XB7; 27 mod 81</span>
</li>

</ul>

This gives us the infinite 3-adic expansion:
<ul>
<li>
 <span class='latexinline'>
<span style="font-style:italic">X</span> = &#X2212;5 = 1 + 1&#XB7; 3 + 2&#XB7; 3<sup>2</sup> + 2&#XB7; 3<sup>3</sup> + &#X2026;</span>
</li>

</ul>

Note that we can't really <i>predict</i> the digits in the 3-adic sequence of -5,
but we can keep expanding and finding more digits.
Also see that the solutions are "coherent". In that, if we look at the
solution mod 9, which is <span class='latexinline'>
4</span>, and then consider it mod 3, we get <span class='latexinline'>
1</span>. So,
we can say that given a sequence of integers <span class='latexinline'>
0 &#X2264; &#X3B1;<sub><span style="font-style:italic">n</span></sub> &#X2264; <span style="font-style:italic">p</span><sup><span style="font-style:italic">n</span></sup> &#X2212; 1</span>,
<b><span class='latexinline'>
&#X3B1;<sub><span style="font-style:italic">n</span></sub></span> is p-adically coherent sequence</b> iff:
<ul>
<li>
 <span class='latexinline'>
 &#X3B1;<sub><span style="font-style:italic">n</span>+1</sub> = &#X3B1;<sub><span style="font-style:italic">n</span></sub> mod <span style="font-style:italic">p</span><sup><span style="font-style:italic">n</span></sup></span>.
</li>

</ul>

<h4><a id=x2-25-mod-3nion-sets-of- href='#x2-25-mod-3nion-sets-of-'> § </a> Viewpoint: Solution sets of <span class='latexinline'>
<span style="font-style:italic">X</span><sup>2</sup> = 25 mod 3<sup><span style="font-style:italic">n</span></sup></span></h4>
Since our solution sets are coherent, we can view the solutions as a tree,
with the expansions of <span class='latexinline'>
<span style="font-style:italic">X</span> = 5, <span style="font-style:italic">X</span> = &#X2212;5 mod 3</span> and then continuing onwards
from there. That is, the sequences are
<ul>
<li>
 <span class='latexinline'>
2 &#X2192; 5 &#X2192; 5 &#X2192; 5 &#X2192; &#X2026;</span>
</li>
<li>
 <span class='latexinline'>
1 &#X2192; 4 &#X2192; 22 &#X2192; 76 &#X2192; &#X2026;</span>
</li>

</ul>

<h4><a id=x2-equiv-2-mod-7n href='#x2-equiv-2-mod-7n'> § </a> Solving <span class='latexinline'>
<span style="font-style:italic">X</span><sup>2</sup> &#X2261; 2 mod 7<sup><span style="font-style:italic">n</span></sup></span></h4>
We now construct a solution to the equation <span class='latexinline'>
<span style="font-style:italic">X</span><sup>2</sup> = 1</span> in the 7-adic system,
thereby showing that <span class='latexinline'>
&#X211A;<sub><span style="font-style:italic">p</span></sub></span> is indeed strictly <i>larger</i> than <span class='latexinline'>
&#X211A;</span>,
since this equation does not have rational roots.
For <span class='latexinline'>
<span style="font-style:italic">n</span>=1</span>, we have the solutions as <span class='latexinline'>
<span style="font-style:italic">X</span> &#X2261; 3 mod 7</span>, <span class='latexinline'>
<span style="font-style:italic">X</span> &#X2261; 4 &#X2261; &#X2212;3 mod 7</span>.
To find solutions for <span class='latexinline'>
<span style="font-style:italic">n</span> = 2</span>, we recall that we need our solutions to be consistent
with those for <span class='latexinline'>
<span style="font-style:italic">n</span> = 1</span>. So, we solve for:
<ul>
<li>
 <span class='latexinline'>
(3 + 7<span style="font-style:italic">k</span>)<sup>2</sup> = 2 mod 49</span>, <span class='latexinline'>
(4 + 7<span style="font-style:italic">k</span>)<sup>2</sup> = 2 mod 49</span>.
</li>

</ul>

Solving the first of these:
<div class='latexblock'><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >(3&#XA0;+&#XA0;7<span style="font-style:italic">k</span>)<sup>2</sup></td><td style="text-align:left;white-space:nowrap" >&#X2261;&#XA0;2&#XA0;mod&#XA0;49&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >
9&#XA0;+&#XA0;42&#XA0;<span style="font-style:italic">k</span>&#XA0;+&#XA0;49<span style="font-style:italic">k</span><sup>2</sup></td><td style="text-align:left;white-space:nowrap" >&#X2261;&#XA0;2&#XA0;mod&#XA0;49&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >
9&#XA0;+&#XA0;42&#XA0;<span style="font-style:italic">k</span>&#XA0;+&#XA0;0<span style="font-style:italic">k</span><sup>2</sup></td><td style="text-align:left;white-space:nowrap" >&#X2261;&#XA0;2&#XA0;mod&#XA0;49&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >
7&#XA0;+&#XA0;42&#XA0;<span style="font-style:italic">k</span></td><td style="text-align:left;white-space:nowrap" >&#X2261;&#XA0;0&#XA0;mod&#XA0;49&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >
1&#XA0;+&#XA0;6&#XA0;<span style="font-style:italic">k</span></td><td style="text-align:left;white-space:nowrap" >&#X2261;&#XA0;0&#XA0;mod&#XA0;49&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >
<span style="font-style:italic">k</span></td><td style="text-align:left;white-space:nowrap" >&#X2261;&#XA0;1&#XA0;mod&#XA0;7
</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table>
</div>
This gives the solution <span class='latexinline'>
<span style="font-style:italic">X</span> &#X2261; 10 mod 49</span>. The other branch (<span class='latexinline'>
<span style="font-style:italic">X</span> = 4 + 7<span style="font-style:italic">k</span></span>)
gives us <span class='latexinline'>
<span style="font-style:italic">X</span> &#X2261; 39 &#X2261; &#X2212;10 mod 49</span>.
We can continue this process indefinitely (<i>exercise</i>), giving us the sequences:
<ul>
<li>
 <span class='latexinline'>
3 &#X2192; 10 &#X2192; 108 &#X2192; 2166 &#X2192; &#X2026;</span>
</li>
<li>
 <span class='latexinline'>
4 &#X2192; 39 &#X2192; 235 &#X2192; 235 &#X2192; &#X2026;</span>
</li>

</ul>

We can show that the sequences of solutions we get satisfy the equation
<span class='latexinline'>
<span style="font-style:italic">X</span><sup>2</sup> = 2 mod 7</span>. This is so by construction. Hence, <span class='latexinline'>
&#X211A;<sub>7</sub></span> contains
a solution that <span class='latexinline'>
&#X211A;</span> does not, and is therefore strictly bigger, since
we can already represent every rational in <span class='latexinline'>
&#X211A;</span> in <span class='latexinline'>
&#X211A;<sub>7</sub></span>.
<h4><a id=as-a-recurrenceng- href='#as-a-recurrenceng-'> § </a> Use case: Solving <span class='latexinline'>
<span style="font-style:italic">X</span> = 1 + 3<span style="font-style:italic">X</span></span> as a recurrence</h4>
Let's use the tools we have built so far to solve the equation <span class='latexinline'>
<span style="font-style:italic">X</span> = 1 + 3<span style="font-style:italic">X</span></span>.
Instead of solving it using algebra, we look at it as a recurrence <span class='latexinline'>
<span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span>+1</sub> = 1 + 3<span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub></span>.
This gives us the terms:
<ul>
<li>
 <span class='latexinline'>
<span style="font-style:italic">X</span><sub>0</sub> = 1</span>
</li>
<li>
 <span class='latexinline'>
<span style="font-style:italic">X</span><sub>1</sub> = 1 + 3</span>
</li>
<li>
 <span class='latexinline'>
<span style="font-style:italic">X</span><sub>2</sub> = 1 + 3 + 3<sup>2</sup></span>
</li>
<li>
 <span class='latexinline'>
<span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub> = 1 + 3 + &#X2026; + 3<sup><span style="font-style:italic">n</span></sup></span>
</li>

</ul>

In <span class='latexinline'>
&#X211D;</span>, this is a divergent sequence. However, we know that the
solution so <span class='latexinline'>
1 + <span style="font-style:italic">X</span> + <span style="font-style:italic">X</span><sup>2</sup> + &#X2026; = 1/(1&#X2212;<span style="font-style:italic">X</span>)</span>, at least as a generating function.
Plugging this in, we get that the answer should be:
<ul>
<li>
 <span class='latexinline'>
1/(1 &#X2212; 3) = &#X2212;1/2</span>
</li>

</ul>

which is indeed the correct answer.
Now this required some really shady stuff in <span class='latexinline'>
&#X211D;</span>. However, with a change
of viewpoint, we can explain what's going on. We can look at the above series
as being a series in <span class='latexinline'>
&#X211A;<sub>3</sub></span>.  Now, this series does <i>really</i> converge,
and by the same argument as above, it converges to <span class='latexinline'>
&#X2212;1/2</span>.
The nice thing about this is that a dubious computation becomes a legal one
by changing one's perspective on where the above series lives.
<h4><a id=viewpoint-evaluation-for-p-adics href='#viewpoint-evaluation-for-p-adics'> § </a> Viewpoint: 'Evaluation' for p-adics</h4>
The last thing that we need to import from the theory of polynomials
is the ability to <i>evaluate</i> them: Given a rational function <span class='latexinline'>
<span style="font-style:italic">F</span>(<span style="font-style:italic">X</span>) = <span style="font-style:italic">P</span>(<span style="font-style:italic">X</span>)/<span style="font-style:italic">Q</span>(<span style="font-style:italic">X</span>)</span>,
where <span class='latexinline'>
<span style="font-style:italic">P</span>(<span style="font-style:italic">X</span>), <span style="font-style:italic">Q</span>(<span style="font-style:italic">X</span>)</span> are polynomials, we can
evaluate it at some arbitrary point <span class='latexinline'>
<span style="font-style:italic">x</span><sub>0</sub></span>, as long as <span class='latexinline'>
<span style="font-style:italic">x</span><sub>0</sub></span> is not a zero
of the polynomial <span class='latexinline'>
<span style="font-style:italic">Q</span>(<span style="font-style:italic">X</span>)</span>.
We would like a similar function, such that for a fixed prime <span class='latexinline'>
<span style="font-style:italic">p</span></span>, we obtain
a ring homomorphism from <span class='latexinline'>
&#X211A; &#X2192; F<sub><span style="font-style:italic">p</span></sub><sup><span style="font-style:italic">x</span></sup></span>, which we will
denote as <span class='latexinline'>
<span style="font-style:italic">p</span>(<span style="font-style:italic">x</span><sub>0</sub>)</span>, where we are imagining that we are "evaluating" the prime
<span class='latexinline'>
<span style="font-style:italic">p</span></span> against the rational <span class='latexinline'>
<span style="font-style:italic">x</span><sub>0</sub></span>.
We define the value of <span class='latexinline'>
<span style="font-style:italic">x</span><sub>0</sub> = <span style="font-style:italic">a</span>/<span style="font-style:italic">b</span></span> at the prime <span class='latexinline'>
<span style="font-style:italic">p</span></span> to be equal to
<span class='latexinline'>
<span style="font-style:italic">ab</span><sup>&#X2212;1</sup> mod <span style="font-style:italic">p</span></span>, where <span class='latexinline'>
<span style="font-style:italic">b</span> <span style="font-style:italic">b</span><sup>&#X2212;1</sup> &#X2261; 1 mod <span style="font-style:italic">p</span></span>. That is, we compute the
usual <span class='latexinline'>
<span style="font-style:italic">ab</span><sup>&#X2212;1</sup></span> to evaluate <span class='latexinline'>
<span style="font-style:italic">a</span>/<span style="font-style:italic">b</span></span>, except we do this <span class='latexinline'>
(mod <span style="font-style:italic">p</span>)</span>, to stay with
the analogy.
Note that if <span class='latexinline'>
<span style="font-style:italic">b</span> &#X2261; 0 mod <span style="font-style:italic">p</span></span>, then we cannot evaluate
the rational <span class='latexinline'>
<span style="font-style:italic">a</span>/<span style="font-style:italic">b</span></span>, and we say that <span class='latexinline'>
<span style="font-style:italic">a</span>/<span style="font-style:italic">b</span></span> has a pole at <span class='latexinline'>
<span style="font-style:italic">p</span></span>. The order
of the pole is the number of times <span class='latexinline'>
<span style="font-style:italic">p</span></span> occurs in the prime factorization of <span class='latexinline'>
<span style="font-style:italic">b</span></span>.
I'm not sure how profitable this viewpoint is, so I
<a href=https://math.stackexchange.com/questions/3483369/profit-of-definition-evaluation-of-a-rational-at-a-p-adic>
asked on math.se</a>
,
and I'll update this post when I recieve a good answer.
<h4><a id=perspective-forcing-the-formal-sum-to-converge-by-imposing-a-new-norm href='#perspective-forcing-the-formal-sum-to-converge-by-imposing-a-new-norm'> § </a> Perspective: Forcing the formal sum to converge by imposing a new norm:</h4>
So far, we have dealt with infinite series in base <span class='latexinline'>
<span style="font-style:italic">p</span></span>, which have terms
<span class='latexinline'>
<span style="font-style:italic">p</span><sup><span style="font-style:italic">i</span></sup>, <span style="font-style:italic">i</span> &#X2265; 0</span>.
Clearly, these sums are divergent as per the usual topology on <span class='latexinline'>
&#X211A;</span>.
However, we would enjoy assigning analytic meaning to these series. Hence, we
wish to consider a new notion of the absolute value of a number, which makes it
such that <span class='latexinline'>
<span style="font-style:italic">p</span><sup><span style="font-style:italic">i</span></sup></span> with large <span class='latexinline'>
<span style="font-style:italic">i</span></span> are considered small.
We define the absolute value for a field <span class='latexinline'>
<span style="font-style:italic">K</span></span> as a function
<span class='latexinline'>
|&#XB7; |: <span style="font-style:italic">K</span> &#X2192; &#X211D;</span>. It obeys the axioms:
<ol>
<li>
 <span class='latexinline'>
| <span style="font-style:italic">x</span> | = 0 &#XA0;&#X21D0;&#X21D2;&#XA0;<span style="font-style:italic">x</span> = 0</span>
</li>
<li>
 <span class='latexinline'>
| <span style="font-style:italic">xy</span> | = | <span style="font-style:italic">x</span> | | <span style="font-style:italic">y</span> |</span> for all <span class='latexinline'>
<span style="font-style:italic">x</span>, <span style="font-style:italic">y</span> &#X2208; <span style="font-style:italic">K</span></span>
</li>
<li>
 <span class='latexinline'>
| <span style="font-style:italic">x</span> + <span style="font-style:italic">y</span> | &#X2264; | <span style="font-style:italic">x</span> | + | <span style="font-style:italic">y</span> |</span>, for all <span class='latexinline'>
<span style="font-style:italic">x</span>, <span style="font-style:italic">y</span> &#X2208; <span style="font-style:italic">K</span></span>.
</li>

</ol>

We want the triangle inequality so it's metric-like, and the norm to be
multiplicative so it measures the size of elements.
The usual absolute value <span class='latexinline'>
| <span style="font-style:italic">x</span> | &#X2261; <br>
 <span style="font-style:italic">x</span> : <span style="font-style:italic">x</span> &#X2265; 0; &#X2212;<span style="font-style:italic">x</span> : &#XA0; otherwise <br>
</span> satisfies
these axioms.
Now, we create a new absolute value that measures primeness. We first introduce
a gadget known as a valuation, which measures the <span class='latexinline'>
<span style="font-style:italic">p</span></span>-ness of a number. We use
this to create a norm that makes number smaller as their <span class='latexinline'>
<span style="font-style:italic">p</span></span>-ness increases.
This will allow infinite series in <span class='latexinline'>
<span style="font-style:italic">p</span><sup><span style="font-style:italic">i</span></sup></span> to converge.
<h4><a id=p-adic-valuation-definition href='#p-adic-valuation-definition'> § </a> p-adic valuation: Definition</h4>
First, we introduce
a valuation <span class='latexinline'>
<span style="font-style:italic">v</span><sub><span style="font-style:italic">p</span></sub>: &#X2124; &#X2212; <br>
0<br>
 &#X2192; &#X211D;</span>, where <span class='latexinline'>
<span style="font-style:italic">v</span><sub><span style="font-style:italic">p</span></sub>(<span style="font-style:italic">n</span>)</span> is
the power of the prime <span class='latexinline'>
<span style="font-style:italic">p</span><sup><span style="font-style:italic">i</span></sup></span> in the prime factorization of <span class='latexinline'>
<span style="font-style:italic">n</span></span>. More formally,
<span class='latexinline'>
<span style="font-style:italic">v</span><sub><span style="font-style:italic">p</span></sub>(<span style="font-style:italic">n</span>)</span> is the unique number such that:
<ul>
<li>
 <span class='latexinline'>
<span style="font-style:italic">n</span> = <span style="font-style:italic">p</span><sup><span style="font-style:italic">v</span><sub><span style="font-style:italic">p</span></sub>(<span style="font-style:italic">n</span>)</sup> <span style="font-style:italic">m</span></span>, where <span class='latexinline'>
<span style="font-style:italic">p</span>  <span style="font-style:italic">m</span></span>.
</li>
<li>
 We extend the valuation to the rationals by defining <span class='latexinline'>
<span style="font-style:italic">v</span><sub><span style="font-style:italic">p</span></sub>(<span style="font-style:italic">a</span>/<span style="font-style:italic">b</span>) = <span style="font-style:italic">v</span><sub><span style="font-style:italic">p</span></sub>(<span style="font-style:italic">a</span>) &#X2212; <span style="font-style:italic">v</span><sub><span style="font-style:italic">p</span></sub>(<span style="font-style:italic">b</span>)</span>.
</li>
<li>
 We set <span class='latexinline'>
<span style="font-style:italic">v</span><sub><span style="font-style:italic">p</span></sub>(0) = +&#X221E;</span>. The intuition is that <span class='latexinline'>
0</span> can be divided by <span class='latexinline'>
<span style="font-style:italic">p</span></span>
  an infinite number of times.
</li>

</ul>

The valuation gets larger as we have larger powers of <span class='latexinline'>
<span style="font-style:italic">p</span></span> in the prime
factorization of a number. However, we want the norm to get <i>smaller</i>. Also,
we need the norm to be multiplicative, while <span class='latexinline'>
<span style="font-style:italic">v</span><sub><span style="font-style:italic">p</span></sub>(<span style="font-style:italic">nm</span>) = <span style="font-style:italic">v</span><sub><span style="font-style:italic">p</span></sub>(<span style="font-style:italic">n</span>) + <span style="font-style:italic">v</span><sub><span style="font-style:italic">p</span></sub>(<span style="font-style:italic">m</span>)</span>, which
is additive.
To fix both of these, we create a norm by exponentiating <span class='latexinline'>
<span style="font-style:italic">v</span><sub><span style="font-style:italic">p</span></sub></span>.
This converts the additive property into a multiplicative property. We
exponentiate with a negative sign so that higher values of <span class='latexinline'>
<span style="font-style:italic">v</span><sub><span style="font-style:italic">p</span></sub></span> lead to
smaller values of the norm.
<h4><a id=p-adic-abosolute-value-definition href='#p-adic-abosolute-value-definition'> § </a> p-adic abosolute value: Definition</h4>
Now, we define the <b>p-adic absolute value</b> of a number <span class='latexinline'>
<span style="font-style:italic">n</span></span> as
<span class='latexinline'>
|<span style="font-style:italic">n</span>|<sub><span style="font-style:italic">p</span></sub> &#X2261; <span style="font-style:italic">p</span><sup>&#X2212;<span style="font-style:italic">v</span><sub><span style="font-style:italic">p</span></sub>(<span style="font-style:italic">n</span>)</sup></span>.
<ul>
<li>
 the norm of <span class='latexinline'>
0</span> is <span class='latexinline'>
<span style="font-style:italic">p</span><sup>&#X2212;<span style="font-style:italic">v</span><sub><span style="font-style:italic">p</span></sub>(0)</sup> = <span style="font-style:italic">p</span><sup>&#X2212;&#X221E;</sup> = 0</span>.
</li>
<li>
 If <span class='latexinline'>
<span style="font-style:italic">p</span><sup>&#X2212;<span style="font-style:italic">v</span><sub><span style="font-style:italic">p</span></sub>(<span style="font-style:italic">n</span>)</sup> = 0</span>, then <span class='latexinline'>
&#X2212;<span style="font-style:italic">v</span><sub><span style="font-style:italic">p</span></sub>(<span style="font-style:italic">n</span>) = log<sub><span style="font-style:italic">p</span></sub> 0 = &#X2212;&#X221E;</span>, and hence <span class='latexinline'>
<span style="font-style:italic">n</span> = 0</span>.
</li>
<li>
 The norm is multiplicative since <span class='latexinline'>
<span style="font-style:italic">v</span><sub><span style="font-style:italic">p</span></sub></span> is additive.
</li>
<li>
 Since <span class='latexinline'>
<span style="font-style:italic">v</span><sub><span style="font-style:italic">p</span></sub>(<span style="font-style:italic">x</span> + <span style="font-style:italic">y</span>) &#X2265; min(<span style="font-style:italic">v</span><sub><span style="font-style:italic">p</span></sub>(<span style="font-style:italic">x</span>), <span style="font-style:italic">v</span><sub><span style="font-style:italic">p</span></sub>(<span style="font-style:italic">y</span>)), |<span style="font-style:italic">x</span> + <span style="font-style:italic">y</span>|<sub><span style="font-style:italic">p</span></sub> &#X2264; <span style="font-style:italic">max</span>(|<span style="font-style:italic">x</span>|<sub><span style="font-style:italic">p</span></sub>, |<span style="font-style:italic">y</span>|<sub><span style="font-style:italic">p</span></sub>) &#X2264; |<span style="font-style:italic">x</span>|<sub><span style="font-style:italic">p</span></sub> + |<span style="font-style:italic">y</span>|<sub><span style="font-style:italic">p</span></sub></span>.
  Hence, the triangle inequality is also satisfied.
</li>

</ul>

So <span class='latexinline'>
|<span style="font-style:italic">n</span>|<sub><span style="font-style:italic">p</span></sub></span> is indeed a norm, which measures <span class='latexinline'>
<span style="font-style:italic">p</span></span>-ness, and is smaller as <span class='latexinline'>
<span style="font-style:italic">i</span></span>
gets larger in the power <span class='latexinline'>
<span style="font-style:italic">p</span><sup><span style="font-style:italic">i</span></sup></span> of the factorization of <span class='latexinline'>
<span style="font-style:italic">n</span></span>, causing our
infinite series to converge.
There is a question of why we chose a base <span class='latexinline'>
<span style="font-style:italic">p</span></span> for <span class='latexinline'>
|<span style="font-style:italic">n</span>|<sub><span style="font-style:italic">p</span></sub> = <span style="font-style:italic">p</span><sup><span style="font-style:italic">v</span><sub><span style="font-style:italic">p</span></sub>(<span style="font-style:italic">n</span>)</sup></span>. It would
appear that any choice of <span class='latexinline'>
|<span style="font-style:italic">n</span>|<sub><span style="font-style:italic">p</span></sub> = <span style="font-style:italic">c</span><sup><span style="font-style:italic">v</span><sub><span style="font-style:italic">p</span></sub>(<span style="font-style:italic">n</span>)</sup>, <span style="font-style:italic">c</span> &gt; 1</span> would be legal.
<a href=https://math.stackexchange.com/questions/3482489/why-does-the-p-adic-norm-use-base-p>
I asked this on <code>math.se</code></a>
,
and the answer is that this choosing a base <span class='latexinline'>
<span style="font-style:italic">p</span></span> gives us the nice formula
<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">&#X2200;&#XA0;<span style="font-style:italic">x</span>&#XA0;&#X2208;&#XA0;&#X2124;,&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">&#X220F;</span></td></tr>
<tr><td class="dcell" style="text-align:center">{<span style="font-style:italic">p</span>&#XA0;:&#XA0;<span style="font-style:italic">p</span>&#XA0;is prime}&#XA0;&#X22C3;&#XA0;{&#XA0;&#X221E;&#XA0;}</td></tr>
</table></td><td class="dcell">&#XA0;|<span style="font-style:italic">x</span>|<sub><span style="font-style:italic">p</span></sub>&#XA0;=&#XA0;1
</td></tr>
</table></div>
That is, the product of all <span class='latexinline'>
<span style="font-style:italic">p</span></span> norms and the usual norm
(denoted by <span class='latexinline'>
| <span style="font-style:italic">x</span> |<sub>&#X221E;</sub></span> )
give us the number 1. The reason is that the <span class='latexinline'>
 | <span style="font-style:italic">x</span>|<sub><span style="font-style:italic">p</span></sub> </span> give us
multiples <span class='latexinline'>
<span style="font-style:italic">p</span><sup>&#X2212;<span style="font-style:italic">v</span><sub><span style="font-style:italic">p</span></sub>(<span style="font-style:italic">x</span>)</sup></span>,
while the usual norm <span class='latexinline'>
| <span style="font-style:italic">x</span> |<sub>&#X221E;</sub></span> contains a multiple
<span class='latexinline'>
<span style="font-style:italic">p</span><sup><span style="font-style:italic">v</span><sub><span style="font-style:italic">p</span></sub>(<span style="font-style:italic">x</span>)</sup></span>, thereby cancelling each other out.
<h4><a id=conclusion href='#conclusion'> § </a> Conclusion</h4>
What we've done in this whirlwind tour is to try and draw analogies between
the ring of polynomials <span class='latexinline'>
&#X2102;[<span style="font-style:italic">X</span>]</span> and the ring <span class='latexinline'>
&#X2124;</span>, by trying
to draw analogies between their prime ideals: <span class='latexinline'>
(<span style="font-style:italic">X</span> &#X2212; &#X3B1;)</span> and <span class='latexinline'>
(<span style="font-style:italic">p</span>)</span>. So,
we imported the notions of generating functions, polynomial evaluation, and
completions (of <span class='latexinline'>
&#X211A;</span>) to gain a picture of what <span class='latexinline'>
&#X211A;<sub><span style="font-style:italic">p</span></sub></span> is like.
We also tried out the theory we've built against some toy problems, that shows
us that this point of view maybe profitable. If you found this interesting,
I highly recommend the book
<a href=https://www.springer.com/gp/book/9783540629115>
p-adic numbers by Fernando Gouvea</a>
.
<h3><a id=line-of-investigation-to-build-physical-intuition-for-semidirect-products href='#line-of-investigation-to-build-physical-intuition-for-semidirect-products'> § </a> <a href=#line-of-investigation-to-build-physical-intuition-for-semidirect-products>
Line of investigation to build physical intuition for semidirect products</a>
</h3>
To quote wikipedia:
<blockquote> In crystallography, the space group of a crystal splits as the semidirect product of the point group and the translation group if and only if the space group is symmorphic</blockquote>
The if and only if is interesting: The geometry ofthe crystal lattice truly
appears to capture the structure of the semidirect product. It's a discrete
object as well, which makes it way easier to visualize. I'm going to hunt down
the definitions involved so I can finally feel like I truly understand semidirect
products from the "action" perspective.
<h3><a id=topology-is-really-about-computation--part-2 href='#topology-is-really-about-computation--part-2'> § </a> <a href=#topology-is-really-about-computation--part-2>
Topology is really about computation --- part 2</a>
</h3>
Here, we're going to describe whatever I've picked up of sheaves in the past
couple of weeks. I'm trying to understand the relationship between sheaves,
topoi, geometry, and logic. I currently see how topoi allows us to model logic,
and how sheaves allow us to model geometry, but I see nothing about the
relationship! I'm hoping that writing this down will allow me to gain some
perspective on this.
<h3><a id=what-is-a-sheaf href='#what-is-a-sheaf'> § </a> What is a sheaf?</h3>
Let's consider two sets <span class='latexinline'>
<span style="font-style:italic">P</span>, <span style="font-style:italic">A</span></span>, <span class='latexinline'>
<span style="font-style:italic">P</span> &#X2286; <span style="font-style:italic">A</span></span>. Now, given a function
<span class='latexinline'>
<span style="font-style:italic">f</span>: <span style="font-style:italic">A</span> &#X2192; <span style="font-style:italic">X</span></span>, we can restrict this function to <span class='latexinline'>
 <span style="font-style:italic">A</span><sub><span style="font-style:italic">P</span></sub>: <span style="font-style:italic">P</span> &#X2192; <span style="font-style:italic">X</span> </span>.
So, we get to <i>invert the direction</i>:
<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(<span style="font-style:italic">P</span>&#XA0;&#X2286;&#XA0;<span style="font-style:italic">A</span>)&#XA0;&#XA0;&#X21D0;&#X21D2;&#XA0;(<span style="font-style:italic">f</span>:&#XA0;<span style="font-style:italic">A</span>&#XA0;&#X2192;&#XA0;<span style="font-style:italic">X</span>)&#XA0;&#X2192;&#XA0;(<span style="font-style:italic">f</span><sub><span style="font-style:italic">P</span></sub>:&#XA0;<span style="font-style:italic">P</span>&#XA0;&#X2192;&#XA0;<span style="font-style:italic">X</span>)
</td></tr>
</table></div>
We should now try to discover some sort of structure to this "reversal"
business. Perhaps we will discover a contravariant functor! (Spoiler: we will).
<h3><a id=topology-is-really-about-computation--part-1 href='#topology-is-really-about-computation--part-1'> § </a> <a href=#topology-is-really-about-computation--part-1>
Topology is really about computation --- part 1</a>
</h3>
Most people believe that topology is about some notion of "nearness" or
"closeness", which has been abstracted out from our usual notion of
continuity that we have from a metric space. Here, I make the claim that
topology is really about <i>computation</i>, and more specifically, <i>decidability</i>.
These are not new ideas. I learnt of this from a monograph 
<a href=https://pdf.sciencedirectassets.com/272990/1-s2.0-S1571066104X00177/1-s2.0-S1571066104051357/main.pdf>
The topology of computation</a>
,
but this does not seem very well known, so I decided to write about it.
The idea is this: We have turing machines which can compute things. We then
also have a set <span class='latexinline'>
<span style="font-style:italic">S</span></span>. Now, a topology <span class='latexinline'>
&#X3C4; &#X2282; 2<sup><span style="font-style:italic">S</span></sup></span> precisely encodes
which of the subsets of <span class='latexinline'>
<span style="font-style:italic">S</span></span> can be separated from the rest of the space by a turing machine.
Thus, a discrete space is a very nice space, where every point can be separated
from every other point. An indescrete space is one where no point can be separated.
Something like the reals is somewhere in between, where we can separate
stuff inside an open interval from stuff clearly outside, but there's some
funny behaviour that goes on at the boundary due to things like <code>(0.999... = 1)</code>,
which we'll see in detail in a moment.
<h4><a id=semidecidability href='#semidecidability'> § </a> Semidecidability</h4>
A subset <span class='latexinline'>
<span style="font-style:italic">Q</span>&#X2286; <span style="font-style:italic">S</span></span> is <i>semidecidable</i>, if there exists a turing machine
<span class='latexinline'>
Q: <span style="font-style:italic">Q</span> &#X2192; { &#X22A5;, &#X22A4; }</span>, such that:
<div class='latexblock'><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >Q(<span style="font-style:italic">q</span>)&#XA0;=&#XA0;&#X22A4;&#XA0;&#XA0;&#X21D0;&#X21D2;&#XA0;<span style="font-style:italic">q</span>&#XA0;&#X2208;&#XA0;<span style="font-style:italic">Q</span>&#XA0;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >
Q(<span style="font-style:italic">q</span>)&#XA0;=&#XA0;&#X22A5;&#XA0;&#XA0;&#X21D0;&#X21D2;&#XA0;<span style="font-style:italic">q</span>&#XA0;&#X2209;&#XA0;<span style="font-style:italic">Q</span>&#XA0;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table>
</div>
Where <span class='latexinline'>
&#X22A4;</span> signifies stopping at a state and returning <code>TRUE</code>, and
<span class='latexinline'>
&#X22A5;</span> signifies <i>never halting at all</i>!. So, the subset <span class='latexinline'>
<span style="font-style:italic">Q</span></span> is
<i>semidedicable</i>, in that, we will halt and say <code>TRUE</code> if the element
belongs in the set. But if an element does not belong in the set, we are
supposed to never terminate.
<h4><a id=1-2dive-semidecidability-of-the-interval- href='#1-2dive-semidecidability-of-the-interval-'> § </a> Deep dive: semidecidability of the interval <span class='latexinline'>
(1, 2)</span></h4>
Let's start with an example. We consider the interval <span class='latexinline'>
<span style="font-style:italic">I</span> = (1, 2)</span>, as a
subset of <span class='latexinline'>
&#X211D;</span>.Let the turing machine recieve the real number
as a function <span class='latexinline'>
<span style="font-style:italic">f</span>: &#X2115; &#X2192; {0, 1, &#X2026; 9}</span>, such that
given a real number <span class='latexinline'>
(<span style="font-style:italic">a</span><sub>0</sub> &#XB7; <span style="font-style:italic">a</span><sub>1</sub> &#XB7; <span style="font-style:italic">a</span><sub>2</sub> &#X2026;)</span>, this is encoded as a
function <span class='latexinline'>
<span style="font-style:italic">f</span><sub><span style="font-style:italic">a</span></sub>(<span style="font-style:italic">i</span>) = <span style="font-style:italic">a</span><sub><span style="font-style:italic">i</span></sub></span>.
We now build a turing machine <span class='latexinline'>
&#XCE;</span> which when given the input the function <span class='latexinline'>
<span style="font-style:italic">f</span><sub><span style="font-style:italic">a</span></sub></span>,
semi-decides whether <span class='latexinline'>
<span style="font-style:italic">a</span> &#X2208; <span style="font-style:italic">I</span></span>.
Let's consider the numbers in <span class='latexinline'>
<span style="font-style:italic">I</span></span>:
<div class='latexblock'>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">0&#XA0;&#X2192;&#XA0;<span style="font-family:monospace">NO</span>&#XA0;0.</td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >9</td></tr>
</table></td><td class="dcell">&#XA0;&#X2192;&#XA0;<span style="font-family:monospace">NO</span>&#XA0;1&#XA0;&#X2192;&#XA0;<span style="font-family:monospace">NO</span>&#XA0;1.<span style="font-style:italic">a</span><sub>1</sub>&#XA0;<span style="font-style:italic">a</span><sub>2</sub>&#XA0;&#X2026;&#XA0;&#X2192;&#XA0;<span style="font-family:monospace">YES</span>&#XA0;1.</td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >9</td></tr>
</table></td><td class="dcell">&#XA0;&#X2192;&#XA0;<span style="font-family:monospace">NO</span>&#XA0;2.0&#XA0;&#X2192;&#XA0;<span style="font-family:monospace">NO</span>&#XA0;2.<span style="font-style:italic">a</span><sub>1</sub>&#XA0;<span style="font-style:italic">a</span><sub>2</sub>&#XA0;&#X2192;&#XA0;<span style="font-family:monospace">NO</span>
</td></tr>
</table></div>
So, we can write a turing machine (ie, some code) that tries to decide whether
a real number <span class='latexinline'>
<span style="font-style:italic">a</span></span>'s encoding <span class='latexinline'>
<span style="font-style:italic">f</span><sub><span style="font-style:italic">a</span></sub></span> belongs to the interval <span class='latexinline'>
<span style="font-style:italic">I</span> = (1, 2)</span>
as follows:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> <b><u><font color="#000000">def</font></u></b> decide_number_in_open_1_2(f):
<font color="#000000">03:</font>   <i><font color="#222222"># if the number is (1.abcd)</font></i>
<font color="#000000">04:</font>   <b><u><font color="#000000">if</font></u></b> f(<font color="#000000">0</font>) == <font color="#000000">1</font>:
<font color="#000000">05:</font>     <i><font color="#222222"># (1.99...99x) | look for the x.</font></i>
<font color="#000000">06:</font>     <i><font color="#222222"># If the number is 1.999..., do not terminate.</font></i>
<font color="#000000">07:</font>     <i><font color="#222222"># if the number is any other number of the form 1.99..x, terminate</font></i>
<font color="#000000">08:</font>     i = <font color="#000000">1</font>
<font color="#000000">09:</font>     <b><u><font color="#000000">while</font></u></b> f(i) != <font color="#000000">9</font>: i += <font color="#000000">1</font>
<font color="#000000">10:</font>     <b><u><font color="#000000">return</font></u></b>
<font color="#000000">11:</font>   <i><font color="#222222"># if the number is not 1.abcd, do not terminate</font></i>
<font color="#000000">12:</font>   <b><u><font color="#000000">while</font></u></b> True: <b><u><font color="#000000">pass</font></u></b>
<font color="#000000">13:</font> </tt></pre>
</div>

Hence, we say that the interval <span class='latexinline'>
<span style="font-style:italic">I</span> = (1, 2)</span> is <i>semi-decidable</i>, since we
have a function
<span class='latexinline'>
&#XCE; &#X2261; <span style="font-family:monospace">decide-number-in-open-1-2</span></span>
such that
<span class='latexinline'>
&#XCE; (<span style="font-style:italic">f</span><sub><span style="font-style:italic">a</span></sub>)  terminates  &#XA0;&#X21D0;&#X21D2;&#XA0;<span style="font-style:italic">a</span> &#X2208; <span style="font-style:italic">I</span></span>.
We don't make <i>any claim</i> about
what happens if <span class='latexinline'>
<span style="font-style:italic">a</span> &#X2209; <span style="font-style:italic">I</span></span>. This is the essence of semidecidability: We
can precisely state when elements in the set belong to the set, but not
when they don't.
<h4><a id=semi-decidability-in-general href='#semi-decidability-in-general'> § </a> Semi decidability in general</h4>
To put this on more solid ground, we define a topology on a set <span class='latexinline'>
<span style="font-style:italic">S</span></span> by considering
programs which recieve as input elements of <span class='latexinline'>
<span style="font-style:italic">S</span></span>, suitably encoded. For example,
the way in which we encoded real numbers as functions from the index to the
digit. Similarly, we encode other mathematical objects in some suitable way.
Now, we define:
<ul>
<li>
 For every program <span class='latexinline'>
<span style="font-style:italic">P</span></span> which takes as inputs elements in <span class='latexinline'>
<span style="font-style:italic">S</span></span>, the set
  <span class='latexinline'>
<span style="font-style:italic">halts</span>(<span style="font-style:italic">P</span>) &#X2261; <br>
 <span style="font-style:italic">s</span> &#X2208; <span style="font-style:italic">S</span> | <span style="font-style:italic">P</span>(<span style="font-style:italic">s</span>) halts <br>
</span> is called as a
  <i>semidecidable set</i>.
</li>

</ul>

<ul>
<li>
 Alternatively, we can say for a subset <span class='latexinline'>
<span style="font-style:italic">T</span> &#X2282; <span style="font-style:italic">S</span></span>, if there
  exists a program <span class='latexinline'>
T</span>, such that
  <span class='latexinline'>
<span style="font-style:italic">s</span> &#X2208; <span style="font-style:italic">T</span> &#XA0;&#X21D0;&#X21D2;&#XA0;T(<span style="font-style:italic">s</span>)  halts</span>, then <span class='latexinline'>
<span style="font-style:italic">T</span></span> is semi-dedecidable.
</li>

</ul>

These are just two viewpoints on the same object. In one, we define the
set based on the program. In the other, we define the program based on the
set.
<h4><a id=semi-decidability-of-the-empty-set-and-the-universe-set href='#semi-decidability-of-the-empty-set-and-the-universe-set'> § </a> Semi decidability of the empty set and the universe set.</h4>
The empty set is semi-decidable, due to the existence of the program:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> <b><u><font color="#000000">def</font></u></b> semidecide_empty(x):
<font color="#000000">3:</font>   <b><u><font color="#000000">while</font></u></b> True: <b><u><font color="#000000">continue</font></u></b>
<font color="#000000">4:</font> </tt></pre>
</div>

The universe set is semi-decidable, due to the existence of the program:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> <b><u><font color="#000000">def</font></u></b> semidecide_univ(x): <b><u><font color="#000000">return</font></u></b>
<font color="#000000">3:</font> </tt></pre>
</div>

<h4><a id=semi-decidability-of-the-union-of-sets href='#semi-decidability-of-the-union-of-sets'> § </a> Semi decidability of the union of sets</h4>
infinite unions of sets are semi decidable, since we can "diagonalize" on
the steps of all programs. That way, if any program halts, we will reach
the state where it halts in our diagonalized enumeration.
Let <code>A00, A01... A0n</code> be the initial states of the machines. We are trying to
semidecide whether any of them halt. We lay out the steps of the machines
in an imaginary grid:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> A00 A01 A02 ... A0n
<font color="#000000">3:</font> A10 A11 A12 ... A1n
<font color="#000000">4:</font> A20 A21 A22 ... A2n
<font color="#000000">5:</font> Am0 Am1 Am2 ... Amn
<font color="#000000">6:</font> </tt></pre>
</div>

For example, machine <code>A0</code> has states:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> A00 -&gt; A10 -&gt; .. -&gt; Am0
<font color="#000000">3:</font> </tt></pre>
</div>

We can walk through the combined state-space of the machines as:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> A00
<font color="#000000">3:</font> A01 A10
<font color="#000000">4:</font> A02 A11 A20
<font color="#000000">5:</font> A03 A12 A21 A30
<font color="#000000">6:</font> ...
<font color="#000000">7:</font> </tt></pre>
</div>

Where on the <code>k</code>'th line, we collect all states <span class='latexinline'>
<span style="font-style:italic">A</span><sub><span style="font-style:italic">ij</span></sub></span> such that <span class='latexinline'>
(<span style="font-style:italic">i</span> + <span style="font-style:italic">j</span> = <span style="font-style:italic">k</span>)</span>.
Now, if any of the machines have a state that is <code>HALT</code>, we will reach the
state as we enumerate the diagonals, and the machine that explores the
combined state space can also return <code>HALT</code>.
<h4><a id=semi-decidability-of-the-intersection-of-sets href='#semi-decidability-of-the-intersection-of-sets'> § </a> Semi decidability of the intersection of sets</h4>
infinite intersections of sets are <i>not</i> semi decidable, since by running
these programs in parallel, we cannot know if an infinite number of programs
halt in finite time. We <i>can</i> tell if <i>one</i> of them halts, but of if <i>all</i>
of them halt.
For example, consider the sequence of machines produced by <code>machine_creator</code>:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> <i><font color="#222222">## creates a machine that stops after n steps</font></i>
<font color="#000000">03:</font> <b><u><font color="#000000">def</font></u></b> machine_creator(n):
<font color="#000000">04:</font>     <i><font color="#222222"># f terminates after n steps</font></i>
<font color="#000000">05:</font>     <b><u><font color="#000000">def</font></u></b> f(x):
<font color="#000000">06:</font>       <b><u><font color="#000000">for</font></u></b> _ <b><u><font color="#000000">in</font></u></b> range(n):
<font color="#000000">07:</font>         <b><u><font color="#000000">continue</font></u></b>
<font color="#000000">08:</font>     <b><u><font color="#000000">return</font></u></b>
<font color="#000000">09:</font> 
<font color="#000000">10:</font>     <b><u><font color="#000000">return</font></u></b> f
<font color="#000000">11:</font> </tt></pre>
</div>

We wish to check if the intersection of all <code>machine_creator(n)</code> halt, for all
<span class='latexinline'>
<span style="font-style:italic">n</span> &#X2265; 0, <span style="font-style:italic">n</span> &#X2208; &#X2115;</span>. Clearly, the answer is an infinite number of steps,
even though every single machine created by <code>machine_creator</code> halts in a
finite number of steps.
<h3><a id=pslq-algorithm-finding-integer-relations-between-reals href='#pslq-algorithm-finding-integer-relations-between-reals'> § </a> <a href=#pslq-algorithm-finding-integer-relations-between-reals>
PSLQ algorithm: finding integer relations between reals</a>
</h3>
An algorithm to find <i>integer</i> relations between <i>real</i> numbers. It was
apparently named "algorithms of the century" by Computing in science and
engineering.
<ul>
<li>
 <a href=http://mathworld.wolfram.com/PSLQAlgorithm.html>
Wolfram link</a>

</li>

</ul>

<h3><a id=geometric-characterization-of-normal-subgroups href='#geometric-characterization-of-normal-subgroups'> § </a> <a href=#geometric-characterization-of-normal-subgroups>
Geometric characterization of normal subgroups</a>
</h3>
<blockquote> <span class='latexinline'>
<span style="font-style:italic">Stab</span>(<span style="font-style:italic">Orb</span>(<span style="font-style:italic">x</span>)) = <span style="font-style:italic">Stab</span>(<span style="font-style:italic">x</span>) &#XA0;&#X21D0;&#X21D2;&#XA0;<span style="font-style:italic">Stab</span>(<span style="font-style:italic">x</span>)  is normal</span></blockquote>
<blockquote> <span class='latexinline'>
&#X2200; <span style="font-style:italic">x</span>&#X2032; &#X2208; <span style="font-style:italic">Orb</span>(<span style="font-style:italic">x</span>), <span style="font-style:italic">Stab</span>(<span style="font-style:italic">x</span>&#X2032;) = <span style="font-style:italic">Stab</span>(<span style="font-style:italic">x</span>) &#XA0;&#X21D0;&#X21D2;&#XA0;<span style="font-style:italic">Stab</span>(<span style="font-style:italic">x</span>)  is normal</span></blockquote>
<h4><a id=forward-if-the-stabilizer-is-normal-then-all-elements-in-the-orbit-have-the-same-stabilizer href='#forward-if-the-stabilizer-is-normal-then-all-elements-in-the-orbit-have-the-same-stabilizer'> § </a> Forward: if the stabilizer is normal, then all elements in the orbit have the same stabilizer</h4>
Let a group <span class='latexinline'>
<span style="font-style:italic">G</span></span> act on a set <span class='latexinline'>
<span style="font-style:italic">X</span></span> with action <span class='latexinline'>
(&#XA0;&#XA0;) : <span style="font-style:italic">G</span> &#XD7; <span style="font-style:italic">X</span> &#X2192; <span style="font-style:italic">X</span></span>.
Let <span class='latexinline'>
<span style="font-style:italic">H</span> &#X2286; <span style="font-style:italic">G</span></span> be the stabilizer of a point <span class='latexinline'>
<span style="font-style:italic">x</span> &#X2208; <span style="font-style:italic">X</span></span>. Now, let
<span class='latexinline'>
<span style="font-style:italic">K</span> = <span style="font-style:italic">kHk</span><sup>&#X2212;1</sup></span>, a conjugacy class of <span class='latexinline'>
<span style="font-style:italic">H</span></span>. Clearly, the element <span class='latexinline'>
(<span style="font-style:italic">k</span> &#XB7; <span style="font-style:italic">x</span>)</span>
in the orbit of <span class='latexinline'>
<span style="font-style:italic">x</span></span> is stabilized by <span class='latexinline'>
<span style="font-style:italic">K</span></span>.
If the group <span class='latexinline'>
<span style="font-style:italic">H</span></span> is normal, then <span class='latexinline'>
<span style="font-style:italic">K</span> = <span style="font-style:italic">H</span></span>. So every element in the orbit of <span class='latexinline'>
<span style="font-style:italic">x</span></span>
is stabilized by <span class='latexinline'>
<span style="font-style:italic">H</span></span>.
<h4><a id=interaction-of-stablizer-and-the-orbit href='#interaction-of-stablizer-and-the-orbit'> § </a> Interaction of stablizer and the orbit:</h4>
<blockquote> <span class='latexinline'>
<span style="font-style:italic">Stab</span>(<span style="font-style:italic">g</span> &#XB7; <span style="font-style:italic">x</span>) = <span style="font-style:italic">g</span> <span style="font-style:italic">Stab</span>(<span style="font-style:italic">x</span>) <span style="font-style:italic">g</span><sup>&#X2212;1</sup></span></blockquote>
<blockquote> <span class='latexinline'>
<span style="font-style:italic">g</span><sup>&#X2212;1</sup> <span style="font-style:italic">Stab</span>(<span style="font-style:italic">g</span> &#XB7; <span style="font-style:italic">x</span>) <span style="font-style:italic">g</span> = <span style="font-style:italic">Stab</span>(<span style="font-style:italic">x</span>)</span></blockquote>
<ul>
<li>
  Proof of <span class='latexinline'>
<span style="font-style:italic">s</span> &#X2208; <span style="font-style:italic">Stab</span>(<span style="font-style:italic">x</span>)  <span style="font-style:italic">gsg</span><sup>&#X2212;1</sup> &#X2208; <span style="font-style:italic">Stab</span>(<span style="font-style:italic">g</span> &#XB7; <span style="font-style:italic">x</span>)</span>:
   The action of <span class='latexinline'>
<span style="font-style:italic">gsg</span><sup>&#X2212;1</sup></span> on <span class='latexinline'>
<span style="font-style:italic">g</span> &#XB7; <span style="font-style:italic">x</span></span> is:
   <span class='latexinline'>
(<span style="font-style:italic">g</span> &#XB7; <span style="font-style:italic">x</span> &#X2192;<sub><span style="font-style:italic">g</span><sup>&#X2212;</sup>1</sub> <span style="font-style:italic">x</span> &#X2192;<sub><span style="font-style:italic">s</span></sub> <span style="font-style:italic">x</span> &#X2192;<sub><span style="font-style:italic">g</span></sub> <span style="font-style:italic">g</span> &#XB7; <span style="font-style:italic">x</span>)</span>.
</li>

</ul>

<ul>
<li>
 Proof of <span class='latexinline'>
<span style="font-style:italic">s</span>&#X2032; &#X2208; <span style="font-style:italic">Stab</span>(<span style="font-style:italic">g</span> &#XB7; <span style="font-style:italic">x</span>)  <span style="font-style:italic">g</span><sup>&#X2212;1</sup><span style="font-style:italic">s</span>&#X2032;<span style="font-style:italic">g</span> &#X2208; <span style="font-style:italic">Stab</span>(<span style="font-style:italic">x</span>)</span>:
  The action of <span class='latexinline'>
<span style="font-style:italic">g</span><sup>&#X2212;1</sup><span style="font-style:italic">s</span>&#X2032;<span style="font-style:italic">g</span></span> on <span class='latexinline'>
<span style="font-style:italic">x</span></span> is:
  <span class='latexinline'>
(<span style="font-style:italic">x</span> &#X2192;<sub><span style="font-style:italic">g</span></sub> <span style="font-style:italic">g</span> &#XB7; <span style="font-style:italic">x</span> &#X2192;<sub><span style="font-style:italic">s</span>&#X2032;</sub> <span style="font-style:italic">g</span> &#XB7; <span style="font-style:italic">x</span> &#X2192;<sub><span style="font-style:italic">g</span><sup>&#X2212;1</sup></sub> <span style="font-style:italic">x</span>)</span>.
</li>

</ul>

Hence, both containments are proved.
<h4><a id=backward-if-all-elements-in-the-orbit-have-the-same-orbit-then-the-stabilizer-is-normal href='#backward-if-all-elements-in-the-orbit-have-the-same-orbit-then-the-stabilizer-is-normal'> § </a> Backward: if all elements in the orbit have the same orbit, then the stabilizer is normal.</h4>
From the above equation <span class='latexinline'>
<span style="font-style:italic">Stab</span>(<span style="font-style:italic">g</span> &#XB7; <span style="font-style:italic">x</span>) = <span style="font-style:italic">g</span> <span style="font-style:italic">Stab</span>(<span style="font-style:italic">x</span>) <span style="font-style:italic">g</span><sup>&#X2212;1</sup></span>. If the
entire orbit has the same stabilizer, <span class='latexinline'>
<span style="font-style:italic">Stab</span> (<span style="font-style:italic">g</span> &#XB7; <span style="font-style:italic">x</span>) = <span style="font-style:italic">Stab</span>(<span style="font-style:italic">x</span>)</span>. Hence,
we get <span class='latexinline'>
<span style="font-style:italic">Stab</span>(<span style="font-style:italic">x</span>) = <span style="font-style:italic">g</span> <span style="font-style:italic">Stab</span>(<span style="font-style:italic">x</span>) <span style="font-style:italic">g</span><sup>&#X2212;1</sup></span>, proving that it's normal.
<h3><a id=handy-characterization-of-adding-an-element-into-an-ideal-proof-that-maximal-ideal-is-prime href='#handy-characterization-of-adding-an-element-into-an-ideal-proof-that-maximal-ideal-is-prime'> § </a> <a href=#handy-characterization-of-adding-an-element-into-an-ideal-proof-that-maximal-ideal-is-prime>
Handy characterization of adding an element into an ideal, proof that maximal ideal is prime</a>
</h3>
<h4><a id=the-characterization href='#the-characterization'> § </a> The characterization</h4>
Let <span class='latexinline'>
<span style="font-style:italic">I</span></span> be an ideal. The ideal generated by adding <span class='latexinline'>
(<span style="font-style:italic">a</span> &#X2208; <span style="font-style:italic">R</span>)</span> to <span class='latexinline'>
<span style="font-style:italic">I</span></span> is
defined as <span class='latexinline'>
<span style="font-style:italic">A</span> &#X2261; (<span style="font-style:italic">I</span> &#X222A; { <span style="font-style:italic">a</span>})</span>. We prove that <span class='latexinline'>
<span style="font-style:italic">A</span> = <span style="font-style:italic">I</span> + <span style="font-style:italic">aR</span></span>.
<div class='latexblock'><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >(<span style="font-style:italic">I</span>&#XA0;&#X22C3;&#XA0;{<span style="font-style:italic">a</span>&#XA0;})&#XA0;&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >=&#XA0;&#XA0;&#XA0;&#XA0;{&#XA0;&#X3B1;&#XA0;<span style="font-style:italic">i</span>&#XA0;+&#XA0;&#X3B2;&#XA0;<span style="font-style:italic">a</span>&#XA0;|&#XA0;<span style="font-style:italic">i</span>&#XA0;&#X2208;&#XA0;<span style="font-style:italic">I</span>,&#XA0;&#X3B1;,&#XA0;&#X3B2;&#XA0;&#X2208;&#XA0;<span style="font-style:italic">R</span>&#XA0;}&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >=&#XA0;&#XA0;&#XA0;&#XA0;{&#XA0;<span style="font-style:italic">i</span>&#X2032;&#XA0;+&#XA0;&#X3B2;&#XA0;<span style="font-style:italic">a</span>&#XA0;|&#XA0;<span style="font-style:italic">i</span>&#X2032;&#XA0;&#X2208;&#XA0;<span style="font-style:italic">I</span>,&#XA0;&#X3B1;,&#XA0;&#X3B2;&#XA0;&#X2208;&#XA0;<span style="font-style:italic">R</span>&#XA0;}&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;(<span style="font-style:italic">I</span> is closed under multiplication by <span style="font-style:italic">R</span>)&#XA0;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >=&#XA0;<span style="font-style:italic">I</span>&#XA0;+&#XA0;<span style="font-style:italic">aR</span>
</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table>
</div>
<h4><a id=quotient-based-proof-that-maximal-ideal-is-prime href='#quotient-based-proof-that-maximal-ideal-is-prime'> § </a> Quotient based proof that maximal ideal is prime</h4>
An ideal <span class='latexinline'>
<span style="font-style:italic">P</span></span> is prime iff the quotient ring <span class='latexinline'>
<span style="font-style:italic">R</span>/<span style="font-style:italic">P</span></span> is an integral domain. An
ideal <span class='latexinline'>
<span style="font-style:italic">M</span></span> is maximal <span class='latexinline'>
<span style="font-style:italic">R</span>/<span style="font-style:italic">M</span></span> is a field. Every field is an integral domain,
hence:
<span class='latexinline'>
<span style="font-style:italic">M</span>  is maximal   <span style="font-style:italic">R</span>/<span style="font-style:italic">M</span>  is a field   <span style="font-style:italic">R</span>/<span style="font-style:italic">M</span> is an integral domain  <span style="font-style:italic">M</span>  is prime</span>.
I was dissatisfied with this proof, since it is not ideal theoretic: It argues
about the behaviour of the quotients. I then found this proof that argues
purly using ideals:
<h4><a id=ideal-theoretic-proof-that-maximal-ideal-is-prime href='#ideal-theoretic-proof-that-maximal-ideal-is-prime'> § </a> Ideal theoretic proof that maximal ideal is prime</h4>
<h4><a id=sketch href='#sketch'> § </a> Sketch</h4>
Let <span class='latexinline'>
<span style="font-style:italic">I</span></span> be a maximal ideal. Let <span class='latexinline'>
<span style="font-style:italic">a</span>, <span style="font-style:italic">b</span> &#X2208; <span style="font-style:italic">R</span></span> such that <span class='latexinline'>
<span style="font-style:italic">ab</span> &#X2208; <span style="font-style:italic">I</span></span>. We need
to prove that <span class='latexinline'>
<span style="font-style:italic">a</span> &#X2208; <span style="font-style:italic">I</span> &#X2228; <span style="font-style:italic">b</span> &#X2208; <span style="font-style:italic">I</span></span>. If <span class='latexinline'>
<span style="font-style:italic">a</span> &#X2208; <span style="font-style:italic">I</span></span>, the problem is done.
So, let <span class='latexinline'>
<span style="font-style:italic">a</span> &#X2209; <span style="font-style:italic">I</span></span>. Build ideal <span class='latexinline'>
<span style="font-style:italic">A</span> = (<span style="font-style:italic">I</span> &#X222A; <span style="font-style:italic">a</span>)</span>. <span class='latexinline'>
<span style="font-style:italic">I</span>  <span style="font-style:italic">A</span></span>. Since
<span class='latexinline'>
<span style="font-style:italic">I</span></span> is maximal, <span class='latexinline'>
<span style="font-style:italic">A</span> = <span style="font-style:italic">R</span></span>. Hence, there are solutions for
<span class='latexinline'>
1<sub><span style="font-style:italic">R</span></sub> &#X2208; <span style="font-style:italic">A</span>  1<sub><span style="font-style:italic">r</span></sub> &#X2208; <span style="font-style:italic">I</span> + <span style="font-style:italic">aR</span>  &#X2203; <span style="font-style:italic">i</span> &#X2208; <span style="font-style:italic">I</span>, <span style="font-style:italic">r</span> &#X2208; <span style="font-style:italic">R</span>, 1<sub><span style="font-style:italic">R</span></sub> = <span style="font-style:italic">i</span> + <span style="font-style:italic">ar</span></span>.
Now, <span class='latexinline'>
<span style="font-style:italic">b</span> = <span style="font-style:italic">b</span> &#XB7; 1<sub><span style="font-style:italic">R</span></sub> = <span style="font-style:italic">b</span>(<span style="font-style:italic">i</span> + <span style="font-style:italic">ar</span>) = <span style="font-style:italic">bi</span> + (<span style="font-style:italic">ba</span>)<span style="font-style:italic">r</span> &#X2208; <span style="font-style:italic">I</span> + <span style="font-style:italic">IR</span> = <span style="font-style:italic">I</span></span>. (<span class='latexinline'>
<span style="font-style:italic">ba</span> &#X2208; <span style="font-style:italic">I</span></span> by assumption).
Hence, <span class='latexinline'>
<span style="font-style:italic">b</span> &#X2208; <span style="font-style:italic">I</span></span>.
<h4><a id=details href='#details'> § </a> Details</h4>
let <span class='latexinline'>
<span style="font-style:italic">i</span></span> be a maximal ideal. let <span class='latexinline'>
<span style="font-style:italic">a</span>, <span style="font-style:italic">b</span> &#X2208; <span style="font-style:italic">r</span></span> such that <span class='latexinline'>
<span style="font-style:italic">ab</span> &#X2208; <span style="font-style:italic">i</span></span>. we need
to prove that <span class='latexinline'>
<span style="font-style:italic">a</span> &#X2208; <span style="font-style:italic">i</span> &#X2228; <span style="font-style:italic">b</span> &#X2208; <span style="font-style:italic">i</span></span>.
if <span class='latexinline'>
<span style="font-style:italic">a</span> &#X2208; <span style="font-style:italic">i</span></span>, then the problem is done. so, let <span class='latexinline'>
<span style="font-style:italic">a</span> &#X2209; <span style="font-style:italic">i</span></span>. consider
the ideal <span class='latexinline'>
<span style="font-style:italic">A</span></span> generated by adding <span class='latexinline'>
<span style="font-style:italic">a</span></span> into <span class='latexinline'>
<span style="font-style:italic">I</span></span>. <span class='latexinline'>
<span style="font-style:italic">A</span> &#X2261; (<span style="font-style:italic">I</span> &#X222A; {<span style="font-style:italic">a</span>})</span>.
We have shown that <span class='latexinline'>
<span style="font-style:italic">A</span> = <span style="font-style:italic">I</span> + <span style="font-style:italic">aR</span></span>. Hence, <span class='latexinline'>
<span style="font-style:italic">I</span> + <span style="font-style:italic">a</span>0 = <span style="font-style:italic">I</span> &#X2282; <span style="font-style:italic">A</span></span>.
Also, <span class='latexinline'>
0 + <span style="font-style:italic">ac</span> 1 = <span style="font-style:italic">a</span> &#X2208; <span style="font-style:italic">A</span></span>, <span class='latexinline'>
<span style="font-style:italic">a</span> &#X2260; <span style="font-style:italic">I</span></span> \implies <span class='latexinline'>
<span style="font-style:italic">A</span> &#X2260; <span style="font-style:italic">I</span></span>. Therefore,
<span class='latexinline'>
<span style="font-style:italic">I</span>  <span style="font-style:italic">A</span></span>. Since <span class='latexinline'>
<span style="font-style:italic">I</span></span> is maximal, this means that <span class='latexinline'>
<span style="font-style:italic">A</span> = <span style="font-style:italic">R</span></span>
Therefore, <span class='latexinline'>
<span style="font-style:italic">I</span> + <span style="font-style:italic">aR</span> = <span style="font-style:italic">R</span></span>. Hence, there exists some <span class='latexinline'>
<span style="font-style:italic">i</span> &#X2208; <span style="font-style:italic">I</span>, <span style="font-style:italic">r</span> &#X2208; <span style="font-style:italic">R</span></span> such
that <span class='latexinline'>
<span style="font-style:italic">i</span> + <span style="font-style:italic">ar</span> = 1<sub><span style="font-style:italic">R</span></sub></span>.
Now, <span class='latexinline'>
<span style="font-style:italic">b</span> = <span style="font-style:italic">b</span> &#XB7; 1<sub><span style="font-style:italic">R</span></sub> = <span style="font-style:italic">b</span> &#XB7; (<span style="font-style:italic">i</span> + <span style="font-style:italic">ar</span>) = <span style="font-style:italic">bi</span> + (<span style="font-style:italic">ba</span>) <span style="font-style:italic">r</span> &#X2208; <span style="font-style:italic">I</span> + <span style="font-style:italic">IR</span> = <span style="font-style:italic">I</span></span> Hence,
<span class='latexinline'>
<span style="font-style:italic">b</span> &#X2208; <span style="font-style:italic">I</span></span>.
<h3><a id=radical-ideals-nilpotents-and-reduced-rings href='#radical-ideals-nilpotents-and-reduced-rings'> § </a> <a href=#radical-ideals-nilpotents-and-reduced-rings>
Radical ideals, nilpotents, and reduced rings</a>
</h3>
<h4><a id=radical-ideals href='#radical-ideals'> § </a> Radical Ideals</h4>
A radical ideal of a ring <span class='latexinline'>
<span style="font-style:italic">R</span></span> is an ideal such that
<span class='latexinline'>
&#X2200; <span style="font-style:italic">r</span> &#X2208; <span style="font-style:italic">R</span>, <span style="font-style:italic">r</span><sup><span style="font-style:italic">n</span></sup> &#X2208; <span style="font-style:italic">I</span>  <span style="font-style:italic">r</span> &#X2208; <span style="font-style:italic">I</span></span>.
That is, if any power of <span class='latexinline'>
<span style="font-style:italic">r</span></span> is in <span class='latexinline'>
<span style="font-style:italic">I</span></span>, then the element
<span class='latexinline'>
<span style="font-style:italic">r</span></span> also gets "sucked into" <span class='latexinline'>
<span style="font-style:italic">I</span></span>.
<h4><a id=nilpotent-elements href='#nilpotent-elements'> § </a> Nilpotent elements</h4>
A nilpotent element of a ring <span class='latexinline'>
<span style="font-style:italic">R</span></span> is any element <span class='latexinline'>
<span style="font-style:italic">r</span></span> such that there exists
some power <span class='latexinline'>
<span style="font-style:italic">n</span></span> such that <span class='latexinline'>
<span style="font-style:italic">r</span><sup><span style="font-style:italic">n</span></sup> = 0</span>.
Note that every ideal of the ring contains <span class='latexinline'>
0</span>. Hence, if an ideal <span class='latexinline'>
<span style="font-style:italic">I</span></span>
of a ring is known to be a radical ideal, then for any nilpotent <span class='latexinline'>
<span style="font-style:italic">r</span></span>,
since <span class='latexinline'>
&#X2203; <span style="font-style:italic">n</span>, <span style="font-style:italic">r</span><sup><span style="font-style:italic">n</span></sup> = 0 &#X2208; <span style="font-style:italic">I</span></span>, since <span class='latexinline'>
<span style="font-style:italic">I</span></span> is radical, <span class='latexinline'>
<span style="font-style:italic">r</span> &#X2208; <span style="font-style:italic">I</span></span>.
That is, <i>a radical ideal with always contain all nilpotents!</i> It will
contain other elements as well, but it will contain nilpotents for sure.
<h4><a id=radicalization-of-an-ideal href='#radicalization-of-an-ideal'> § </a> Radicalization of an ideal</h4>
Given a ideal <span class='latexinline'>
<span style="font-style:italic">I</span></span>, it's radical idea <span class='latexinline'>
&#X221A;<span style="text-decoration:overline"><span style="font-style:italic">I</span></span> &#X2261; { <span style="font-style:italic">r</span> &#X2208; <span style="font-style:italic">R</span>, <span style="font-style:italic">r</span><sup><span style="font-style:italic">n</span></sup> &#X2208; <span style="font-style:italic">I</span> }</span>.
That is, we add all the elements <span class='latexinline'>
<span style="font-style:italic">I</span></span> needs to have for it to become a radical.
Notice that the radicalization of the zero ideal <span class='latexinline'>
<span style="font-style:italic">I</span></span> will precisely contain
all nilpotents. that is, <span class='latexinline'>
&#X221A;<span style="text-decoration:overline">(0)</span> &#X2261; { <span style="font-style:italic">r</span> &#X2208; <span style="font-style:italic">R</span>, <span style="font-style:italic">r</span><sup><span style="font-style:italic">n</span></sup> = 0}</span>.
<h4><a id=reduced-rings href='#reduced-rings'> § </a> Reduced rings</h4>
A ring <span class='latexinline'>
<span style="font-style:italic">R</span></span> is a reduced ring if the only nilpotent in the ring is <span class='latexinline'>
0</span>.
<h4><a id=creating-reduced-rings-removing-nilpotents-by-quotienting-radical-ideals href='#creating-reduced-rings-removing-nilpotents-by-quotienting-radical-ideals'> § </a> creating reduced rings (removing nilpotents) by quotienting radical ideals</h4>
Tto remove nilpotents of the ring <span class='latexinline'>
<span style="font-style:italic">R</span></span>, we can create <span class='latexinline'>
<span style="font-style:italic">R</span>&#X2032; &#X2261; <span style="font-style:italic">R</span> / &#X221A;<span style="text-decoration:overline">(0</span></span>. Since
<span class='latexinline'>
&#X221A;<span style="text-decoration:overline">(0)</span></span> is the ideal which contains all nilpotents, the quotient ring <span class='latexinline'>
<span style="font-style:italic">R</span>&#X2032;</span> will contain
no nilpotents other than <span class='latexinline'>
0</span>.
Similarly, quotienting by any larger radical ideal <span class='latexinline'>
<span style="font-style:italic">I</span></span> will remove all nilpotents
(and then some), leaving a reduced ring.
<blockquote> A ring modulo a radical ideal is reduced</blockquote>
<h4><a id=integral-domains href='#integral-domains'> § </a> Integral domains</h4>
a Ring <span class='latexinline'>
<span style="font-style:italic">R</span></span> is an integral domain if <span class='latexinline'>
<span style="font-style:italic">ab</span> = 0  <span style="font-style:italic">a</span> = 0 &#X2228; <span style="font-style:italic">b</span> = 0</span>. That is,
the ring <span class='latexinline'>
<span style="font-style:italic">R</span></span> has no zero divisors.
<h4><a id=prime-ideals href='#prime-ideals'> § </a> Prime ideals</h4>
An ideal <span class='latexinline'>
<span style="font-style:italic">I</span></span> of a ring <span class='latexinline'>
<span style="font-style:italic">R</span></span> is a prime ideal if
<span class='latexinline'>
&#X2200; <span style="font-style:italic">xy</span> &#X2208; <span style="font-style:italic">R</span>, <span style="font-style:italic">xy</span> &#X2208; <span style="font-style:italic">I</span>  <span style="font-style:italic">x</span> &#X2208; <span style="font-style:italic">I</span> &#X2228; <span style="font-style:italic">y</span> &#X2208; <span style="font-style:italic">I</span></span>. This generalizes
the notion of a prime number diving a composite: <span class='latexinline'>
<span style="font-style:italic">p</span> | <span style="font-style:italic">xy</span>  <span style="font-style:italic">p</span> | <span style="font-style:italic">x</span> &#X2228; <span style="font-style:italic">p</span> | <span style="font-style:italic">y</span></span>.
<h4><a id=creating-integral-domains-by-quotenting-prime-ideals href='#creating-integral-domains-by-quotenting-prime-ideals'> § </a> creating integral domains by quotenting prime ideals</h4>
Recall that every ideal contains a <span class='latexinline'>
0</span>. Now, if an ideal <span class='latexinline'>
<span style="font-style:italic">I</span></span> is prime, and if
<span class='latexinline'>
<span style="font-style:italic">ab</span> = 0 &#X2208; <span style="font-style:italic">I</span></span>, then either <span class='latexinline'>
<span style="font-style:italic">a</span> &#X2208; <span style="font-style:italic">I</span></span> or <span class='latexinline'>
<span style="font-style:italic">b</span> &#X2208; <span style="font-style:italic">I</span></span> (by the definition of prime).
We create <span class='latexinline'>
<span style="font-style:italic">R</span>&#X2032; = <span style="font-style:italic">R</span> / <span style="font-style:italic">I</span></span>. We denote <span class='latexinline'>
<span style="text-decoration:overline"><span style="font-style:italic">r</span></span> &#X2208; <span style="font-style:italic">R</span>&#X2032;</span> as the image of <span class='latexinline'>
<span style="font-style:italic">r</span> &#X2208; <span style="font-style:italic">R</span></span>
in the quotient ring <span class='latexinline'>
<span style="font-style:italic">R</span>&#X2032;</span>.
The intuition is that quotienting by a  <span class='latexinline'>
<span style="font-style:italic">I</span></span>, since if <span class='latexinline'>
<span style="font-style:italic">ab</span> = 0  <span style="font-style:italic">a</span> &#X2208; <span style="font-style:italic">I</span> &#X2228; <span style="font-style:italic">b</span> &#X2208; <span style="font-style:italic">I</span></span>,
we are "forcing" that in the quotient ring <span class='latexinline'>
<span style="font-style:italic">R</span>&#X2032;</span>, if <span class='latexinline'>
<span style="text-decoration:overline"><span style="font-style:italic">a</span></span> <span style="text-decoration:overline"><span style="font-style:italic">b</span></span> = 0</span>, then either
<span class='latexinline'>
<span style="text-decoration:overline"><span style="font-style:italic">a</span></span> = 0</span> or <span class='latexinline'>
<span style="text-decoration:overline"><span style="font-style:italic">b</span></span> = 0</span>, since <span class='latexinline'>
(<span style="font-style:italic">a</span> &#X2208; <span style="font-style:italic">I</span>  <span style="text-decoration:overline"><span style="font-style:italic">a</span></span> = 0)</span>,
and <span class='latexinline'>
<span style="font-style:italic">b</span> &#X2208; <span style="font-style:italic">I</span>  <span style="text-decoration:overline"><span style="font-style:italic">b</span></span> = 0)</span>.
<blockquote> A ring modulo a prime ideal is an integral domain.</blockquote>
I learnt of this explanation from this
<a href=http://quickmathintuitions.org/relationship-between-reduced-rings-radical-ideals-and-nilpotent-elements/>
excellent blog post by Stefano Ottolenghi</a>
.
<h3><a id=my-disenchantment-with-abstract-interpretation href='#my-disenchantment-with-abstract-interpretation'> § </a> <a href=#my-disenchantment-with-abstract-interpretation>
My disenchantment with abstract interpretation</a>
</h3>
When I first ran across the theory of abstract interpretation, it seemed magical:
Define two functions, check that they're monotone maps, and boom, we have
on our hands an analysis.
However, the problem appears to be that in reality, it's not as simple. Here is
the list of issues I've run across when trying to use abstract interpretation
for a "real world" use-case:
First of all, all interesting lattices are infinte height, requiring some
choice of widening.  Defining a good widening is a black art.  Secondly, while
there is a lot of theory on combining abstract domains (reduced products and
the like), it seems hard to deploy the theory in the real world.
I read a fair bit into the theory of abstract acceleration, where the idea is
that instead of widening indiscriminately, if our theory is powerful enough to
compute an exact closed form, we choose to do so. However, the problem is that
this regime does not "fit well" into abstract interpretation: We have the
abstract interpreter on the one hand, and then the acceleration regime on the
other, which is a separate algorithm. So the full analysis looks something
like:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> <b><u><font color="#000000">def</font></u></b> analyze(program):
<font color="#000000">3:</font>   analysis = {}
<font color="#000000">4:</font>   <b><u><font color="#000000">for</font></u></b> loop <b><u><font color="#000000">in</font></u></b> inner to outer:
<font color="#000000">5:</font>      loop_data = abstract_interpret(loop)
<font color="#000000">6:</font>      analaysis.append(accelerate(loop))
<font color="#000000">7:</font>   <b><u><font color="#000000">return</font></u></b> analysis
<font color="#000000">8:</font> </tt></pre>
</div>

That is, what used to be a nice theory of just "do things in any order and
it will converge", now becomes a new algorithm, that uses abstract interpretation
as a subroutine. This was not the hope I had! I wanted to <i>get away</i> from having
to do proofs by analyzing an algorithm, this was the entire promise: Define
a lattice well enough and the proof is guaranteed. Rather, what I had
imagined was:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> <b><u><font color="#000000">def</font></u></b> analyze(program):
<font color="#000000">3:</font>   <b><u><font color="#000000">return</font></u></b> abstract_interpret_using_acceleration_domain(program)
<font color="#000000">4:</font> </tt></pre>
</div>

Now this <code>acceleration_domain</code> maybe frightfully complicated, but I'm willing
to pay that price, as long as it's an honest-to-god abstract interpretation.
This was a huge bummer for me to find out that this is not the case.
<h3><a id=computing-equivalent-gate-sets-using-grobner-bases href='#computing-equivalent-gate-sets-using-grobner-bases'> § </a> <a href=#computing-equivalent-gate-sets-using-grobner-bases>
Computing equivalent gate sets using grobner bases</a>
</h3>
Here's a fun little problem, whose only solution I know involves a fair
bit of math and computer algebra:
We are given the grammar for a language <code>L</code>:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> E = T +_mod8 E | T -_mod8 E | T
<font color="#000000">3:</font> T = V | V ^ V | V ^ V ^ V
<font color="#000000">4:</font> V = 'a1' | 'a2' | ...
<font color="#000000">5:</font> </tt></pre>
</div>

where <code>+_mod8</code> is addition modulo 8, <code>-_mod8</code> is subtraction modulo 8,
and <code>^</code> is XOR.
This language is equipped with the obvious
evaluation rules, corresponding to those of arithmetic. We are guaranteed
that during evaluation, the variables <code>a_i</code> will only have values <code>0</code> and <code>1</code>.
Since we have addition, we can perform multiplication by a constant
by repeated addition. So we can perform <code>3*a</code> as <code>a+a+a</code>.
We are then given the input expression <code>(a0 ^ a1 ^ a2 ^ a3)</code>. We wish
to find an equivalent expression in terms of the above language <code>L</code>.
We think of <code>E</code> as some set of logic gates we are allowed to use, and we are
trying to express the operation <code>(a0 ^ a1 ^ a2 ^ a3)</code> in terms of these gates.
The first idea that I thought was that of employing a grobner basis,
since they essentially embody rewrite rules modulo polynomial equalities, which
is precisely our setting here.
In this blog post, I'm going to describe what a grobner basis is and why it's
natural to reach for them to solve this problem, the code, and the eventual
solution.
As a spolier, the solution is:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> a^b^c^d =
<font color="#000000">3:</font> -a - b + c + 3*d - 3*axorb - axorc
<font color="#000000">4:</font> + axord - bxorc + bxord + 3*cxord
<font color="#000000">5:</font> - 3*axorbxorc - axorbxord
<font color="#000000">6:</font> + axorcxord + bxorcxord
<font color="#000000">7:</font> </tt></pre>
</div>

Clearly, this contains only additions/subtractions and multiplications by
a constant.
If there's some principled way to derive this (beyond throwing symbolic
algebra machinery), I'd really love to know ---
<a href=https://github.com/bollu/bollu.github.io/issues>
Please raise an issue with the explanation!</a>

<h4><a id=what-the-hell-is-grobner-basis href='#what-the-hell-is-grobner-basis'> § </a> What the hell is Grobner Basis?</h4>
The nutshell is that a grobner basis is a way to construct rewrite rules which
also understand arithmetic (I learnt this viewpoint from the book "Term
rewriting and all that". Fantastic book in general). Expanding on the
nutshell, assume we have a term rewriting system:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> A -&gt; -1*B -- (1)
<font color="#000000">3:</font> C -&gt; B^2  -- (2)
<font color="#000000">4:</font> </tt></pre>
</div>

over an alphabet <code>{A, B, C}</code>.
Now, given the string <code>C + AB</code>, we wish to find out if it can be rewritten to
<code>0</code> or not. Let's try to substitute and see what happens:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> C + AB -2-&gt; B^2 + AB -1-&gt; B^2 + (-1*B)B
<font color="#000000">3:</font> </tt></pre>
</div>

At this point, we're stuck! we don't have rewrite rules to allow us to
rewrite <code>(-1*B)B</code> into <code>-B^2</code>. Indeed, creating such a list would be
infinitely long. But if we are willing to accept that we somehow have
the rewrite rules that correspond to polynomial arithmetic, where we view
<code>A, B, C</code> as variables, then we <i>can</i> rewrite the above string to 0:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> B^2 + (-1*B)B -&gt; B^2 - B^2 -&gt; 0
<font color="#000000">3:</font> </tt></pre>
</div>

A Grobner basis is the algorithmic / mathematical machine that allows us
to perform this kind of substitution.
In this example, this might appear stupid: what is so special? We simply
substituted variables and arrived at <code>0</code> by using arithmetic. What's
so complicated about that? To understand why this is not always so easy,
let's consider a pathological, specially constructed example
<h4><a id=a-complicated-example-that-shatters-dreams href='#a-complicated-example-that-shatters-dreams'> § </a> A complicated example that shatters dreams</h4>
Here's the pathological example:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> A -&gt; 1     -- (1)
<font color="#000000">3:</font> AB -&gt; -B^2 -- (2)
<font color="#000000">4:</font> </tt></pre>
</div>

And we consider the string <code>S = AB + B^2</code>.  If we blindly apply the
first rule, we arrive at:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> S = AB + B^2 -1-&gt; 1B + B^2 = B + B^2 (STUCK)
<font color="#000000">3:</font> </tt></pre>
</div>

However, if we apply <code>(2)</code> and then <code>(1)</code>:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> S = AB + B^2 -2-&gt; -B^2 + B^2 -&gt; 0
<font color="#000000">3:</font> </tt></pre>
</div>

This tells us that we <i>can't just apply the rewrite rules willy-nilly</i>.
It's sensitive to the <i>order</i> of the rewrites! That is, the rewrite system
is not <a href=https://en.wikipedia.org/wiki/Confluence_(abstract_rewriting>
confluent</a>
).
The grobner basis is a function from rewrite systems to rewrite systems.
When given a rewrite system <code>R</code>, it produces a <i>new</i> rewrite system <code>R'</code>
that <i>is confluent</i>. So, we can apply the rewrite rules of <code>R'</code> in any order,
and we guaranteed that we will only get a 0 from <code>R'</code> if and only if
we could have gotten a <code>0</code> from <code>R</code> for all strings.
We can then go on to phrase this whole rewriting setup in the language of
ideals from ring theory, and that is the language in which it is most
often described. I've gone into more depth on that perspective here: 
<a href=#what-the-hell-is-a-grobner-basis-ideals-as-rewrite-systems>
"What is a grobner basis? polynomial factorization as rewrite systems"</a>
.
Now that we have a handle on what a grobner basis is, let's go on to solve
the original problem:
<h4><a id=an-explanation-through-a-slightly-simpler-problem href='#an-explanation-through-a-slightly-simpler-problem'> § </a> An explanation through a slightly simpler problem</h4>
I'll first demonstrate the idea of how to solve the original problem
by solving a slightly simpler problem:
<blockquote> Rewrite <code>a^b^c</code> in terms of <code>a^b</code>, <code>b^c</code>, <code>c^a</code> and the same <code>+_mod8</code> instruction set as the original problem. The only difference this time is that we do <i>not</i> have <code>T -> V ^ V ^ V</code>.</blockquote>
The idea is to construct the polynomial ring over <code>Z/8Z</code> (integers modulo 8) with
variables as <code>a, b, c, axorb, bxorc, axorc</code>. Now, we know that <code>a^b = a + b - 2ab</code>. So,
we setup rewrite rules such that <code>a + b - 2ab -> axorb</code>, <code>b + c - 2bc -> bxorb</code>,
<code>c + a - 2ca -> cxora</code>.
We construct the <i>polynomial</i> <code>f(a, b, c) = a^b^c</code>, which
has been written in terms of addition and multiplication, defined
as <code>f_orig(a, b, c) = 4*a*b*c - 2*a*b - 2*a*c - 2*b*c + a + b + c</code>. We then
rewrite <code>f_orig</code> with respect to our rewrite rules. Hopefully, the rewrite
rules should give us a clean expression in terms of one variable and
two-variable <code>xor</code>s. There is the danger that we may have some term
such as <code>a * bxorc</code>, and we do get such a term (<code>2*b*axorc</code>) in this case,
but it does not appear in the <i>original</i> problem.
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> <i><font color="#222222">## Create ring with variables a, b, c, axorb, bxorc, axorc</font></i>
<font color="#000000">03:</font> R = IntegerModRing(<font color="#000000">8</font>)[<font color="#808080">'a, b, c, axorb, bxorc, axorc'</font>]
<font color="#000000">04:</font> (a, b, c, axorb, bxorc, axorc) = R.gens()
<font color="#000000">05:</font> 
<font color="#000000">06:</font> 
<font color="#000000">07:</font> <i><font color="#222222">## xor of 2 numbers as a polynomial</font></i>
<font color="#000000">08:</font> <b><u><font color="#000000">def</font></u></b> xor2(x, y): <b><u><font color="#000000">return</font></u></b> x + y - <font color="#000000">2</font>*x*y
<font color="#000000">09:</font> 
<font color="#000000">10:</font> <i><font color="#222222">## xor of 3 numbers as a polynomial</font></i>
<font color="#000000">11:</font> <b><u><font color="#000000">def</font></u></b> xor3(x, y, z): <b><u><font color="#000000">return</font></u></b> xor2(x, xor2(y, z))
<font color="#000000">12:</font> 
<font color="#000000">13:</font> <i><font color="#222222">## define the ideal which contains relations:</font></i>
<font color="#000000">14:</font> <i><font color="#222222">## xor2(a, b) -&gt; axorb, xor2(b, c) -&gt; bxorc, xor2(a, c) -&gt; axorc</font></i>
<font color="#000000">15:</font> <i><font color="#222222">## we also add the relation (a^2 - a = 0 =&gt; a = 0 or a = 1)</font></i>
<font color="#000000">16:</font> <i><font color="#222222">## since we know that our variables are only {0, 1}</font></i>
<font color="#000000">17:</font> I = ideal((axorb - xor2(a, b), bxorc - xor2(b, c), axorc - xor2(a, c), a*a-a, b*b-b, c*c-c))
<font color="#000000">18:</font> 
<font color="#000000">19:</font> <i><font color="#222222">## the polynomial representing a^b^c we wish to reduce</font></i>
<font color="#000000">20:</font> f_orig = xor3(a, b, c)
<font color="#000000">21:</font> 
<font color="#000000">22:</font> <i><font color="#222222">## we take the groebner basis of the ring to reduce the polynomial f.</font></i>
<font color="#000000">23:</font> IG = I.groebner_basis()
<font color="#000000">24:</font> 
<font color="#000000">25:</font> <i><font color="#222222">## we reduce a^b^c with respect to the groebner basis.</font></i>
<font color="#000000">26:</font> f_reduced = f_orig.reduce(IG)
<font color="#000000">27:</font> 
<font color="#000000">28:</font> <b><u><font color="#000000">print</font></u></b>(<font color="#808080">"value of a^b^c:\n\t%s\n\treduced: %s"</font> % (f_orig, f_reduced))
<font color="#000000">29:</font> 
<font color="#000000">30:</font> <i><font color="#222222">## Code to evaluate the function `f` on all inputs to check correctness</font></i>
<font color="#000000">31:</font> <b><u><font color="#000000">def</font></u></b> evalxor2(f):
<font color="#000000">32:</font>     <b><u><font color="#000000">for</font></u></b> (i, j, k) <b><u><font color="#000000">in</font></u></b> [(i, j, k) <b><u><font color="#000000">for</font></u></b> i <b><u><font color="#000000">in</font></u></b> [<font color="#000000">0</font>, <font color="#000000">1</font>] <b><u><font color="#000000">for</font></u></b> j <b><u><font color="#000000">in</font></u></b> [<font color="#000000">0</font>, <font color="#000000">1</font>] <b><u><font color="#000000">for</font></u></b> k <b><u><font color="#000000">in</font></u></b> [<font color="#000000">0</font>, <font color="#000000">1</font>]]:
<font color="#000000">33:</font>       ref = i^^j^^k
<font color="#000000">34:</font>       eval = f.substitute(a=i, b=j, c=k, axorb=i^^j, bxorc=j^^k, axorc=i^^k)
<font color="#000000">35:</font>       <b><u><font color="#000000">print</font></u></b>(<font color="#808080">"%s^%s^%s: ref(%s) =?= f(%s): %s"</font> %
<font color="#000000">36:</font>         (i, j, k, ref, eval, ref == eval))
<font color="#000000">37:</font> 
<font color="#000000">38:</font> <i><font color="#222222">## check original formulation is correct</font></i>
<font color="#000000">39:</font> <b><u><font color="#000000">print</font></u></b>(<font color="#808080">"evaulating original f for sanity check:"</font>)
<font color="#000000">40:</font> evalxor2(f_orig)
<font color="#000000">41:</font> 
<font color="#000000">42:</font> <i><font color="#222222">## Check reduced formulation is correct</font></i>
<font color="#000000">43:</font> <b><u><font color="#000000">print</font></u></b>(<font color="#808080">"evaulating reduced f:"</font>)
<font color="#000000">44:</font> evalxor2(f_reduced)
<font color="#000000">45:</font> </tt></pre>
</div>

Running the code gives us the reduced polynomial <code>-2*b*axorc + b + axorc</code>
which unfortunately contains a term that is <code>b * axorc</code>. So, this approach
does not work, and I was informed by my friend that she is unaware
of a solution to this problem (writing <code>a^b^c</code> in terms of smaller xors and
sums).
The full code output is:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> value of a^b^c:
<font color="#000000">03:</font>         4*a*b*c - 2*a*b - 2*a*c - 2*b*c + a + b + c
<font color="#000000">04:</font>         reduced: -2*b*axorc + b + axorc
<font color="#000000">05:</font> evaulating original f for sanity check:
<font color="#000000">06:</font> 0^0^0: ref(0) =?= f(0): True
<font color="#000000">07:</font> 0^0^1: ref(1) =?= f(1): True
<font color="#000000">08:</font> 0^1^0: ref(1) =?= f(1): True
<font color="#000000">09:</font> 0^1^1: ref(0) =?= f(0): True
<font color="#000000">10:</font> 1^0^0: ref(1) =?= f(1): True
<font color="#000000">11:</font> 1^0^1: ref(0) =?= f(0): True
<font color="#000000">12:</font> 1^1^0: ref(0) =?= f(0): True
<font color="#000000">13:</font> 1^1^1: ref(1) =?= f(1): True
<font color="#000000">14:</font> evaulating reduced f:
<font color="#000000">15:</font> 0^0^0: ref(0) =?= f(0): True
<font color="#000000">16:</font> 0^0^1: ref(1) =?= f(1): True
<font color="#000000">17:</font> 0^1^0: ref(1) =?= f(1): True
<font color="#000000">18:</font> 0^1^1: ref(0) =?= f(0): True
<font color="#000000">19:</font> 1^0^0: ref(1) =?= f(1): True
<font color="#000000">20:</font> 1^0^1: ref(0) =?= f(0): True
<font color="#000000">21:</font> 1^1^0: ref(0) =?= f(0): True
<font color="#000000">22:</font> 1^1^1: ref(1) =?= f(1): True
<font color="#000000">23:</font> </tt></pre>
</div>

That is, both the original polynomial and the reduced polynomial match
the expected results. But the reduced polynomial is not in our language <code>L</code>,
since it has a term that is a <i>product</i> of <code>b</code> with <code>axorc</code>.
<h4><a id=tacking-the-original-problem href='#tacking-the-original-problem'> § </a> Tacking the original problem.</h4>
We try the exact same approach to the original problem of expressing
<code>a ^ b ^ c ^ d</code>. We find that the reduced polynomial is
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> -a - b + c + 3*d - 3*axorb - axorc
<font color="#000000">3:</font> + axord - bxorc + bxord + 3*cxord
<font color="#000000">4:</font> - 3*axorbxorc - axorbxord
<font color="#000000">5:</font> + axorcxord + bxorcxord
<font color="#000000">6:</font> </tt></pre>
</div>

which happily has no products between terms! It also passes our sanity
check, so we've now found the answer.
The full output is:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> value of a^b^c^d:
<font color="#000000">03:</font>         4*a*b*c + 4*a*b*d + 4*a*c*d + 4*b*c*d
<font color="#000000">04:</font>       - 2*a*b - 2*a*c - 2*b*c - 2*a*d
<font color="#000000">05:</font>       - 2*b*d - 2*c*d + a + b + c + d
<font color="#000000">06:</font> reduced: -a - b + c + 3*d - 3*axorb
<font color="#000000">07:</font>       - axorc + axord - bxorc + bxord
<font color="#000000">08:</font>       + 3*cxord - 3*axorbxorc
<font color="#000000">09:</font>       - axorbxord + axorcxord + bxorcxord
<font color="#000000">10:</font> evaluating original a^b^c^d
<font color="#000000">11:</font> 0^0^0^0: ref(0) =?= f(0): True
<font color="#000000">12:</font> 0^0^0^1: ref(1) =?= f(1): True
<font color="#000000">13:</font> 0^0^1^0: ref(1) =?= f(1): True
<font color="#000000">14:</font> 0^0^1^1: ref(0) =?= f(0): True
<font color="#000000">15:</font> 0^1^0^0: ref(1) =?= f(1): True
<font color="#000000">16:</font> 0^1^0^1: ref(0) =?= f(0): True
<font color="#000000">17:</font> 0^1^1^0: ref(0) =?= f(0): True
<font color="#000000">18:</font> 0^1^1^1: ref(1) =?= f(1): True
<font color="#000000">19:</font> 1^0^0^0: ref(1) =?= f(1): True
<font color="#000000">20:</font> 1^0^0^1: ref(0) =?= f(0): True
<font color="#000000">21:</font> 1^0^1^0: ref(0) =?= f(0): True
<font color="#000000">22:</font> 1^0^1^1: ref(1) =?= f(1): True
<font color="#000000">23:</font> 1^1^0^0: ref(0) =?= f(0): True
<font color="#000000">24:</font> 1^1^0^1: ref(1) =?= f(1): True
<font color="#000000">25:</font> 1^1^1^0: ref(1) =?= f(1): True
<font color="#000000">26:</font> 1^1^1^1: ref(0) =?= f(0): True
<font color="#000000">27:</font> evaluating reduced a^b^c^d
<font color="#000000">28:</font> 0^0^0^0: ref(0) =?= f(0): True
<font color="#000000">29:</font> 0^0^0^1: ref(1) =?= f(1): True
<font color="#000000">30:</font> 0^0^1^0: ref(1) =?= f(1): True
<font color="#000000">31:</font> 0^0^1^1: ref(0) =?= f(0): True
<font color="#000000">32:</font> 0^1^0^0: ref(1) =?= f(1): True
<font color="#000000">33:</font> 0^1^0^1: ref(0) =?= f(0): True
<font color="#000000">34:</font> 0^1^1^0: ref(0) =?= f(0): True
<font color="#000000">35:</font> 0^1^1^1: ref(1) =?= f(1): True
<font color="#000000">36:</font> 1^0^0^0: ref(1) =?= f(1): True
<font color="#000000">37:</font> 1^0^0^1: ref(0) =?= f(0): True
<font color="#000000">38:</font> 1^0^1^0: ref(0) =?= f(0): True
<font color="#000000">39:</font> 1^0^1^1: ref(1) =?= f(1): True
<font color="#000000">40:</font> 1^1^0^0: ref(0) =?= f(0): True
<font color="#000000">41:</font> 1^1^0^1: ref(1) =?= f(1): True
<font color="#000000">42:</font> 1^1^1^0: ref(1) =?= f(1): True
<font color="#000000">43:</font> 1^1^1^1: ref(0) =?= f(0): True
<font color="#000000">44:</font> </tt></pre>
</div>

<h4><a id=reduction href='#reduction'> § </a> code for <code>a^b^c^d</code> reduction:</h4>
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> <b><u><font color="#000000">def</font></u></b> xor3(x, y, z): <b><u><font color="#000000">return</font></u></b> xor2(x, xor2(y, z))
<font color="#000000">03:</font> 
<font color="#000000">04:</font> R = IntegerModRing(<font color="#000000">8</font>)['a, b, c, d, axorb, axorc, axord, bxorc, \
<font color="#000000">05:</font>         bxord, cxord, axorbxorc, axorbxord, axorcxord, bxorcxord']
<font color="#000000">06:</font> 
<font color="#000000">07:</font> (a, b, c, d, axorb, axorc, axord, bxorc, bxord, cxord, axorbxorc, \
<font color="#000000">08:</font>         axorbxord, axorcxord, bxorcxord) = R.gens()
<font color="#000000">09:</font> I = ideal((axorb - xor2(a, b),
<font color="#000000">10:</font>            axorc - xor2(a, c),
<font color="#000000">11:</font>            axord - xor2(a, d),
<font color="#000000">12:</font>            bxorc - xor2(b, c),
<font color="#000000">13:</font>            bxord - xor2(b, d),
<font color="#000000">14:</font>            cxord - xor2(c, d),
<font color="#000000">15:</font>            axorbxorc - xor3(a, b, c),
<font color="#000000">16:</font>            axorbxord - xor3(a, b, d),
<font color="#000000">17:</font>            axorcxord - xor3(a, c, d),
<font color="#000000">18:</font>            bxorcxord - xor3(b, c, d),
<font color="#000000">19:</font>            a*a-a,
<font color="#000000">20:</font>            b*b-b,
<font color="#000000">21:</font>            c*c-c,
<font color="#000000">22:</font>            d*d-d
<font color="#000000">23:</font>            ))
<font color="#000000">24:</font> IG = I.groebner_basis()
<font color="#000000">25:</font> f_orig = (xor2(a, xor2(b, xor2(c, d))))
<font color="#000000">26:</font> f_reduced = f_orig.reduce(IG)
<font color="#000000">27:</font> <b><u><font color="#000000">print</font></u></b>(<font color="#808080">"value of a^b^c^d:\n\t%s\n\treduced: %s"</font> % (f_orig, f_reduced))
<font color="#000000">28:</font> 
<font color="#000000">29:</font> <b><u><font color="#000000">def</font></u></b> evalxor3(f):
<font color="#000000">30:</font>     <b><u><font color="#000000">for</font></u></b> (i, j, k, l) <b><u><font color="#000000">in</font></u></b> [(i, j, k, l) <b><u><font color="#000000">for</font></u></b> i <b><u><font color="#000000">in</font></u></b> [<font color="#000000">0</font>, <font color="#000000">1</font>] \
<font color="#000000">31:</font>                            <b><u><font color="#000000">for</font></u></b> j <b><u><font color="#000000">in</font></u></b> [<font color="#000000">0</font>, <font color="#000000">1</font>] \
<font color="#000000">32:</font>                            <b><u><font color="#000000">for</font></u></b> k <b><u><font color="#000000">in</font></u></b> [<font color="#000000">0</font>, <font color="#000000">1</font>] \
<font color="#000000">33:</font>                            <b><u><font color="#000000">for</font></u></b> l <b><u><font color="#000000">in</font></u></b> [<font color="#000000">0</font>, <font color="#000000">1</font>]]:
<font color="#000000">34:</font>       ref = i^^j^^k^^l
<font color="#000000">35:</font>       eval = f.substitute(a=i, b=j, c=k, d=l,
<font color="#000000">36:</font>                           axorb=i^^j, axorc=i^^k,
<font color="#000000">37:</font>                           axord=i^^l, bxorc=j^^k,
<font color="#000000">38:</font>                           bxord=j^^l, cxord=k^^l,
<font color="#000000">39:</font>                           axorbxorc=i^^j^^k, axorbxord=i^^j^^l,
<font color="#000000">40:</font>                           axorcxord=i^^k^^l, bxorcxord=j^^k^^l)
<font color="#000000">41:</font>       <b><u><font color="#000000">print</font></u></b>(<font color="#808080">"%s^%s^%s^%s: ref(%s) =?= f(%s): %s"</font> %
<font color="#000000">42:</font>         (i, j, k, l, ref, eval, ref == eval))
<font color="#000000">43:</font> 
<font color="#000000">44:</font> <b><u><font color="#000000">print</font></u></b>(<font color="#808080">"evaluating original a^b^c^d"</font>)
<font color="#000000">45:</font> evalxor3(f_orig)
<font color="#000000">46:</font> 
<font color="#000000">47:</font> 
<font color="#000000">48:</font> <b><u><font color="#000000">print</font></u></b>(<font color="#808080">"evaluating reduced a^b^c^d"</font>)
<font color="#000000">49:</font> evalxor3(f_reduced)
<font color="#000000">50:</font> </tt></pre>
</div>

<h4><a id=closing-thoughts href='#closing-thoughts'> § </a> Closing thoughts</h4>
This was a really fun exercise: Around a hundred lines of code illuminates
the use of machinery such as grobner basis for solving real-world problems!
I really enjoyed hacking this up and getting nerd sniped.
<h3><a id=the-janus-programming-language--time-reversible-computation href='#the-janus-programming-language--time-reversible-computation'> § </a> <a href=#the-janus-programming-language--time-reversible-computation>
The janus programming language --- Time reversible computation</a>
</h3>
<ul>
<li>
 <a href=https://en.wikipedia.org/wiki/Janus_(time-reversible_computing_programming_language>
Wiki link</a>

</li>
<li>
 <a href=http://tetsuo.jp/ref/janus.pdf>
Original letter to Landlauer</a>

</li>

</ul>

I found out it's called Janus, since Janus is the god of doorways in greek
mythology. Hence, he is also the god of duality and transitions --- he
<i>literally</i> looks both into the future and into the past.
<blockquote> He is usually depicted as having two faces, since he looks to the future and to the past.</blockquote>
An apt name for the language!
<h3><a id=-a-book-about-proofs-of-combinatorial-closed-forms href='#-a-book-about-proofs-of-combinatorial-closed-forms'> § </a> <a href=#a--b--a-book-about-proofs-of-combinatorial-closed-forms>
<code>A = B</code> --- A book about proofs of combinatorial closed forms</a>
</h3>
The book explains algorithms on solving closed forms for combinatorial
recurrences, by means of <a href=http://mathworld.wolfram.com/ZeilbergersAlgorithm.html>
Zeilberger's algorithm</a>
.
The book is written by Zeilberger himself, and supposedy also teaches one Maple.
I'd like to learn the algorithm, since it might be useful eventually for
Groebner basis / loop analysis shenanigans I like to play as part of
my work on compilers.
<ul>
<li>
 <a href=https://www.math.upenn.edu/~wilf/AeqB.pdf>
Download link here</a>

</li>

</ul>

<h3><a id=bitsets-of-a-given-length- href='#bitsets-of-a-given-length-'> § </a> <a href=#generating-k-bitsets-of-a-given-length-n>
Generating <code>k</code> bitsets of a given length <code>n</code></a>
:</h3>
The problem is to generate all bitvectors of length <code>n</code> that have <code>k</code> bits
set. For example, generate all bitvectors of length <code>5</code> that have <code>3</code> bits
set.
I know that an algorithm exists in Hacker's delight, but I've been too sick
to crack open a book, so I decided to discover the algorithm myself. The one
I came up with relies on looking at the numbers moving at a certain velocity,
and them colliding with each other. For example, let us try to generate all
<code>5C3</code> combinations of bits.
We start wih:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> #1           count of position
<font color="#000000">3:</font> a b c d e    positions
<font color="#000000">4:</font> 1 1 1 0 0    bitset
<font color="#000000">5:</font> &lt; - - - -    velocity
<font color="#000000">6:</font> </tt></pre>
</div>

Where the <code><</code> represents that the <code>1</code> at position <code>a</code> is moving leftwards.
Our arena is <i>circular</i>, so the leftmost <code>1</code> can wrap around to the right.
This leads to the next state
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> #2
<font color="#000000">3:</font> a b c d e
<font color="#000000">4:</font> 0 1 1 0 1
<font color="#000000">5:</font> - - - - &lt;
<font color="#000000">6:</font> </tt></pre>
</div>

We continue moving left peacefully.
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> #3
<font color="#000000">3:</font> a b c d e
<font color="#000000">4:</font> 0 1 1 1 0
<font color="#000000">5:</font> - - - &lt; -
<font color="#000000">6:</font> </tt></pre>
</div>

whoops, we have now collided with a block of <code>1</code>s. Not to worry, we simply
transfer our velocity by way of collision, from the <code>1</code> at <code>d</code> to the <code>1</code> at <code>b</code>.
I denote the transfer as follows:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> #3
<font color="#000000">3:</font> a b c d e
<font color="#000000">4:</font> 0 1 1 1 0  original state
<font color="#000000">5:</font> - - - &lt; -
<font color="#000000">6:</font> - &lt; &lt; &lt; -  transfer of velocity
<font color="#000000">7:</font> - &lt; - - -  final state after transfer of velocity
<font color="#000000">8:</font> </tt></pre>
</div>

The <code>1</code> at <code>b</code> proceeds along its merry way with the given velocity
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> #4
<font color="#000000">3:</font> a b c d e
<font color="#000000">4:</font> 1 0 1 1 0
<font color="#000000">5:</font> &lt; - - - -
<font color="#000000">6:</font> </tt></pre>
</div>

Once again, it wraps around, and suffers a collision
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> #5
<font color="#000000">3:</font> a b c d e
<font color="#000000">4:</font> 0 0 1 1 1
<font color="#000000">5:</font> - - - - - &lt; (collision, transfer)
<font color="#000000">6:</font> - - &lt; &lt; &lt; transfer of velocity
<font color="#000000">7:</font> - - &lt; - - final state after transfer of velocity
<font color="#000000">8:</font> </tt></pre>
</div>

This continues:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> 0 1 0 1 1  #6
<font color="#000000">03:</font> - &lt; - - -
<font color="#000000">04:</font> 1 0 0 1 1  #7
<font color="#000000">05:</font> &lt; - - - - (collision, transfer velocity)
<font color="#000000">06:</font> &lt; - - &lt; &lt;
<font color="#000000">07:</font> - - - &lt; -
<font color="#000000">08:</font> 1 0 1 0 1 #8
<font color="#000000">09:</font> - - &lt; - -
<font color="#000000">10:</font> 1 1 0 0 1 #9
<font color="#000000">11:</font> - &lt; - - - (colision, transfer velocity
<font color="#000000">12:</font> &lt; &lt; - - &lt;
<font color="#000000">13:</font> - - - - &lt;
<font color="#000000">14:</font> 1 1 0 1 0 #10
<font color="#000000">15:</font> - - - &lt; -
<font color="#000000">16:</font> 1 1 1 0 0 #11: wrap around to initial state
<font color="#000000">17:</font> </tt></pre>
</div>

I don't have a proof of correctness, but I have an intuition that this
should generate all states. Does anyone have a proof?
<i>EDIT:</i> <a href=https://math.stackexchange.com/questions/3398241/correctness-proof-for-algorithm-to-generate-k-bitsets-of-n-bits-nck>
this algorithm does not work</a>
,
since it will keep clusters of <span class='latexinline'>
<span style="font-style:italic">k</span>&#X2212;1</span> bits next to each other, when a
bit hits a cluster of <span class='latexinline'>
<span style="font-style:italic">k</span> &#X2212; 1</span> bits.  For completeness, I'm going to draft out
the usual algorithm in full:
<h4><a id=usual-algorithm href='#usual-algorithm'> § </a> Usual Algorithm</h4>
Let's consider the same example of <code>5C3</code>:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font>    a b c d e
<font color="#000000">3:</font> 1| 0 0 1 1 1 (LSB)
<font color="#000000">4:</font> </tt></pre>
</div>

We start with all bits at their lowest position. Now, we try to go to
the next smallest number, which still has 3 bits toggled. Clearly, we need
the bit at position <code>b</code> to be 1, since that's the next number. Then,
we can keep the lower 2 bits <code>d, e</code> set to 1, so that it's still as small a
number as possible.
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font>    a b c d e
<font color="#000000">3:</font> 2| 0 1 0 1 1 (LSB)
<font color="#000000">4:</font> </tt></pre>
</div>

Once again, we now move the digit at <code>d</code> to the digit at <code>c</code>, while keeping
the final digit at <code>e</code> to make sure it's still the smallest possible.
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font>    a b c d e
<font color="#000000">3:</font> 3| 0 1 1 0 1 (LSB)
<font color="#000000">4:</font> </tt></pre>
</div>

Now, we can move the <code>1</code> at <code>e</code> to <code>d</code>, since that will lead to the smallest
increase:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font>    a b c d e
<font color="#000000">3:</font> 4| 0 1 1 1 0 (LSB)
<font color="#000000">4:</font> </tt></pre>
</div>

At this point, we are forced to move to location <code>a</code>, since we have exhausted
all smaller locations. so we move the <code>1</code> at <code>b</code> to <code>a</code>, and then reset all
the other bits to be as close to the LSB as possible:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font>    a b c d e
<font color="#000000">3:</font> 5| 1 0 0 1 1 (LSB)
<font color="#000000">4:</font> </tt></pre>
</div>

Continuing this process gives us the rest of the sequence:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font>     a b c d e
<font color="#000000">3:</font> 5 | 1 0 0 1 1
<font color="#000000">4:</font> 6 | 1 0 1 0 1
<font color="#000000">5:</font> 7 | 1 0 1 1 0
<font color="#000000">6:</font> 8 | 1 1 0 0 1 (note the reset of d!)
<font color="#000000">7:</font> 9 | 1 1 0 1 0
<font color="#000000">8:</font> 10| 1 1 1 0 0
<font color="#000000">9:</font> </tt></pre>
</div>

<h3><a id=bondi-k-calculus href='#bondi-k-calculus'> § </a> <a href=#bondi-k-calculus>
Bondi k-calculus</a>
</h3>
<ul>
<li>
 <a href=https://en.wikipedia.org/wiki/Bondi_k-calculus>
Link here</a>

</li>

</ul>

An alternative formalism to derive special relativity geometrically,
resting purely on hypotehses about the way light travels.
However, I've not been able to prove the correctness of the assumptions made,
by using coordinate geometry. I suspect this is because I will need to use
hyperbolic geometry for the "side lengths" to work out.
Indeed, I found another source, called as <a href=http://bearsoft.co.uk/Kcalc.html>
The k-calculus fiddle</a>

which attempts to discredit k-calculus. The author of the above blog writes at
the end:
<blockquote> In asking Ray D'Inverno's permission to use his book as the example of k-calculus, he was kind enough to point out that the arguments I have given are invalid. Chapter 2 of his book should be read through to the end and then reread in the light of the fact that the geometry of space and time is Minkowskian. Euclidean geometry should not be used in interpreting the diagrams because their geometry is Minkowskian.</blockquote>
which seems to imply that we need to use hyperbolic geometry for this.
<h3><a id=topology-as-an-object-telling-us-what-zero-locus-is-closed href='#topology-as-an-object-telling-us-what-zero-locus-is-closed'> § </a> Topology as an object telling us what zero-locus is closed:</h3>
<ul>
<li>
 <a href=https://math.stackexchange.com/questions/53852/is-there-a-way-of-working-with-the-zariski-topology-in-terms-of-convergence-limi>
Idea from this amazing post on <code>math.se</code></a>

</li>

</ul>

<h3><a id=vivado-toolchain-craziness- href='#vivado-toolchain-craziness-'> § </a> <a href=#vivado-toolchain-craziness>
Vivado toolchain craziness </a>
</h3>
I found this file as I was cleaning up some old code, for a project to implement
a <a href=https://github.com/AakashKT/CuckooHashingHLS>
fast K/V store on an FPGA</a>
,
so I thought I should put this up for anyone else who stumbles on the
same frustrations / errors. I'm not touching this particular toolchain again
with a 10-foot pole till the tools stabilize by <i>a lot</i>.
<h4><a id=vivado-hls-issues href='#vivado-hls-issues'> § </a> Vivado HLS issues</h4>
<ul>
<li>
 Unable to create BRAM for fields such as <code>bool</code>, <code>int16</code>. The data buses
  will be <code>8/16</code> bits long, with error:
</li>

</ul>

<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> [BD 41-241] Message from IP propagation TCL of /blk_mem_gen_7: set_property
<font color="#000000">3:</font> error: Validation failed for parameter 'Write Width A(Write_Width_A)' for BD
<font color="#000000">4:</font> Cell 'blk_mem_gen_7'. Value '8' is out of the range (32,1024) Customization
<font color="#000000">5:</font> errors found on 'blk_mem_gen_7'. Restoring to previous valid configuration.
<font color="#000000">6:</font> </tt></pre>
</div>

<ul>
<li>
 I had an array of structs:
</li>

</ul>

<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> <b><u><font color="#000000">struct</font></u></b> S {
<font color="#000000">3:</font>     <b><font color="#000000">bool</font></b> b;
<font color="#000000">4:</font>     int16 x;
<font color="#000000">5:</font>     int16 y;
<font color="#000000">6:</font> }
<font color="#000000">7:</font> </tt></pre>
</div>

This gets generated as 3 ports for memory, of widths <code>1</code>, <code>16</code>, <code>16</code>. Ideally,
I wanted <i>one</i> port, of width <code>16+16+1=33</code>, for each struct value.
However, what was generated were three ports of widths <code>1</code>, <code>16</code>, and <code>16</code>
which I cannot connect to BRAM.
<ul>
<li>
 <code>data_pack</code> allows us to create one port of width <code>16+16+1=33</code>
</li>

</ul>

<ul>
<li>
 Shared function names allocated on BRAM causes errors in synthesis:
</li>

</ul>

<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> <b><u><font color="#000000">struct</font></u></b> Foo {...};
<font color="#000000">3:</font> <b><font color="#000000">void</font></b> f (Foo conflict) {
<font color="#000000">4:</font> <b><u><font color="#000000">    #pragma</font></u></b> HLS interface bram port=conflict
<font color="#000000">5:</font> }
<font color="#000000">6:</font> 
<font color="#000000">7:</font> <b><font color="#000000">void</font></b> g (Foo conflict) {
<font color="#000000">8:</font> <b><u><font color="#000000">    #pragma</font></u></b> HLS interface bram port=conflict
<font color="#000000">9:</font> }
<font color="#000000">10:</font> </tt></pre>
</div>

<ul>
<li>
 Enums causes compile failure in RTL generation  (commit <code>3c0d619039cff7a7abb61268e6c8bc6d250d8730</code>)
</li>
<li>
 <code>ap_int</code> causes compile failurre in RTL generation (commit <code>3c0d619039cff7a7abb61268e6c8bc6d250d8730</code>)
</li>
<li>
 <code>x % m</code> where <code>m != 2^k</code> is very expensive -- there must be faster encodings of modulus?
</li>
<li>
 How to share code between HLS and vivado SDK? I often wanted to share constant values between
  my HLS code and my Zynq code.
</li>
<li>
 Can't understand why array of structs that were packed does not get deserialized correctly. I had to manually
  pack a struct into a <code>uint32</code>. For whatever reason, having a <code>#pragma pack</code> did something to the representation of the struct
  as far as I can tell, and I couldn't treat the memory as just a raw <code>struct *</code> on the other side:
</li>

</ul>

<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> <i><font color="#222222">// HLS side</font></i>
<font color="#000000">03:</font> <b><u><font color="#000000">struct</font></u></b> Vec2  { <b><font color="#000000">int</font></b> x; <b><font color="#000000">int</font></b> y};
<font color="#000000">04:</font> <b><font color="#000000">void</font></b> f(Vec2 points[NUM_POINTS]) {
<font color="#000000">05:</font> <b><u><font color="#000000">        #pragma</font></u></b> HLS DATA_PACK variable=points
<font color="#000000">06:</font> <b><u><font color="#000000">    #pragma</font></u></b> HLS INTERFACE bram port=points
<font color="#000000">07:</font> 
<font color="#000000">08:</font>     points[<font color="#000000">0</font>] = {<font color="#000000">2</font>, <font color="#000000">3</font>};
<font color="#000000">09:</font> }
<font color="#000000">10:</font> 
<font color="#000000">11:</font> <i><font color="#222222">// Host side</font></i>
<font color="#000000">12:</font> Vec2 *points = (Vec2 *)(0xPOINTER_LOCATION_FROM_VIVADO);
<font color="#000000">13:</font> 
<font color="#000000">14:</font> <b><font color="#000000">int</font></b> main() {
<font color="#000000">15:</font>     <i><font color="#222222">// points[0] will *not* be {2, 3}!</font></i>
<font color="#000000">16:</font> }
<font color="#000000">17:</font> </tt></pre>
</div>

<ul>
<li>
 If I change my IP, there is no way to preserve the current connections in the
  GUI why just updating the "changed connections". I'm forced to remove the IP
  and add it again (no, the Refresh IP button does not work).
</li>
<li>
 On generating a new bitstream from Vivado, Vivado SDK tries to reload the config,
  fails at the reloading (thinks <code>xil_print.h</code> doesn't exist), and then fails to compile code.
  Options are to either restart Vivado SDK, or refresh <code>xil_print.h</code>.
</li>

</ul>

<ul>
<li>
 It is entirely unclear what to version control in a vivado project, unless one
  has an omniscient view of the <i>entire toolchain</i>. I resorted to <code>git add</code> ing
  everything, but this is a terrible strategy in so many ways.
</li>

</ul>

<h4><a id=sdaccel-bugs href='#sdaccel-bugs'> § </a> SDAccel bugs</h4>
<b><a href=https://www.xilinx.com/support/documentation/sw_manuals/xilinx2017_1/ug1028-sdsoc-intro-tutorial.pdf>
link to tutorial we were following</a>
</b>
<ul>
<li>
 The executable is named <code>.exe</code> while it's actually an ELF executable (The SDAccel tutorials say it is called as <code>.elf</code>)
</li>
<li>
 the board is supposed to automatically boot into linux, which it does not. One is expected to call <code>bootd</code> manually (for "boot default") so it boots ito linux. (The SDAccel tutorials say it automatically boots into it)
</li>
<li>
 At this point, the SD card is unreadable. It took a bunch of time to figure out that the SD card needs to be mounted by us, and has the mount name <code>/dev/mmcblk0p1</code>. (The SDAccel tutorials say that it should be automatically mounted)
</li>
<li>
 At this point, we are unable to run <code>hashing.elf</code>. It dies with a truly bizarre error: <code>hashing.elf: command not found</code>. This is almost un-googleable, due to the fact that the same problem occurs when people don't have the correct file name.
</li>
<li>
 I rewrote <code>ls</code> with <code>hashing.elf</code> to see what would happen, because I conjectured that the shell was able to run <code>coreutils</code>.
</li>
<li>
 This dies with a different error <code>ls: core not found</code>. I'd luckily seen this during my android days, and knew this was from busybox.
</li>
<li>
 This led me to google "busybox unable to execute executable", which led me to this <a href=https://stackoverflow.com/questions/1562071/how-can-i-find-which-elf-dependency-is-not-fulfilled>
StackOverflow link</a>
 that clued me into the fact that the ELF interpreter is missing.
</li>
<li>
 When I discovered this, I wound up trying to understand how to get the right ELF interpreter. <code>readelf -l <exe name></code> dumps out <code>[Requesting program interpreter: /lib/ld-linux-armhf.so.3]</code>. So, I bravely copied: <code>cp /lib/ld-linux.so.3 /lib/ld-linux-armhf.so.3</code>.
</li>
<li>
 Stuff is <i>still</i> broken, but I now get <i>useful</i> error messages:
</li>

</ul>

<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> zynq&gt; /hashing.elf
<font color="#000000">3:</font> /hashing.elf: error while loading shared libraries:
<font color="#000000">4:</font> libxilinxopencl.so: cannot open shared object file: No such file or directory
<font color="#000000">5:</font> </tt></pre>
</div>

At this point, clearly we have some linker issues (why does <code>xocc</code> not correctly statically link? What's up with it? Why does it expect it to be able to load a shared library? <b>WTF is happening</b>). do note that this is <i>not</i> the way the process
is supposed to go according to the tutorial!
<ul>
<li>
 Of course, there's no static library version of <code>libxilinxopencl.so</code>, so that's a dead end. I'm completely unsure if the tutorial even makes sense.
</li>
<li>
 This entire chain of debugging is full of luck.
</li>

</ul>

<ul>
<li>
 <a href=https://www.xilinx.com/html_docs/xilinx2018_2/sdsoc_doc/compiling-and-running-applications-on-arm-processor-hjy1504034381720.html>
Link talking about generating <code>BOOT</code> file</a>

</li>

</ul>

At some point, I gave up on the entire enterprise.
<h3><a id=a-grobner-basis-ideals-as-rewrite-systems href='#a-grobner-basis-ideals-as-rewrite-systems'> § </a> <a href=#what-the-hell-is-a-grobner-basis-ideals-as-rewrite-systems>
What the hell <i>is</i> a Grobner basis? Ideals as rewrite systems</a>
</h3>
<h4><a id=a-motivating-example href='#a-motivating-example'> § </a> A motivating example</h4>
The question a Grobner basis allows us to answer is this: can the polynomial
<span class='latexinline'>
<span style="font-style:italic">p</span>(<span style="font-style:italic">x</span>, <span style="font-style:italic">y</span>) = <span style="font-style:italic">xy</span><sup>2</sup> + <span style="font-style:italic">y</span></span> be factorized in terms of <span class='latexinline'>
<span style="font-style:italic">a</span>(<span style="font-style:italic">x</span>, <span style="font-style:italic">y</span>) = <span style="font-style:italic">xy</span> + 1, <span style="font-style:italic">b</span>(<span style="font-style:italic">x</span>, <span style="font-style:italic">y</span>) = <span style="font-style:italic">y</span><sup>2</sup> &#X2212; 1</span>,
such that <span class='latexinline'>
<span style="font-style:italic">p</span>(<span style="font-style:italic">x</span>, <span style="font-style:italic">y</span>) = <span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>, <span style="font-style:italic">y</span>) <span style="font-style:italic">a</span>(<span style="font-style:italic">x</span>, <span style="font-style:italic">y</span>) + <span style="font-style:italic">g</span>(<span style="font-style:italic">x</span>, <span style="font-style:italic">y</span>) <span style="font-style:italic">b</span>(<span style="font-style:italic">x</span>, <span style="font-style:italic">y</span>)</span> for some <i>arbitrary</i> polynomials
<span class='latexinline'>
<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>, <span style="font-style:italic">y</span>), <span style="font-style:italic">g</span>(<span style="font-style:italic">x</span>, <span style="font-style:italic">y</span>) &#X2208; <span style="font-style:italic">R</span>[<span style="font-style:italic">x</span>, <span style="font-style:italic">y</span>]</span>.
One might imagine, "well, I'll divide and see what happens!" Now, there are two
routes to go down:
<ul>
<li>
 <span class='latexinline'>
<span style="font-style:italic">xy</span><sup>2</sup> + <span style="font-style:italic">y</span> = <span style="font-style:italic">y</span>(<span style="font-style:italic">xy</span> + 1) = <span style="font-style:italic">y</span> <span style="font-style:italic">a</span>(<span style="font-style:italic">x</span>, <span style="font-style:italic">y</span>) + 0 <span style="font-style:italic">b</span>(<span style="font-style:italic">x</span>, <span style="font-style:italic">y</span>)</span>. Well, problem solved?
</li>
<li>
 <span class='latexinline'>
<span style="font-style:italic">xy</span><sup>2</sup> + <span style="font-style:italic">y</span> = <span style="font-style:italic">xy</span><sup>2</sup> &#X2212; <span style="font-style:italic">x</span> + <span style="font-style:italic">x</span> + <span style="font-style:italic">y</span> = <span style="font-style:italic">x</span> (<span style="font-style:italic">y</span><sup>2</sup> &#X2212; 1) + <span style="font-style:italic">x</span> + <span style="font-style:italic">y</span> = <span style="font-style:italic">x</span> <span style="font-style:italic">b</span>(<span style="font-style:italic">x</span>, <span style="font-style:italic">y</span>) + (<span style="font-style:italic">x</span> + <span style="font-style:italic">y</span>)</span>. Now what? we're stuck, and we can't apply <code>a(x, y)</code>!
</li>

</ul>

So, clearly, the <i>order</i> in which we perform of factorization / division starts
to matter! Ideally, we want an algorithm which is <i>not sensitive</i> to the order
in which we choose to apply these changes. <span class='latexinline'>
<span style="font-style:italic">x</span><sup>2</sup> + 1</span>.
<h4><a id=the-rewrite-rule-perspective href='#the-rewrite-rule-perspective'> § </a> The rewrite rule perspective</h4>
An alternative viewpoint of asking "can this be factorized", is to ask
"can we look at the factorization as a rewrite rule"? For this perspective,
notice that "factorizing" in terms of <span class='latexinline'>
<span style="font-style:italic">xy</span> + 1</span> is the same as being
able to set <span class='latexinline'>
<span style="font-style:italic">xy</span> = &#X2212;1</span>, and then have the polynomial collapse to zero.
(For the more algebraic minded, this relates to the fact that <span class='latexinline'>
<span style="font-style:italic">R</span>[<span style="font-style:italic">x</span>] / <span style="font-style:italic">p</span>(<span style="font-style:italic">x</span>) &#X223C; <span style="font-style:italic">R</span>(roots of p)</span>).
The intuition behind this is that when we "divide by <span class='latexinline'>
<span style="font-style:italic">xy</span> + 1</span>", really what
we are doing is we are setting <span class='latexinline'>
<span style="font-style:italic">xy</span> + 1 = 0</span>, and then seeing what remains. But
<span class='latexinline'>
<span style="font-style:italic">xy</span> + 1 = 0 &#XA0;&#X21D0;&#X21D2;&#XA0;<span style="font-style:italic">xy</span> = &#X2212;1</span>. Thus, we can look at the original question as:
How can we apply the rewrite rules <span class='latexinline'>
<span style="font-style:italic">xy</span> &#X2192; &#X2212;1</span>, <span class='latexinline'>
<span style="font-style:italic">y</span><sup>2</sup> &#X2192; 1</span>,
along with the regular rewrite rules of polynomial arithmetic to the polynomial
<span class='latexinline'>
<span style="font-style:italic">p</span>(<span style="font-style:italic">x</span>, <span style="font-style:italic">y</span>) = <span style="font-style:italic">xy</span><sup>2</sup> + <span style="font-style:italic">y</span></span>, such that we end with the value <span class='latexinline'>
0</span>?
Our two derivations above correspond to the application of the rules:
<ul>
<li>
 <span class='latexinline'>
<span style="font-style:italic">xy</span><sup>2</sup> + <span style="font-style:italic">y</span> &#X2192;<sup><span style="font-style:italic">xy</span> = &#X2212;1</sup> &#X2212;<span style="font-style:italic">y</span> + <span style="font-style:italic">y</span> = 0</span>
</li>
<li>
 <span class='latexinline'>
<span style="font-style:italic">xy</span><sup>2</sup> + <span style="font-style:italic">y</span> &#X2192;<sup><span style="font-style:italic">y</span><sup>2</sup> = 1</sup> <span style="font-style:italic">x</span> + <span style="font-style:italic">y</span>  stuck!</span>
</li>

</ul>

That is, our <a href=https://en.wikipedia.org/wiki/Confluence_(abstract_rewriting>
rewrite rules are not confluent</a>
)
The grobner basis is a mathematical object, which is a  <i>a confluent set of rewrite rules</i>
for the above problem. That is, it's a set of polynomials which manage to find
the rewrite <span class='latexinline'>
<span style="font-style:italic">p</span>(<span style="font-style:italic">x</span>, <span style="font-style:italic">y</span>) &#X2192;<sup>&#X22C6;</sup> 0</span>, regardless of the order in which
we apply them. It's also <i>correct</i>, in that it only rewrites to <span class='latexinline'>
0</span> if the
original system had <i>some way</i> to rewrite to <span class='latexinline'>
0</span>.
<h4><a id=the-buchbergers-algorithm href='#the-buchbergers-algorithm'> § </a> The buchberger's algorithm</h4>
We need to identify
<a href=https://en.wikipedia.org/wiki/Critical_pair_(logic>
critical pairs</a>
),
which in this setting are called as S-polynomials.
Let <span class='latexinline'>
<span style="font-style:italic">f</span><sub><span style="font-style:italic">i</span></sub> = <span style="font-style:italic">H</span>(<span style="font-style:italic">f</span><sub><span style="font-style:italic">i</span></sub>) + <span style="font-style:italic">R</span>(<span style="font-style:italic">f</span><sub><span style="font-style:italic">i</span></sub>)</span> and <span class='latexinline'>
<span style="font-style:italic">f</span><sub><span style="font-style:italic">j</span></sub> = <span style="font-style:italic">H</span>(<span style="font-style:italic">f</span><sub><span style="font-style:italic">j</span></sub>) + <span style="font-style:italic">R</span>(<span style="font-style:italic">f</span><sub><span style="font-style:italic">j</span></sub>)</span>. Let <span class='latexinline'>
<span style="font-style:italic">m</span> = <span style="font-style:italic">lcm</span>(<span style="font-style:italic">H</span>(<span style="font-style:italic">f</span><sub><span style="font-style:italic">i</span></sub>), <span style="font-style:italic">H</span>(<span style="font-style:italic">f</span><sub><span style="font-style:italic">j</span></sub>))</span>,
and let <span class='latexinline'>
<span style="font-style:italic">m</span><sub><span style="font-style:italic">i</span></sub>, <span style="font-style:italic">m</span><sub><span style="font-style:italic">j</span></sub></span> be monomials such that <span class='latexinline'>
<span style="font-style:italic">m</span><sub><span style="font-style:italic">i</span></sub> &#XB7; <span style="font-style:italic">H</span>(<span style="font-style:italic">f</span><sub><span style="font-style:italic">i</span></sub>) = <span style="font-style:italic">m</span> = <span style="font-style:italic">m</span><sub><span style="font-style:italic">j</span></sub> &#XB7; <span style="font-style:italic">H</span>(<span style="font-style:italic">f</span><sub><span style="font-style:italic">j</span></sub>)</span>.
The S-polynomial induced by <span class='latexinline'>
<span style="font-style:italic">f</span><sub><span style="font-style:italic">i</span></sub>, <span style="font-style:italic">f</span><sub><span style="font-style:italic">j</span></sub></span> is defined as <span class='latexinline'>
<span style="font-style:italic">S</span>(<span style="font-style:italic">f</span><sub><span style="font-style:italic">i</span></sub>, <span style="font-style:italic">f</span><sub><span style="font-style:italic">j</span></sub>) = <span style="font-style:italic">m</span><sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">f</span><sub><span style="font-style:italic">i</span></sub> &#X2212; <span style="font-style:italic">m</span><sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">f</span><sub><span style="font-style:italic">j</span></sub></span>.
<h4><a id=references href='#references'> § </a> References</h4>
<ul>
<li>
 <a href=https://www21.in.tum.de/~nipkow/TRaAT/>
The term rewriting perspective is from the book "term rewriting and all that"</a>

</li>
<li>
 <a href=https://mattpap.github.io/masters-thesis/html/src/groebner.html>
Sympy has excellent reading material on grobner basis</a>

</li>

</ul>

<h3><a id=lie-bracket-versus-torsion href='#lie-bracket-versus-torsion'> § </a> <a href=lie-bracket-versus-torsion>
Lie bracket versus torsion</a>
</h3>
<img width=200 height=200 src="static/lie-bracket-versus-torsion.png">
This picture <i>finally</i> made the difference between these two things clear.
The lie bracket moves along the <i>flow</i>, while the torsion moves along
<i>parallel transport</i>.
This is why the sides of the parallelogram that measure torsion form,
well, a parallelogram: we set them up using parallel transport.
On the other hand, the lie bracket measures the actual failure of the parallelogram
from being formed.
<h3><a id=blog-post-weekend-paper-replication-of-stoke-the-stochastic-superoptimizer href='#blog-post-weekend-paper-replication-of-stoke-the-stochastic-superoptimizer'> § </a> <a href=https://github.com/bollu/blaze/blob/master/notebooks/tutorial.ipynb>
Blog post: Weekend paper replication of STOKE, the stochastic superoptimizer</a>
</h3>
Click the title to go to the post. We replicate the <code>STOKE</code> paper in haskell,
to implement a superoptimiser based on MCMC methods.
<h3><a id=niquedsing- href='#niquedsing-'> § </a> Collapsing <code>BlockId</code>, <code>Label</code>, <code>Unique</code>:</h3>
We have this hiearchy of <code>BlockId</code>, <code>Label</code>, and <code>Unique</code> that can be
collapsed.
<h3><a id=spatial-partitioning-data-structures-in-molecular-dynamics href='#spatial-partitioning-data-structures-in-molecular-dynamics'> § </a> <a href=#spatial-partitioning-data-structures-in-molecular-dynamics>
Spatial partitioning data structures in molecular dynamics</a>
</h3>
<ul>
<li>
 <a href=https://en.wikipedia.org/wiki/Cell_lists>
Cell lists</a>

</li>
<li>
 <a href=https://en.wikipedia.org/wiki/Verlet_list>
Verlet lists</a>

</li>

</ul>

appear to be version of spatial hierarchical data structures for fast
interaction computation. Apparently, multipole expansions are not useful
in this case since multipole expansions are useful to take into account
long range effects, but not short range effects.
<h3><a id=vector-arthur-whitney-and-text-editors href='#vector-arthur-whitney-and-text-editors'> § </a> <a href=#vector-arthur-whitney-and-text-editors>
Vector: Arthur Whitney and text editors</a>
</h3>
<ul>
<li>
 http://archive.vector.org.uk/art10501320
</li>

</ul>

<h3><a id=intrinsicsng-cps-in-llvm-using-the- href='#intrinsicsng-cps-in-llvm-using-the-'> § </a> Representing CPS in LLVM using the <code>@coro.*</code> intrinsics</h3>
This is part of a larger thread --- <a href=http://lists.llvm.org/pipermail/llvm-dev/2017-April/112212.html>
Adding CPS call support to LLVM</a>
 where there is a large discussion on the correct design of how to teach LLVM about CPS.
Gor Nishanov proided the above example of encoding CPS using the llvm <code>coro</code> instructions.
<ul>
<li>
 https://gist.github.com/bollu/e0573dbc145028fb42f89e64c6dd6742
</li>

</ul>

<h3><a id=moaddwordc-llvm-code-generator-lowering-of- href='#moaddwordc-llvm-code-generator-lowering-of-'> § </a> Bug in the LLVM code generator: Lowering of <code>MO_Add2</code> and <code>MO_AddWordC</code></h3>
<a href=https://github.com/ghc/ghc/blob/bf73419518ca550e85188616f860961c7e2a336b/compiler/llvmGen/LlvmCodeGen/CodeGen.hs#L817>
Both of these are lowered the same way</a>
,
but they should be different.
In particular, <code>GHC.Prim</code> explains:
<ul>
<li>
 <a href=http://hackage.haskell.org/package/ghc-prim-0.5.3/docs/GHC-Prim.html#v:addWordC-35->
<code>AddWordC#</code></a>
 returns <code>(result, carry)</code>
</li>
<li>
 <a href=http://hackage.haskell.org/package/ghc-prim-0.5.3/docs/GHC-Prim.html#v:plusWord-35->
<code>PlusWordC#</code></a>
 returns <code>(carry, result)</code>
</li>

</ul>

Honestly, this is confusing, but I guess there's some story to having two separate primops for this?
<h3><a id=discrete-random-distributions-with-conditioning-in-20-lines-of-haskell href='#discrete-random-distributions-with-conditioning-in-20-lines-of-haskell'> § </a> <a href=#discrete-random-distributions-with-conditioning-in-20-lines-of-haskell>
Discrete random distributions with conditioning in 20 lines of haskell</a>
</h3>
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> <b><u><font color="#000000">newtype</font></u></b> <b><font color="#000000">D</font></b> a = <b><font color="#000000">D</font></b> { unD :: [(a, <b><font color="#000000">Double</font></b>)] } <b><u><font color="#000000">deriving</font></u></b>(<b><font color="#000000">Eq</font></b>, <b><font color="#000000">Show</font></b>, <b><font color="#000000">Ord</font></b>)
<font color="#000000">03:</font> 
<font color="#000000">04:</font> <b><u><font color="#000000">instance</font></u></b> <b><font color="#000000">Functor</font></b> <b><font color="#000000">D</font></b> <b><u><font color="#000000">where</font></u></b>
<font color="#000000">05:</font>     <i><font color="#222222">-- fmap :: (a -&gt; b) -&gt; D a -&gt; D b</font></i>
<font color="#000000">06:</font>     fmap f (<b><font color="#000000">D</font></b> xs) = <b><font color="#000000">D</font></b> $ fmap (\(a, d) -&gt; (f a, d)) xs
<font color="#000000">07:</font> 
<font color="#000000">08:</font> <b><u><font color="#000000">instance</font></u></b> <b><font color="#000000">Monad</font></b> <b><font color="#000000">D</font></b> <b><u><font color="#000000">where</font></u></b>
<font color="#000000">09:</font>     return x = <b><font color="#000000">D</font></b> $ [(x, <font color="#000000">1.0</font>)]
<font color="#000000">10:</font>     <i><font color="#222222">-- f :: a -&gt; (D b)</font></i>
<font color="#000000">11:</font>     (<b><font color="#000000">D</font></b> as) &gt;&gt;= f = <b><font color="#000000">D</font></b> $ <b><u><font color="#000000">do</font></u></b> <i><font color="#222222">-- list monad</font></i>
<font color="#000000">12:</font>                       (a, p) &lt;- as
<font color="#000000">13:</font>                       (b, p2) &lt;- unD (f a)
<font color="#000000">14:</font>                       return $ (b, p * p2)
<font color="#000000">15:</font> 
<font color="#000000">16:</font> <i><font color="#222222">-- [(a, 0.5), (b, 0.5)]</font></i>
<font color="#000000">17:</font> <i><font color="#222222">-- [(a, 0.3), (a, 0.2), (b, 0.1), (b, 0.4)]</font></i>
<font color="#000000">18:</font> <i><font color="#222222">--</font></i>
<font color="#000000">19:</font> <b><u><font color="#000000">instance</font></u></b> <b><font color="#000000">Applicative</font></b> <b><font color="#000000">D</font></b> <b><u><font color="#000000">where</font></u></b>
<font color="#000000">20:</font>     pure = return
<font color="#000000">21:</font>     ff &lt;*&gt; fa = <b><u><font color="#000000">do</font></u></b>
<font color="#000000">22:</font>         f &lt;- ff
<font color="#000000">23:</font>         a &lt;- fa
<font color="#000000">24:</font>         return $ f  a
<font color="#000000">25:</font> 
<font color="#000000">26:</font> condition :: <b><font color="#000000">Bool</font></b> -&gt; <b><font color="#000000">D</font></b> ()
<font color="#000000">27:</font> condition <b><font color="#000000">True</font></b> = <b><font color="#000000">D</font></b> [((), <font color="#000000">1.0</font>)]
<font color="#000000">28:</font> condition <b><font color="#000000">False</font></b> = <b><font color="#000000">D</font></b> [((), <font color="#000000">0.0</font>)]
<font color="#000000">29:</font> 
<font color="#000000">30:</font> 
<font color="#000000">31:</font> dice :: <b><font color="#000000">D</font></b> <b><font color="#000000">Int</font></b>
<font color="#000000">32:</font> dice = <b><u><font color="#000000">let</font></u></b> p = <font color="#000000">1.0</font> / <font color="#000000">6</font> <b><u><font color="#000000">in</font></u></b> <b><font color="#000000">D</font></b> $ [(x, p) | x &lt;- [<font color="#000000">1</font>..<font color="#000000">6</font>]]
<font color="#000000">33:</font> 
<font color="#000000">34:</font> 
<font color="#000000">35:</font> dice_hard :: <b><font color="#000000">D</font></b> <b><font color="#000000">Int</font></b>
<font color="#000000">36:</font> dice_hard = <b><u><font color="#000000">do</font></u></b>
<font color="#000000">37:</font>     x &lt;- dice
<font color="#000000">38:</font>     condition $ x &gt; <font color="#000000">3</font>
<font color="#000000">39:</font>     return $ x
<font color="#000000">40:</font> 
<font color="#000000">41:</font> 
<font color="#000000">42:</font> main :: <b><font color="#000000">IO</font></b> ()
<font color="#000000">43:</font> main = <b><u><font color="#000000">do</font></u></b>
<font color="#000000">44:</font>     print dice
<font color="#000000">45:</font>     print dice_hard
<font color="#000000">46:</font> </tt></pre>
</div>

This gives the output:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> D {unD = [(1,0.16666666666666666),
<font color="#000000">03:</font>           (2,0.16666666666666666),
<font color="#000000">04:</font>           (3,0.16666666666666666),
<font color="#000000">05:</font>           (4,0.16666666666666666),
<font color="#000000">06:</font>           (5,0.16666666666666666),
<font color="#000000">07:</font>           (6,0.16666666666666666)]}
<font color="#000000">08:</font> 
<font color="#000000">09:</font> D {unD = [(1,0.0),
<font color="#000000">10:</font>           (2,0.0),
<font color="#000000">11:</font>           (3,0.0),
<font color="#000000">12:</font>           (4,0.16666666666666666),
<font color="#000000">13:</font>           (5,0.16666666666666666),
<font color="#000000">14:</font>           (6,0.16666666666666666)]}
<font color="#000000">15:</font> </tt></pre>
</div>

Notice that <code>D a ~= WriterT (Product Float) []</code>!
<h3><a id=everything-you-know-about-word2vec-is-wrong href='#everything-you-know-about-word2vec-is-wrong'> § </a> <a href=#everything-you-know-about-word2vec-is-wrong>
Everything you know about word2vec is wrong</a>
</h3>
The classic explanation of <code>word2vec</code>, in skip-gram, with negative sampling,
in the paper and countless blog posts on the internet is as follows:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> while(1) {
<font color="#000000">3:</font>    1. vf = vector of focus word
<font color="#000000">4:</font>    2. vc = vector of context word
<font color="#000000">5:</font>    3. train such that (vc . vf = 1)
<font color="#000000">6:</font>    4. for(0 &lt;= i &lt; negative samples):
<font color="#000000">7:</font>            vneg = vector of word *not* in context
<font color="#000000">8:</font>            train such that (vf . vneg = 0)
<font color="#000000">9:</font> }
<font color="#000000">10:</font> </tt></pre>
</div>

Indeed, if I google "word2vec skipgram", the results I get are:
<ul>
<li>
 <a href=https://en.wikipedia.org/wiki/Word2vec#Training_algorithm>
The wikipedia page which describes the algorithm on a high level</a>

</li>
<li>
 <a href=https://www.tensorflow.org/tutorials/representation/word2vec>
The tensorflow page with the same explanation</a>

</li>
<li>
 <a href=https://towardsdatascience.com/word2vec-skip-gram-model-part-1-intuition-78614e4d6e0b>
The towards data science blog which describes the same algorithm</a>

</li>

</ul>

the list goes on. However, <b>every single one of these implementations is wrong</b>.
The original word2vec <code>C</code> implementation does <i>not</i> do what's explained above,
and is <i>drastically different</i>. Most serious users of word embeddings, who use
embeddings generated from <code>word2vec</code> do one of the following things:
<ol>
<li>
 They invoke the original C implementation directly.
</li>
<li>
 They invoke the <code>gensim</code> implementation, which is <i>transliterated</i> from the
   C source to the extent that the variables names are the same.
</li>

</ol>

Indeed, the <code>gensim</code> implementation is the 
<b>only one that I know of which is faithful to the C implementation</b>.
<h4><a id=the-c-implementation href='#the-c-implementation'> § </a> The C implementation</h4>
The C implementation in fact maintains <i>two vectors for each word</i>, one where
it appears as a focus word, and one where it appears as a context word.
(Is this sounding familiar? Indeed, it appears that GloVe actually took this
idea from <code>word2vec</code>, which has never mentioned this fact!)
The setup is incredibly well done in the C code:
<ul>
<li>
 An array called <code>syn0</code> holds the vector embedding of a word when it occurs
  as a <i>focus word</i>. This is <b>random initialized</b>.
</li>

</ul>

<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> https:<i><font color="#222222">//github.com/tmikolov/word2vec/blob/20c129af10659f7c50e86e3be406df663beff438/word2vec.c#L369</font></i>
<font color="#000000">3:</font>   <b><u><font color="#000000">for</font></u></b> (a = <font color="#000000">0</font>; a &lt; vocab_size; a++) <b><u><font color="#000000">for</font></u></b> (b = <font color="#000000">0</font>; b &lt; layer1_size; b++) {
<font color="#000000">4:</font>     next_random = next_random * (<b><font color="#000000">unsigned</font></b> <b><font color="#000000">long</font></b> <b><font color="#000000">long</font></b>)<font color="#000000">25214903917</font> + <font color="#000000">11</font>;
<font color="#000000">5:</font>     syn0[a * layer1_size + b] =
<font color="#000000">6:</font>        (((next_random &amp; <font color="#000000">0xFFFF</font>) / (real)<font color="#000000">65536</font>) - <font color="#000000">0.5</font>) / layer1_size;
<font color="#000000">7:</font>   }
<font color="#000000">8:</font> 
<font color="#000000">9:</font> </tt></pre>
</div>

<ul>
<li>
 Another array called <code>syn1neg</code> holds the vector of a word when it occurs
  as a <i>context word</i>. This is <b>zero initialized</b>.
</li>

</ul>

<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> https:<i><font color="#222222">//github.com/tmikolov/word2vec/blob/20c129af10659f7c50e86e3be406df663beff438/word2vec.c#L365</font></i>
<font color="#000000">3:</font> <b><u><font color="#000000">for</font></u></b> (a = <font color="#000000">0</font>; a &lt; vocab_size; a++) <b><u><font color="#000000">for</font></u></b> (b = <font color="#000000">0</font>; b &lt; layer1_size; b++)
<font color="#000000">4:</font>   syn1neg[a * layer1_size + b] = <font color="#000000">0</font>;
<font color="#000000">5:</font> </tt></pre>
</div>

<ul>
<li>
 During training (skip-gram, negative sampling, though other cases are
  also similar), we first pick a focus word. This is held constant throughout
  the positive and negative sample training. The gradients of the focus vector
  are accumulated in a buffer, and are applied to the focus word
  <i>after it has been affected by both positive and negative samples</i>.
</li>

</ul>

<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> <b><u><font color="#000000">if</font></u></b> (negative &gt; <font color="#000000">0</font>) <b><u><font color="#000000">for</font></u></b> (d = <font color="#000000">0</font>; d &lt; negative + <font color="#000000">1</font>; d++) {
<font color="#000000">03:</font>   <i><font color="#222222">// if we are performing negative sampling, in the 1st iteration,</font></i>
<font color="#000000">04:</font>   <i><font color="#222222">// pick a word from the context and set the dot product target to 1</font></i>
<font color="#000000">05:</font>   <b><u><font color="#000000">if</font></u></b> (d == <font color="#000000">0</font>) {
<font color="#000000">06:</font>     target = word;
<font color="#000000">07:</font>     label = <font color="#000000">1</font>;
<font color="#000000">08:</font>   } <b><u><font color="#000000">else</font></u></b> {
<font color="#000000">09:</font>     <i><font color="#222222">// for all other iterations, pick a word randomly and set the dot</font></i>
<font color="#000000">10:</font>     <i><font color="#222222">//product target to 0</font></i>
<font color="#000000">11:</font>     next_random = next_random * (<b><font color="#000000">unsigned</font></b> <b><font color="#000000">long</font></b> <b><font color="#000000">long</font></b>)<font color="#000000">25214903917</font> + <font color="#000000">11</font>;
<font color="#000000">12:</font>     target = table[(next_random &gt;&gt; <font color="#000000">16</font>) % table_size];
<font color="#000000">13:</font>     <b><u><font color="#000000">if</font></u></b> (target == <font color="#000000">0</font>) target = next_random % (vocab_size - <font color="#000000">1</font>) + <font color="#000000">1</font>;
<font color="#000000">14:</font>     <b><u><font color="#000000">if</font></u></b> (target == word) <b><u><font color="#000000">continue</font></u></b>;
<font color="#000000">15:</font>     label = <font color="#000000">0</font>;
<font color="#000000">16:</font>   }
<font color="#000000">17:</font>   l2 = target * layer1_size;
<font color="#000000">18:</font>   f = <font color="#000000">0</font>;
<font color="#000000">19:</font> 
<font color="#000000">20:</font>   <i><font color="#222222">// find dot product of original vector with negative sample vector</font></i>
<font color="#000000">21:</font>   <i><font color="#222222">// store in f</font></i>
<font color="#000000">22:</font>   <b><u><font color="#000000">for</font></u></b> (c = <font color="#000000">0</font>; c &lt; layer1_size; c++) f += syn0[c + l1] * syn1neg[c + l2];
<font color="#000000">23:</font> 
<font color="#000000">24:</font>   <i><font color="#222222">// set g = sigmoid(f) (roughly, the actual formula is slightly more complex)</font></i>
<font color="#000000">25:</font>   <b><u><font color="#000000">if</font></u></b> (f &gt; MAX_EXP) g = (label - <font color="#000000">1</font>) * alpha;
<font color="#000000">26:</font>   <b><u><font color="#000000">else</font></u></b> <b><u><font color="#000000">if</font></u></b> (f &lt; -MAX_EXP) g = (label - <font color="#000000">0</font>) * alpha;
<font color="#000000">27:</font>   <b><u><font color="#000000">else</font></u></b> g = (label - expTable[(<b><font color="#000000">int</font></b>)((f + MAX_EXP) * (EXP_TABLE_SIZE / MAX_EXP / <font color="#000000">2</font>))]) * alpha;
<font color="#000000">28:</font> 
<font color="#000000">29:</font>   <i><font color="#222222">// 1. update the vector syn1neg,</font></i>
<font color="#000000">30:</font>   <i><font color="#222222">// 2. DO NOT UPDATE syn0</font></i>
<font color="#000000">31:</font>   <i><font color="#222222">// 3. STORE THE syn0 gradient in a temporary buffer neu1e</font></i>
<font color="#000000">32:</font>   <b><u><font color="#000000">for</font></u></b> (c = <font color="#000000">0</font>; c &lt; layer1_size; c++) neu1e[c] += g * syn1neg[c + l2];
<font color="#000000">33:</font>   <b><u><font color="#000000">for</font></u></b> (c = <font color="#000000">0</font>; c &lt; layer1_size; c++) syn1neg[c + l2] += g * syn0[c + l1];
<font color="#000000">34:</font> }
<font color="#000000">35:</font> <i><font color="#222222">// Finally, after all samples, update syn1 from neu1e</font></i>
<font color="#000000">36:</font> https:<i><font color="#222222">//github.com/tmikolov/word2vec/blob/20c129af10659f7c50e86e3be406df663beff438/word2vec.c#L541</font></i>
<font color="#000000">37:</font> <i><font color="#222222">// Learn weights input -&gt; hidden</font></i>
<font color="#000000">38:</font> <b><u><font color="#000000">for</font></u></b> (c = <font color="#000000">0</font>; c &lt; layer1_size; c++) syn0[c + l1] += neu1e[c];
<font color="#000000">39:</font> </tt></pre>
</div>

<h4><a id=why-random-and-zero-initialization href='#why-random-and-zero-initialization'> § </a> Why random and zero initialization?</h4>
Once again, since none of this actually explained in the original papers
<i>or on the web</i>, I can only hypothesize.
My hypothesis is that since the negative samples come from all over the text
and are not really weighed by frequency, you can wind up picking <i>any word</i>,
and more often than not, <i>a word whose vector has not been trained much at all</i>.
If this vector actually had a value, then it could move the actually important
focus word randomly.
The solution is to set all negative samples to zero, so that 
<i>only vectors that have occurred somewhat frequently</i> will affect the representation 
of another vector.
It's quite ingenious, really, and until this, I'd never really thought of
how important initialization strategies really are.
<h4><a id=why-im-writing-this href='#why-im-writing-this'> § </a> Why I'm writing this</h4>
I spent two months of my life trying to reproduce <code>word2vec</code>, following
the paper exactly, reading countless articles, and simply not succeeding.
I was unable to reach the same scores that <code>word2vec</code> did, and it was not
for lack of trying.
I could not have imagined that the paper would have literally fabricated an
algorithm that doesn't work, while the implementation does something completely
different.
Eventually, I decided to read the sources, and spent three whole days convinced
I was reading the code wrong since literally everything on the internet told me
otherwise.
I don't understand why the original paper and the internet contain zero
explanations of the <i>actual</i> mechanism behind <code>word2vec</code>, so I decided to put
it up myself.
This also explains GloVe's radical choice of having a separate vector
for the negative context --- they were just doing what <code>word2vec</code> does, but
they told people about it <code>:)</code>.
Is this academic dishonesty? I don't know the answer, and that's a heavy
question. But I'm frankly incredibly pissed, and this is probably the last
time I take a machine learning paper's explanation of the algorithm
seriously again --- from next time, I read the source <i>first</i>.
<h3><a id=hamiltonian-monte-carlo-leapfrog-integrators-and-sympletic-geometry href='#hamiltonian-monte-carlo-leapfrog-integrators-and-sympletic-geometry'> § </a> Hamiltonian monte carlo, leapfrog integrators, and sympletic geometry</h3>
This is a section that I'll update as I learn more about the space, since I'm studying
differential geometry over the summer, I hope to know enough about "sympletic manifolds".
I'll make this an append-only log to add to the section as I understand more.
<h4><a id=31st-may href='#31st-may'> § </a> 31st May</h4>
<ul>
<li>
 To perform hamiltonian monte carlo, we use the hamiltonian and its
  derivatives to provide a momentum to our proposal distribution --- That is,
  when we choose a new point from the current point, our probability
  distribution for the new point is influenced by our current momentum.
</li>

</ul>

<ul>
<li>
 For some integral necessary within this scheme, Euler integration doesn't cut it
  since the error diverges to infinity
</li>

</ul>

<ul>
<li>
 Hence, we need an integrator that guarantees that the energy of out system is
  conserved.  Enter the leapfrog integrator. This integrator is also 
  <i>time reversible</i> -- We can run it forward for <code>n</code> steps, and then run it
  backward for <code>n</code> steps to arrive at the same state.  Now I finally know how
  Braid was implemented, something that bugged the hell out of 9th grade me
  when I tried to implement Braid-like physics in my engine!
</li>

</ul>

<ul>
<li>
 The actual derivation of the integrator uses Lie algebras, Sympletic
  geometry, and other diffgeo ideas, which is great, because it gives me
  motivation to study differential geometry <code>:)</code>
</li>

</ul>

<ul>
<li>
 Original paper: <a href=https://www.sciencedirect.com/science/article/abs/pii/0375960190900923>
Construction of higher order sympletic integrators</a>

</li>

</ul>

<h4><a id=simulating-orbits-with-large-timesteps href='#simulating-orbits-with-large-timesteps'> § </a> Simulating orbits with large timesteps</h4>
<img width=200 height=200 src="./static/leapfrog-vs-euler.png">
Clearly, the leapfrog integrator preserves energy and continues to move
in an orbit, while the euler integrator goes batshit and causes orbits
to spiral outwards. Full code is available below. More of the code is
spent coaxing matplotlib to look nice, than doing the actual
computation.
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> <b><u><font color="#000000">import</font></u></b> numpy as np
<font color="#000000">03:</font> <b><u><font color="#000000">import</font></u></b> matplotlib.pyplot as plt
<font color="#000000">04:</font> <b><u><font color="#000000">import</font></u></b> numpy.linalg
<font color="#000000">05:</font> 
<font color="#000000">06:</font> <i><font color="#222222">## dq/dt = dH/dp | dp/dt = -dH/dq (a = -del V)</font></i>
<font color="#000000">07:</font> <b><u><font color="#000000">def</font></u></b> leapfroge(dhdp, dhdq, q, p, dt):
<font color="#000000">08:</font>     p += -dhdq(q, p) * <font color="#000000">0.5</font> * dt <i><font color="#222222"># halfstep momentum</font></i>
<font color="#000000">09:</font>     q += dhdp(q, p) * dt <i><font color="#222222"># fullstep position</font></i>
<font color="#000000">10:</font>     p += -dhdq(q, p) * <font color="#000000">0.5</font> * dt <i><font color="#222222"># halfstep momentum</font></i>
<font color="#000000">11:</font>     <b><u><font color="#000000">return</font></u></b> (q, p)
<font color="#000000">12:</font> 
<font color="#000000">13:</font> <b><u><font color="#000000">def</font></u></b> euler(dhdp, dhdq, q, p, dt):
<font color="#000000">14:</font>     pnew = p + -dhdq(q, p) * dt
<font color="#000000">15:</font>     qnew = q + dhdp(q, p) * dt
<font color="#000000">16:</font> 
<font color="#000000">17:</font> <b><u><font color="#000000">def</font></u></b> planet(integrator, n, dt):
<font color="#000000">18:</font>     STRENGTH = <font color="#000000">0.5</font>
<font color="#000000">19:</font> 
<font color="#000000">20:</font>     q = np.array([<font color="#000000">0.0</font>, <font color="#000000">1.0</font>]); p = np.array([-<font color="#000000">1.0</font>, <font color="#000000">0.0</font>])
<font color="#000000">21:</font> 
<font color="#000000">22:</font>     <i><font color="#222222"># H = STRENGTH * |q| (potential) + p^2/2 (kinetic)</font></i>
<font color="#000000">23:</font>     <b><u><font color="#000000">def</font></u></b> H(qcur, pcur): <b><u><font color="#000000">return</font></u></b> STRENGTH * np.linalg.norm(q) + np.dot(p, p) / <font color="#000000">2</font>
<font color="#000000">24:</font>     <b><u><font color="#000000">def</font></u></b> dhdp(qcur, pcur): <b><u><font color="#000000">return</font></u></b> p
<font color="#000000">25:</font>     <b><u><font color="#000000">def</font></u></b> dhdq(qcur, pcur): <b><u><font color="#000000">return</font></u></b> STRENGTH * <font color="#000000">2</font> * q / np.linalg.norm(q)
<font color="#000000">26:</font> 
<font color="#000000">27:</font>     qs = []
<font color="#000000">28:</font>     <b><u><font color="#000000">for</font></u></b> i <b><u><font color="#000000">in</font></u></b> range(n):
<font color="#000000">29:</font>         (q, p) = integrator(dhdp, dhdq, q, p, dt)
<font color="#000000">30:</font>         qs.append(q.copy())
<font color="#000000">31:</font>     <b><u><font color="#000000">return</font></u></b> np.asarray(qs)
<font color="#000000">32:</font> 
<font color="#000000">33:</font> NITERS = <font color="#000000">15</font>
<font color="#000000">34:</font> TIMESTEP = <font color="#000000">1</font>
<font color="#000000">35:</font> 
<font color="#000000">36:</font> plt.rcParams.update({<font color="#808080">'font.size'</font>: <font color="#000000">22</font>, <font color="#808080">'font.family'</font>:<font color="#808080">'monospace'</font>})
<font color="#000000">37:</font> fig, ax = plt.subplots()
<font color="#000000">38:</font> 
<font color="#000000">39:</font> planet_leapfrog = planet(leapfroge, NITERS, TIMESTEP)
<font color="#000000">40:</font> ax.plot(planet_leapfrog[:, <font color="#000000">0</font>], planet_leapfrog[:, <font color="#000000">1</font>], label=<font color="#808080">'leapfrog'</font>,
<font color="#000000">41:</font>         linewidth=<font color="#000000">3</font>, color=<font color="#808080">'#00ACC1'</font>)
<font color="#000000">42:</font> planet_euler = planet(euler, NITERS, TIMESTEP)
<font color="#000000">43:</font> ax.plot(planet_euler[:, <font color="#000000">0</font>], planet_euler[:, <font color="#000000">1</font>], label=<font color="#808080">'euler'</font>,
<font color="#000000">44:</font>         linewidth=<font color="#000000">3</font>, color=<font color="#808080">'#D81B60'</font>)
<font color="#000000">45:</font> 
<font color="#000000">46:</font> legend = plt.legend(frameon=False)
<font color="#000000">47:</font> ax.set_title(<font color="#808080">"leapfrog v/s euler: NITERS=%s dt=%s"</font> % (NITERS, TIMESTEP))
<font color="#000000">48:</font> ax.spines[<font color="#808080">'top'</font>].set_visible(False)
<font color="#000000">49:</font> ax.spines[<font color="#808080">'right'</font>].set_visible(False)
<font color="#000000">50:</font> ax.spines[<font color="#808080">'bottom'</font>].set_visible(False)
<font color="#000000">51:</font> ax.spines[<font color="#808080">'left'</font>].set_visible(False)
<font color="#000000">52:</font> plt.show()
<font color="#000000">53:</font> plt.savefig(<font color="#808080">"leapfrog-vs-euler.png"</font>)
<font color="#000000">54:</font> </tt></pre>
</div>

<h3><a id=small-haskell-mcmc-implementation href='#small-haskell-mcmc-implementation'> § </a> <a href=#small-haskell-mcmc-implementation>
Small Haskell MCMC implementation</a>
</h3>
We create a simple monad called <code>PL</code> which allows for a single operation: sampling
from a uniform distribution. We then exploit this to implement MCMC using metropolis hastings,
which is used to sample from arbitrary distributions. Bonus is a small library to render sparklines
in the CLI.
For next time:
<ul>
<li>
 Using applicative to speed up computations by exploiting parallelism
</li>
<li>
 Conditioning of a distribution wrt a variable
</li>

</ul>

<h4><a id=source-code href='#source-code'> § </a> Source code</h4>
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">001:</font> 
<font color="#000000">002:</font> <i><font color="#222222">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</font></i>
<font color="#000000">003:</font> <i><font color="#222222">{-# LANGUAGE GADTs #-}</font></i>
<font color="#000000">004:</font> <i><font color="#222222">{-# LANGUAGE StandaloneDeriving #-}</font></i>
<font color="#000000">005:</font> <i><font color="#222222">{-# LANGUAGE FlexibleContexts #-}</font></i>
<font color="#000000">006:</font> <i><font color="#222222">{-# LANGUAGE FlexibleInstances #-}</font></i>
<font color="#000000">007:</font> <i><font color="#222222">{-# LANGUAGE UndecidableInstances #-}</font></i>
<font color="#000000">008:</font> <i><font color="#222222">{-# LANGUAGE DeriveFunctor #-}</font></i>
<font color="#000000">009:</font> <b><u><font color="#000000">import</font></u></b> System.<b><font color="#000000">Random</font></b>
<font color="#000000">010:</font> <b><u><font color="#000000">import</font></u></b> Data.<b><font color="#000000">List</font></b>(sort, nub)
<font color="#000000">011:</font> <b><u><font color="#000000">import</font></u></b> Data.<b><font color="#000000">Proxy</font></b>
<font color="#000000">012:</font> <b><u><font color="#000000">import</font></u></b> Control.<b><font color="#000000">Monad</font></b> (replicateM)
<font color="#000000">013:</font> <b><u><font color="#000000">import</font></u></b> qualified Data.<b><font color="#000000">Map</font></b> as <b><font color="#000000">M</font></b>
<font color="#000000">014:</font> 
<font color="#000000">015:</font> 
<font color="#000000">016:</font> <i><font color="#222222">-- | Loop a monadic computation.</font></i>
<font color="#000000">017:</font> mLoop :: <b><font color="#000000">Monad</font></b> m =&gt;
<font color="#000000">018:</font>       (a -&gt; m a) <i><font color="#222222">-- ^ loop</font></i>
<font color="#000000">019:</font>       -&gt; <b><font color="#000000">Int</font></b> <i><font color="#222222">-- ^ number of times to run</font></i>
<font color="#000000">020:</font>       -&gt; a <i><font color="#222222">-- initial value</font></i>
<font color="#000000">021:</font>       -&gt; m a <i><font color="#222222">-- final value</font></i>
<font color="#000000">022:</font> mLoop <b><u><font color="#000000">_</font></u></b> <font color="#000000">0</font> a = return a
<font color="#000000">023:</font> mLoop f n a = f a &gt;&gt;= mLoop f (n - <font color="#000000">1</font>)
<font color="#000000">024:</font> 
<font color="#000000">025:</font> 
<font color="#000000">026:</font> <i><font color="#222222">-- | Utility library for drawing sparklines</font></i>
<font color="#000000">027:</font> 
<font color="#000000">028:</font> <i><font color="#222222">-- | List of characters that represent sparklines</font></i>
<font color="#000000">029:</font> sparkchars :: <b><font color="#000000">String</font></b>
<font color="#000000">030:</font> sparkchars = <font color="#808080">"_▁▂▃▄▅▆▇█"</font>
<font color="#000000">031:</font> 
<font color="#000000">032:</font> <i><font color="#222222">-- Convert an int to a sparkline character</font></i>
<font color="#000000">033:</font> num2spark :: <b><font color="#000000">RealFrac</font></b> a =&gt; a <i><font color="#222222">-- ^ Max value</font></i>
<font color="#000000">034:</font>   -&gt; a <i><font color="#222222">-- ^ Current value</font></i>
<font color="#000000">035:</font>   -&gt; <b><font color="#000000">Char</font></b>
<font color="#000000">036:</font> num2spark maxv curv =
<font color="#000000">037:</font>    sparkchars !!
<font color="#000000">038:</font>      (floor $ (curv / maxv) * (fromIntegral (length sparkchars - <font color="#000000">1</font>)))
<font color="#000000">039:</font> 
<font color="#000000">040:</font> series2spark :: <b><font color="#000000">RealFrac</font></b> a =&gt; [a] -&gt; <b><font color="#000000">String</font></b>
<font color="#000000">041:</font> series2spark vs =
<font color="#000000">042:</font>   <b><u><font color="#000000">let</font></u></b> maxv = <b><u><font color="#000000">if</font></u></b> null vs <b><u><font color="#000000">then</font></u></b> <font color="#000000">0</font> <b><u><font color="#000000">else</font></u></b> maximum vs
<font color="#000000">043:</font>   <b><u><font color="#000000">in</font></u></b> map (num2spark maxv) vs
<font color="#000000">044:</font> 
<font color="#000000">045:</font> seriesPrintSpark :: <b><font color="#000000">RealFrac</font></b> a =&gt; [a] -&gt; <b><font color="#000000">IO</font></b> ()
<font color="#000000">046:</font> seriesPrintSpark = putStrLn . series2spark
<font color="#000000">047:</font> 
<font color="#000000">048:</font> <i><font color="#222222">-- Probabilities</font></i>
<font color="#000000">049:</font> <i><font color="#222222">-- ============</font></i>
<font color="#000000">050:</font> <b><u><font color="#000000">type</font></u></b> <b><font color="#000000">F</font></b> = <b><font color="#000000">Float</font></b>
<font color="#000000">051:</font> <i><font color="#222222">-- | probability density</font></i>
<font color="#000000">052:</font> <b><u><font color="#000000">newtype</font></u></b> <b><font color="#000000">P</font></b> = <b><font color="#000000">P</font></b> { unP :: <b><font color="#000000">Float</font></b> } <b><u><font color="#000000">deriving</font></u></b>(<b><font color="#000000">Num</font></b>)
<font color="#000000">053:</font> 
<font color="#000000">054:</font> <i><font color="#222222">-- | prob. distributions over space a</font></i>
<font color="#000000">055:</font> <b><u><font color="#000000">newtype</font></u></b> <b><font color="#000000">D</font></b> a = <b><font color="#000000">D</font></b> { runD :: a -&gt; <b><font color="#000000">P</font></b> }
<font color="#000000">056:</font> 
<font color="#000000">057:</font> uniform :: <b><font color="#000000">Int</font></b> -&gt; <b><font color="#000000">D</font></b> a
<font color="#000000">058:</font> uniform n =
<font color="#000000">059:</font>   <b><font color="#000000">D</font></b> $ \<b><u><font color="#000000">_</font></u></b> -&gt; <b><font color="#000000">P</font></b> $ <font color="#000000">1.0</font> / (fromIntegral $ n)
<font color="#000000">060:</font> 
<font color="#000000">061:</font> (&gt;$&lt;) :: <b><font color="#000000">Contravariant</font></b> f =&gt; (b -&gt; a) -&gt; f a  -&gt; f b
<font color="#000000">062:</font> (&gt;$&lt;) = cofmap
<font color="#000000">063:</font> 
<font color="#000000">064:</font> <b><u><font color="#000000">instance</font></u></b> <b><font color="#000000">Contravariant</font></b> <b><font color="#000000">D</font></b> <b><u><font color="#000000">where</font></u></b>
<font color="#000000">065:</font>   cofmap f (<b><font color="#000000">D</font></b> d) = <b><font color="#000000">D</font></b> (d . f)
<font color="#000000">066:</font> 
<font color="#000000">067:</font> <i><font color="#222222">-- | Normal distribution with given mean</font></i>
<font color="#000000">068:</font> normalD :: <b><font color="#000000">Float</font></b> -&gt;  <b><font color="#000000">D</font></b> <b><font color="#000000">Float</font></b>
<font color="#000000">069:</font> normalD mu = <b><font color="#000000">D</font></b> $ \f -&gt; <b><font color="#000000">P</font></b> $ exp (- ((f-mu)^<font color="#000000">2</font>))
<font color="#000000">070:</font> 
<font color="#000000">071:</font> <i><font color="#222222">-- | Distribution that takes on value x^p for 1 &lt;= x &lt;= 2.  Is normalized</font></i>
<font color="#000000">072:</font> polyD :: <b><font color="#000000">Float</font></b> -&gt; <b><font color="#000000">D</font></b> <b><font color="#000000">Float</font></b>
<font color="#000000">073:</font> polyD p = <b><font color="#000000">D</font></b> $ \f -&gt; <b><font color="#000000">P</font></b> $ <b><u><font color="#000000">if</font></u></b> <font color="#000000">1</font> &lt;= f &amp;&amp; f &lt;= <font color="#000000">2</font> <b><u><font color="#000000">then</font></u></b> (f ** p) * (p + <font color="#000000">1</font>) / (<font color="#000000">2</font> ** (p+<font color="#000000">1</font>) - <font color="#000000">1</font>) <b><u><font color="#000000">else</font></u></b> <font color="#000000">0</font>
<font color="#000000">074:</font> 
<font color="#000000">075:</font> <b><u><font color="#000000">class</font></u></b> <b><font color="#000000">Contravariant</font></b> f <b><u><font color="#000000">where</font></u></b>
<font color="#000000">076:</font>   cofmap :: (b -&gt; a) -&gt; f a -&gt; f b
<font color="#000000">077:</font> 
<font color="#000000">078:</font> <b><u><font color="#000000">data</font></u></b> <b><font color="#000000">PL</font></b> next <b><u><font color="#000000">where</font></u></b>
<font color="#000000">079:</font>     <b><font color="#000000">Ret</font></b> :: next -&gt; <b><font color="#000000">PL</font></b> next <i><font color="#222222">-- ^ return  a value</font></i>
<font color="#000000">080:</font>     <b><font color="#000000">Sample01</font></b> :: (<b><font color="#000000">Float</font></b> -&gt; <b><font color="#000000">PL</font></b> next) -&gt; <b><font color="#000000">PL</font></b> next <i><font color="#222222">-- ^ sample uniformly from a [0, 1) distribution</font></i>
<font color="#000000">081:</font> 
<font color="#000000">082:</font> <b><u><font color="#000000">instance</font></u></b> <b><font color="#000000">Monad</font></b> <b><font color="#000000">PL</font></b> <b><u><font color="#000000">where</font></u></b>
<font color="#000000">083:</font>   return = <b><font color="#000000">Ret</font></b>
<font color="#000000">084:</font>   (<b><font color="#000000">Ret</font></b> a) &gt;&gt;= f = f a
<font color="#000000">085:</font>   (<b><font color="#000000">Sample01</font></b> float2plnext) &gt;&gt;= next2next' =
<font color="#000000">086:</font>       <b><font color="#000000">Sample01</font></b> $ \f -&gt; float2plnext f &gt;&gt;= next2next'
<font color="#000000">087:</font> 
<font color="#000000">088:</font> <b><u><font color="#000000">instance</font></u></b> <b><font color="#000000">Applicative</font></b> <b><font color="#000000">PL</font></b> <b><u><font color="#000000">where</font></u></b>
<font color="#000000">089:</font>     pure = return
<font color="#000000">090:</font>     ff &lt;*&gt; fx = <b><u><font color="#000000">do</font></u></b>
<font color="#000000">091:</font>         f &lt;- ff
<font color="#000000">092:</font>         x &lt;- fx
<font color="#000000">093:</font>         return $ f x
<font color="#000000">094:</font> 
<font color="#000000">095:</font> <b><u><font color="#000000">instance</font></u></b> <b><font color="#000000">Functor</font></b> <b><font color="#000000">PL</font></b> <b><u><font color="#000000">where</font></u></b>
<font color="#000000">096:</font>     fmap f plx = <b><u><font color="#000000">do</font></u></b>
<font color="#000000">097:</font>          x &lt;- plx
<font color="#000000">098:</font>          return $ f x
<font color="#000000">099:</font> 
<font color="#000000">100:</font> <i><font color="#222222">-- | operation to sample from [0, 1)</font></i>
<font color="#000000">101:</font> sample01 :: <b><font color="#000000">PL</font></b> <b><font color="#000000">Float</font></b>
<font color="#000000">102:</font> sample01 = <b><font color="#000000">Sample01</font></b> <b><font color="#000000">Ret</font></b>
<font color="#000000">103:</font> 
<font color="#000000">104:</font> 
<font color="#000000">105:</font> <i><font color="#222222">-- | Run one step of MH on a distribution to obtain a (correlated) sample</font></i>
<font color="#000000">106:</font> mhStep :: (a -&gt; <b><font color="#000000">Float</font></b>) <i><font color="#222222">-- ^ function to score sample with, proportional to distribution</font></i>
<font color="#000000">107:</font>   -&gt; (a -&gt; <b><font color="#000000">PL</font></b> a) <i><font color="#222222">-- ^ Proposal program</font></i>
<font color="#000000">108:</font>   -&gt; a <i><font color="#222222">-- current sample</font></i>
<font color="#000000">109:</font>   -&gt; <b><font color="#000000">PL</font></b> a
<font color="#000000">110:</font> mhStep f q a = <b><u><font color="#000000">do</font></u></b>
<font color="#000000">111:</font>         a' &lt;- q a
<font color="#000000">112:</font>         <b><u><font color="#000000">let</font></u></b> alpha = f a' / f a <i><font color="#222222">-- acceptance ratio</font></i>
<font color="#000000">113:</font>         u &lt;- sample01
<font color="#000000">114:</font>         return $ <b><u><font color="#000000">if</font></u></b> u &lt;= alpha <b><u><font color="#000000">then</font></u></b> a' <b><u><font color="#000000">else</font></u></b> a
<font color="#000000">115:</font> 
<font color="#000000">116:</font> <i><font color="#222222">-- Typeclass that can provide me with data to run MCMC on it</font></i>
<font color="#000000">117:</font> <b><u><font color="#000000">class</font></u></b> <b><font color="#000000">MCMC</font></b> a <b><u><font color="#000000">where</font></u></b>
<font color="#000000">118:</font>     arbitrary :: a
<font color="#000000">119:</font>     uniform2val :: <b><font color="#000000">Float</font></b> -&gt; a
<font color="#000000">120:</font> 
<font color="#000000">121:</font> <b><u><font color="#000000">instance</font></u></b> <b><font color="#000000">MCMC</font></b> <b><font color="#000000">Float</font></b> <b><u><font color="#000000">where</font></u></b>
<font color="#000000">122:</font>         arbitrary = <font color="#000000">0</font>
<font color="#000000">123:</font>         <i><font color="#222222">-- map [0, 1) -&gt; (-infty, infty)</font></i>
<font color="#000000">124:</font>         uniform2val v = tan (-pi/<font color="#000000">2</font> + pi * v)
<font color="#000000">125:</font> 
<font color="#000000">126:</font> 
<font color="#000000">127:</font> <i><font color="#222222">{-</font></i>
<font color="#000000">128:</font> <i><font color="#222222">-- | Any enumerable object has a way to get me the starting point for MCMC</font></i>
<font color="#000000">129:</font> <i><font color="#222222">instance (Bounded a, Enum a) =&gt; MCMC a where</font></i>
<font color="#000000">130:</font> <i><font color="#222222">     arbitrary = toEnum 0</font></i>
<font color="#000000">131:</font> <i><font color="#222222">     uniform2val v = let</font></i>
<font color="#000000">132:</font> <i><font color="#222222">        maxf = fromIntegral . fromEnum $ maxBound</font></i>
<font color="#000000">133:</font> <i><font color="#222222">        minf = fromIntegral . fromEnum $ minBound</font></i>
<font color="#000000">134:</font> <i><font color="#222222">        in toEnum $ floor $ minf + v * (maxf - minf)</font></i>
<font color="#000000">135:</font> <i><font color="#222222">-}</font></i>
<font color="#000000">136:</font> 
<font color="#000000">137:</font> 
<font color="#000000">138:</font> <i><font color="#222222">-- | Run MH to sample from a distribution</font></i>
<font color="#000000">139:</font> mh :: (a -&gt; <b><font color="#000000">Float</font></b>) <i><font color="#222222">-- ^ function to score sample with</font></i>
<font color="#000000">140:</font>  -&gt; (a -&gt; <b><font color="#000000">PL</font></b> a) <i><font color="#222222">-- ^ proposal program</font></i>
<font color="#000000">141:</font>  -&gt; a <i><font color="#222222">-- ^ current sample</font></i>
<font color="#000000">142:</font>  -&gt; <b><font color="#000000">PL</font></b> a
<font color="#000000">143:</font> mh f q a = mLoop (mhStep f q) <font color="#000000">100</font>  $ a
<font color="#000000">144:</font> 
<font color="#000000">145:</font> <i><font color="#222222">-- | Construct a program to sample from an arbitrary distribution using MCMC</font></i>
<font color="#000000">146:</font> mhD :: <b><font color="#000000">MCMC</font></b> a =&gt; <b><font color="#000000">D</font></b> a -&gt; <b><font color="#000000">PL</font></b> a
<font color="#000000">147:</font> mhD (<b><font color="#000000">D</font></b> d) =
<font color="#000000">148:</font>     <b><u><font color="#000000">let</font></u></b>
<font color="#000000">149:</font>       scorer = (unP . d)
<font color="#000000">150:</font>       proposal <b><u><font color="#000000">_</font></u></b> = <b><u><font color="#000000">do</font></u></b>
<font color="#000000">151:</font>         f &lt;- sample01
<font color="#000000">152:</font>         return $ uniform2val f
<font color="#000000">153:</font>     <b><u><font color="#000000">in</font></u></b> mh scorer proposal arbitrary
<font color="#000000">154:</font> 
<font color="#000000">155:</font> 
<font color="#000000">156:</font> <i><font color="#222222">-- | Run the probabilistic value to get a sample</font></i>
<font color="#000000">157:</font> sample :: <b><font color="#000000">RandomGen</font></b> g =&gt; g -&gt; <b><font color="#000000">PL</font></b> a -&gt; (a, g)
<font color="#000000">158:</font> sample g (<b><font color="#000000">Ret</font></b> a) = (a, g)
<font color="#000000">159:</font> sample g (<b><font color="#000000">Sample01</font></b> f2plnext) = <b><u><font color="#000000">let</font></u></b> (f, g') = random g in sample g' (f2plnext f)
<font color="#000000">160:</font> 
<font color="#000000">161:</font> 
<font color="#000000">162:</font> <i><font color="#222222">-- | Sample n values from the distribution</font></i>
<font color="#000000">163:</font> samples :: <b><font color="#000000">RandomGen</font></b> g =&gt; <b><font color="#000000">Int</font></b> -&gt; g -&gt; <b><font color="#000000">PL</font></b> a -&gt; ([a], g)
<font color="#000000">164:</font> samples <font color="#000000">0</font> g <b><u><font color="#000000">_</font></u></b> = ([], g)
<font color="#000000">165:</font> samples n g pl = <b><u><font color="#000000">let</font></u></b> (a, g') = sample g pl
<font color="#000000">166:</font>                      (as, g'') = samples (n - 1) g' pl
<font color="#000000">167:</font>                  <b><u><font color="#000000">in</font></u></b> (a:as, g'')
<font color="#000000">168:</font> 
<font color="#000000">169:</font> <i><font color="#222222">-- | count fraction of times value occurs in list</font></i>
<font color="#000000">170:</font> occurFrac :: (<b><font color="#000000">Eq</font></b> a) =&gt; [a] -&gt; a -&gt; <b><font color="#000000">Float</font></b>
<font color="#000000">171:</font> occurFrac as a =
<font color="#000000">172:</font>     <b><u><font color="#000000">let</font></u></b> noccur = length (filter (==a) as)
<font color="#000000">173:</font>         n = length as
<font color="#000000">174:</font>     <b><u><font color="#000000">in</font></u></b> (fromIntegral noccur) / (fromIntegral n)
<font color="#000000">175:</font> 
<font color="#000000">176:</font> <i><font color="#222222">-- | Produce a distribution from a PL by using the sampler to sample N times</font></i>
<font color="#000000">177:</font> distribution :: (<b><font color="#000000">Eq</font></b> a, <b><font color="#000000">Num</font></b> a, <b><font color="#000000">RandomGen</font></b> g) =&gt; <b><font color="#000000">Int</font></b> -&gt; g -&gt; <b><font color="#000000">PL</font></b> a -&gt; (<b><font color="#000000">D</font></b> a, g)
<font color="#000000">178:</font> distribution n g pl =
<font color="#000000">179:</font>     <b><u><font color="#000000">let</font></u></b> (as, g') = samples n g pl <b><u><font color="#000000">in</font></u></b> (<b><font color="#000000">D</font></b> (\a -&gt; <b><font color="#000000">P</font></b> (occurFrac as a)), g')
<font color="#000000">180:</font> 
<font color="#000000">181:</font> 
<font color="#000000">182:</font> <i><font color="#222222">-- | biased coin</font></i>
<font color="#000000">183:</font> coin :: <b><font color="#000000">Float</font></b> -&gt; <b><font color="#000000">PL</font></b> <b><font color="#000000">Int</font></b> <i><font color="#222222">-- 1 with prob. p1, 0 with prob. (1 - p1)</font></i>
<font color="#000000">184:</font> coin p1 = <b><u><font color="#000000">do</font></u></b>
<font color="#000000">185:</font>     <b><font color="#000000">Sample01</font></b> (\f -&gt; <b><font color="#000000">Ret</font></b> $ <b><u><font color="#000000">if</font></u></b> f &lt; p1 <b><u><font color="#000000">then</font></u></b> <font color="#000000">1</font> <b><u><font color="#000000">else</font></u></b> <font color="#000000">0</font>)
<font color="#000000">186:</font> 
<font color="#000000">187:</font> 
<font color="#000000">188:</font> <i><font color="#222222">-- | Create a histogram from values.</font></i>
<font color="#000000">189:</font> histogram :: <b><font color="#000000">Int</font></b> <i><font color="#222222">-- ^ number of buckets</font></i>
<font color="#000000">190:</font>           -&gt; [<b><font color="#000000">Float</font></b>] <i><font color="#222222">-- values</font></i>
<font color="#000000">191:</font>           -&gt; [<b><font color="#000000">Int</font></b>]
<font color="#000000">192:</font> histogram nbuckets as =
<font color="#000000">193:</font>     <b><u><font color="#000000">let</font></u></b>
<font color="#000000">194:</font>         minv :: <b><font color="#000000">Float</font></b>
<font color="#000000">195:</font>         minv = minimum as
<font color="#000000">196:</font>         maxv :: <b><font color="#000000">Float</font></b>
<font color="#000000">197:</font>         maxv = maximum as
<font color="#000000">198:</font>         <i><font color="#222222">-- value per bucket</font></i>
<font color="#000000">199:</font>         perbucket :: <b><font color="#000000">Float</font></b>
<font color="#000000">200:</font>         perbucket = (maxv - minv) / (fromIntegral nbuckets)
<font color="#000000">201:</font>         bucket :: <b><font color="#000000">Float</font></b> -&gt; <b><font color="#000000">Int</font></b>
<font color="#000000">202:</font>         bucket v = floor (v / perbucket)
<font color="#000000">203:</font>         bucketed :: M.<b><font color="#000000">Map</font></b> <b><font color="#000000">Int</font></b> <b><font color="#000000">Int</font></b>
<font color="#000000">204:</font>         bucketed = foldl (\m v -&gt; M.insertWith (+) (bucket v) <font color="#000000">1</font> m) mempty as
<font color="#000000">205:</font>      <b><u><font color="#000000">in</font></u></b> map snd . M.toList $ bucketed
<font color="#000000">206:</font> 
<font color="#000000">207:</font> 
<font color="#000000">208:</font> printSamples :: (<b><font color="#000000">Real</font></b> a, <b><font color="#000000">Eq</font></b> a, <b><font color="#000000">Ord</font></b> a, <b><font color="#000000">Show</font></b> a) =&gt; <b><font color="#000000">String</font></b> -&gt; [a] -&gt; <b><font color="#000000">IO</font></b> ()
<font color="#000000">209:</font> printSamples s as =  <b><u><font color="#000000">do</font></u></b>
<font color="#000000">210:</font>     putStrLn $ <font color="#808080">"***"</font> &lt;&gt; s
<font color="#000000">211:</font>     putStrLn $ <font color="#808080">"   samples: "</font> &lt;&gt; series2spark (map toRational as)
<font color="#000000">212:</font> 
<font color="#000000">213:</font> printHistogram :: [<b><font color="#000000">Float</font></b>] -&gt; <b><font color="#000000">IO</font></b> ()
<font color="#000000">214:</font> printHistogram samples = putStrLn $ series2spark (map fromIntegral . histogram <font color="#000000">10</font> $  samples)
<font color="#000000">215:</font> 
<font color="#000000">216:</font> 
<font color="#000000">217:</font> <i><font color="#222222">-- | Given a coin bias, take samples and print bias</font></i>
<font color="#000000">218:</font> printCoin :: <b><font color="#000000">Float</font></b> -&gt; <b><font color="#000000">IO</font></b> ()
<font color="#000000">219:</font> printCoin bias = <b><u><font color="#000000">do</font></u></b>
<font color="#000000">220:</font>     <b><u><font color="#000000">let</font></u></b> g = mkStdGen <font color="#000000">1</font>
<font color="#000000">221:</font>     <b><u><font color="#000000">let</font></u></b> (tosses, <b><u><font color="#000000">_</font></u></b>) = samples <font color="#000000">100</font> g (coin bias)
<font color="#000000">222:</font>     printSamples (<font color="#808080">"bias: "</font> &lt;&gt; show bias) tosses
<font color="#000000">223:</font> 
<font color="#000000">224:</font> 
<font color="#000000">225:</font> 
<font color="#000000">226:</font> <i><font color="#222222">-- | Create normal distribution as sum of uniform distributions.</font></i>
<font color="#000000">227:</font> normal :: <b><font color="#000000">PL</font></b> <b><font color="#000000">Float</font></b>
<font color="#000000">228:</font> normal =  fromIntegral . sum &lt;$&gt; (replicateM <font color="#000000">5</font> (coin <font color="#000000">0.5</font>))
<font color="#000000">229:</font> 
<font color="#000000">230:</font> 
<font color="#000000">231:</font> main :: <b><font color="#000000">IO</font></b> ()
<font color="#000000">232:</font> main = <b><u><font color="#000000">do</font></u></b>
<font color="#000000">233:</font>     printCoin <font color="#000000">0.01</font>
<font color="#000000">234:</font>     printCoin <font color="#000000">0.99</font>
<font color="#000000">235:</font>     printCoin <font color="#000000">0.5</font>
<font color="#000000">236:</font>     printCoin <font color="#000000">0.7</font>
<font color="#000000">237:</font> 
<font color="#000000">238:</font>     putStrLn $ <font color="#808080">"normal distribution using central limit theorem: "</font>
<font color="#000000">239:</font>     <b><u><font color="#000000">let</font></u></b> g = mkStdGen <font color="#000000">1</font>
<font color="#000000">240:</font>     <b><u><font color="#000000">let</font></u></b> (nsamples, <b><u><font color="#000000">_</font></u></b>) = samples <font color="#000000">1000</font> g normal
<font color="#000000">241:</font>     <i><font color="#222222">-- printSamples "normal: " nsamples</font></i>
<font color="#000000">242:</font>     printHistogram nsamples
<font color="#000000">243:</font> 
<font color="#000000">244:</font> 
<font color="#000000">245:</font>     putStrLn $ <font color="#808080">"normal distribution using MCMC: "</font>
<font color="#000000">246:</font>     <b><u><font color="#000000">let</font></u></b> (mcmcsamples, <b><u><font color="#000000">_</font></u></b>) = samples <font color="#000000">1000</font> g (mhD $  normalD <font color="#000000">0.5</font>)
<font color="#000000">247:</font>     printHistogram mcmcsamples
<font color="#000000">248:</font> 
<font color="#000000">249:</font>     putStrLn $ <font color="#808080">"sampling from x^4 with finite support"</font>
<font color="#000000">250:</font>     <b><u><font color="#000000">let</font></u></b> (mcmcsamples, <b><u><font color="#000000">_</font></u></b>) = samples <font color="#000000">1000</font> g (mhD $  polyD <font color="#000000">4</font>)
<font color="#000000">251:</font>     printHistogram mcmcsamples
<font color="#000000">252:</font> </tt></pre>
</div>

<h4><a id=output href='#output'> § </a> Output</h4>
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> ***bias: 1.0e-2
<font color="#000000">03:</font>    samples: ________________________________________█_█________
<font color="#000000">04:</font> ***bias: 0.99
<font color="#000000">05:</font>    samples: ███████████████████████████████████████████████████
<font color="#000000">06:</font> ***bias: 0.5
<font color="#000000">07:</font>    samples: __█____█__███_███_█__█_█___█_█_██___████████__█_███
<font color="#000000">08:</font> ***bias: 0.7
<font color="#000000">09:</font>    samples: __█__█_█__███_█████__███_█_█_█_██_█_████████__█████
<font color="#000000">10:</font> normal distribution using central limit theorem:
<font color="#000000">11:</font> _▄▇█▄_
<font color="#000000">12:</font> normal distribution using MCMC:
<font color="#000000">13:</font> __▁▄█▅▂▁___
<font color="#000000">14:</font> sampling from x^4 with finite support
<font color="#000000">15:</font> ▁▁▃▃▃▄▅▆▇█_
<font color="#000000">16:</font> 
<font color="#000000">17:</font> </tt></pre>
</div>

<h3><a id=the-smallest-implementation-of-reverse-mode-ad-autograd-ever href='#the-smallest-implementation-of-reverse-mode-ad-autograd-ever'> § </a> The smallest implementation of reverse mode AD (autograd) ever:</h3>
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> <i><font color="#222222">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</font></i>
<font color="#000000">03:</font> <b><u><font color="#000000">import</font></u></b> qualified Data.Map.<b><font color="#000000">Strict</font></b> as <b><font color="#000000">M</font></b>
<font color="#000000">04:</font> 
<font color="#000000">05:</font> <i><font color="#222222">-- | This file can be copy-pasted and will run!</font></i>
<font color="#000000">06:</font> 
<font color="#000000">07:</font> <i><font color="#222222">-- | Symbols</font></i>
<font color="#000000">08:</font> <b><u><font color="#000000">type</font></u></b> <b><font color="#000000">Sym</font></b> = <b><font color="#000000">String</font></b>
<font color="#000000">09:</font> <i><font color="#222222">-- | Environments</font></i>
<font color="#000000">10:</font> <b><u><font color="#000000">type</font></u></b> <b><font color="#000000">E</font></b> a = M.<b><font color="#000000">Map</font></b> <b><font color="#000000">Sym</font></b> a
<font color="#000000">11:</font> <i><font color="#222222">-- | Newtype to represent deriative values</font></i>
<font color="#000000">12:</font> <b><u><font color="#000000">type</font></u></b> <b><font color="#000000">F</font></b> = <b><font color="#000000">Float</font></b>
<font color="#000000">13:</font> <b><u><font color="#000000">newtype</font></u></b> <b><font color="#000000">Der</font></b> = <b><font color="#000000">Der</font></b> { under :: <b><font color="#000000">F</font></b> } <b><u><font color="#000000">deriving</font></u></b>(<b><font color="#000000">Show</font></b>, <b><font color="#000000">Num</font></b>)
<font color="#000000">14:</font> 
<font color="#000000">15:</font> <b><u><font color="#000000">infixl</font></u></b> <font color="#000000">7</font> !#
<font color="#000000">16:</font> <i><font color="#222222">-- | We are indexing the map at a "hash" (Sym)</font></i>
<font color="#000000">17:</font> (!#) :: <b><font color="#000000">E</font></b> a -&gt; <b><font color="#000000">Sym</font></b> -&gt; a
<font color="#000000">18:</font> (!#) = (M.!)
<font color="#000000">19:</font> 
<font color="#000000">20:</font> <i><font color="#222222">-- | A node in the computation graph</font></i>
<font color="#000000">21:</font> <b><u><font color="#000000">data</font></u></b> <b><font color="#000000">Node</font></b> =
<font color="#000000">22:</font>   <b><font color="#000000">Node</font></b> { name :: <b><font color="#000000">Sym</font></b> <i><font color="#222222">-- ^ Name of the node</font></i>
<font color="#000000">23:</font>        , ins :: [<b><font color="#000000">Node</font></b>] <i><font color="#222222">-- ^ inputs to the node</font></i>
<font color="#000000">24:</font>        , out :: <b><font color="#000000">E</font></b> <b><font color="#000000">F</font></b> -&gt; <b><font color="#000000">F</font></b> <i><font color="#222222">-- ^ output of the node</font></i>
<font color="#000000">25:</font>        , der :: (<b><font color="#000000">E</font></b> <b><font color="#000000">F</font></b>, <b><font color="#000000">E</font></b> (<b><font color="#000000">Sym</font></b> -&gt; <b><font color="#000000">Der</font></b>))
<font color="#000000">26:</font>                   -&gt; <b><font color="#000000">Sym</font></b> -&gt; <b><font color="#000000">Der</font></b> <i><font color="#222222">-- ^ derivative wrt to a name</font></i>
<font color="#000000">27:</font>        }
<font color="#000000">28:</font> 
<font color="#000000">29:</font> <i><font color="#222222">-- | @ looks like a "circle", which is a node. So we are indexing the map</font></i>
<font color="#000000">30:</font> <i><font color="#222222">-- at a node.</font></i>
<font color="#000000">31:</font> (!@) :: <b><font color="#000000">E</font></b> a -&gt; <b><font color="#000000">Node</font></b> -&gt; a
<font color="#000000">32:</font> (!@) e node = e M.! (name node)
<font color="#000000">33:</font> 
<font color="#000000">34:</font> <i><font color="#222222">-- | Given the current environments of values and derivatives, compute</font></i>
<font color="#000000">35:</font> <i><font color="#222222">-- | The new value and derivative for a node.</font></i>
<font color="#000000">36:</font> run_ :: (<b><font color="#000000">E</font></b> <b><font color="#000000">F</font></b>, <b><font color="#000000">E</font></b> (<b><font color="#000000">Sym</font></b> -&gt; <b><font color="#000000">Der</font></b>)) -&gt; <b><font color="#000000">Node</font></b> -&gt; (<b><font color="#000000">E</font></b> <b><font color="#000000">F</font></b>, <b><font color="#000000">E</font></b> (<b><font color="#000000">Sym</font></b> -&gt; <b><font color="#000000">Der</font></b>))
<font color="#000000">37:</font> run_ ein (<b><font color="#000000">Node</font></b> name ins out der) =
<font color="#000000">38:</font>   <b><u><font color="#000000">let</font></u></b> (e', ed') = foldl run_ ein ins <i><font color="#222222">-- run all the inputs</font></i>
<font color="#000000">39:</font>       v = out e' <i><font color="#222222">-- compute the output</font></i>
<font color="#000000">40:</font>       dv = der (e', ed') <i><font color="#222222">-- and the derivative</font></i>
<font color="#000000">41:</font>   <b><u><font color="#000000">in</font></u></b> (M.insert name v e', M.insert name dv ed')  <i><font color="#222222">-- and insert them</font></i>
<font color="#000000">42:</font> 
<font color="#000000">43:</font> <i><font color="#222222">-- | Run the program given a node</font></i>
<font color="#000000">44:</font> run :: <b><font color="#000000">E</font></b> <b><font color="#000000">F</font></b> -&gt; <b><font color="#000000">Node</font></b> -&gt; (<b><font color="#000000">E</font></b> <b><font color="#000000">F</font></b>, <b><font color="#000000">E</font></b> (<b><font color="#000000">Sym</font></b> -&gt; <b><font color="#000000">Der</font></b>))
<font color="#000000">45:</font> run e n = run_ (e, mempty) n
<font color="#000000">46:</font> 
<font color="#000000">47:</font> <i><font color="#222222">-- | Let's build nodes</font></i>
<font color="#000000">48:</font> nconst :: <b><font color="#000000">Sym</font></b> -&gt; <b><font color="#000000">F</font></b> -&gt; <b><font color="#000000">Node</font></b>
<font color="#000000">49:</font> nconst n f = <b><font color="#000000">Node</font></b> n [] (\<b><u><font color="#000000">_</font></u></b> -&gt; f) (\<b><u><font color="#000000">_</font></u></b> <b><u><font color="#000000">_</font></u></b> -&gt; <font color="#000000">0</font>)
<font color="#000000">50:</font> 
<font color="#000000">51:</font> <i><font color="#222222">-- | Variable</font></i>
<font color="#000000">52:</font> nvar :: <b><font color="#000000">Sym</font></b> -&gt; <b><font color="#000000">Node</font></b>
<font color="#000000">53:</font> nvar n = <b><font color="#000000">Node</font></b> n [] (!# n) (\<b><u><font color="#000000">_</font></u></b> n' -&gt; if n == n' <b><u><font color="#000000">then</font></u></b> <font color="#000000">1</font> <b><u><font color="#000000">else</font></u></b> <font color="#000000">0</font>)
<font color="#000000">54:</font> 
<font color="#000000">55:</font> <i><font color="#222222">-- | binary operation</font></i>
<font color="#000000">56:</font> nbinop :: (<b><font color="#000000">F</font></b> -&gt; <b><font color="#000000">F</font></b> -&gt; <b><font color="#000000">F</font></b>)  <i><font color="#222222">-- ^ output computation from inputs</font></i>
<font color="#000000">57:</font>  -&gt; (<b><font color="#000000">F</font></b> -&gt; <b><font color="#000000">Der</font></b> -&gt; <b><font color="#000000">F</font></b> -&gt; <b><font color="#000000">Der</font></b> -&gt; <b><font color="#000000">Der</font></b>) <i><font color="#222222">-- ^ derivative computation from outputs</font></i>
<font color="#000000">58:</font>  -&gt; <b><font color="#000000">Sym</font></b> <i><font color="#222222">-- ^ Name</font></i>
<font color="#000000">59:</font>  -&gt; (<b><font color="#000000">Node</font></b>, <b><font color="#000000">Node</font></b>) <i><font color="#222222">-- ^ input nodes</font></i>
<font color="#000000">60:</font>  -&gt; <b><font color="#000000">Node</font></b>
<font color="#000000">61:</font> nbinop f df n (in1, in2) =
<font color="#000000">62:</font>   <b><font color="#000000">Node</font></b> { name = n
<font color="#000000">63:</font>        , ins = [in1, in2]
<font color="#000000">64:</font>        , out = \e -&gt; f (e !# name in1) (e !# name in2)
<font color="#000000">65:</font>        , der = \(e, ed) n' -&gt;
<font color="#000000">66:</font>                  <b><u><font color="#000000">let</font></u></b> (name1, name2) = (name in1, name in2)
<font color="#000000">67:</font>                      (v1, v2) = (e !# name1, e !# name2)
<font color="#000000">68:</font>                      (dv1, dv2) = (ed !# name1 $ n', ed !# name2 $ n')
<font color="#000000">69:</font>                      <b><u><font color="#000000">in</font></u></b> df v1 dv1 v2 dv2
<font color="#000000">70:</font>        }
<font color="#000000">71:</font> 
<font color="#000000">72:</font> nadd :: <b><font color="#000000">Sym</font></b> -&gt; (<b><font color="#000000">Node</font></b>, <b><font color="#000000">Node</font></b>) -&gt; <b><font color="#000000">Node</font></b>
<font color="#000000">73:</font> nadd = nbinop (+) (\v dv v' dv' -&gt; dv + dv')
<font color="#000000">74:</font> 
<font color="#000000">75:</font> nmul :: <b><font color="#000000">Sym</font></b> -&gt; (<b><font color="#000000">Node</font></b>, <b><font color="#000000">Node</font></b>) -&gt; <b><font color="#000000">Node</font></b>
<font color="#000000">76:</font> nmul = nbinop (*) (\v (<b><font color="#000000">Der</font></b> dv) v' (Der dv') -&gt; <b><font color="#000000">Der</font></b> $ (v*dv') + (v'*dv))
<font color="#000000">77:</font> 
<font color="#000000">78:</font> main :: <b><font color="#000000">IO</font></b> ()
<font color="#000000">79:</font> main = <b><u><font color="#000000">do</font></u></b>
<font color="#000000">80:</font>   <b><u><font color="#000000">let</font></u></b> x = nvar <font color="#808080">"x"</font> :: <b><font color="#000000">Node</font></b>
<font color="#000000">81:</font>   <b><u><font color="#000000">let</font></u></b> y = nvar <font color="#808080">"y"</font>
<font color="#000000">82:</font>   <b><u><font color="#000000">let</font></u></b> xsq = nmul <font color="#808080">"xsq"</font> (x, x)
<font color="#000000">83:</font>   <b><u><font color="#000000">let</font></u></b> ten = nconst <font color="#808080">"10"</font> <font color="#000000">10</font>
<font color="#000000">84:</font>   <b><u><font color="#000000">let</font></u></b> xsq_plus_10 = nadd <font color="#808080">"xsq_plus_10"</font> (xsq, ten)
<font color="#000000">85:</font>   <b><u><font color="#000000">let</font></u></b> xsq_plus_10_plus_y = nadd <font color="#808080">"xsq_plus_10_plus_y"</font>  (xsq_plus_10, y)
<font color="#000000">86:</font>   <b><u><font color="#000000">let</font></u></b> (e, de) = run (M.fromList $ [(<font color="#808080">"x"</font>, <font color="#000000">2.0</font>), (<font color="#808080">"y"</font>, <font color="#000000">3.0</font>)]) xsq_plus_10_plus_y
<font color="#000000">87:</font>   putStrLn $ show e
<font color="#000000">88:</font>   putStrLn $ show $ de !@ xsq_plus_10_plus_y $ <font color="#808080">"x"</font>
<font color="#000000">89:</font>   putStrLn $ show $ de !@ xsq_plus_10_plus_y $ <font color="#808080">"y"</font>
<font color="#000000">90:</font> </tt></pre>
</div>

Yeah, in ~80 lines of code, you can basically build an autograd engine. Isn't
haskell so rad?
<h3><a id=timings-of-passes-in-ghc-and-low-hanging-fruit-in-the-backend href='#timings-of-passes-in-ghc-and-low-hanging-fruit-in-the-backend'> § </a> Timings of passes in GHC, and low hanging fruit in the backend:</h3>
<ul>
<li>
 One can use <code>-v3</code> to get pass timings.
</li>
<li>
 Apparently, GHC spends a lot of time in the simplifier, and time
  spend in the backend is peanuts in comparison to this.
</li>

</ul>

To quote <code>AndreasK</code>:
<blockquote> - Register allocation, common block elimination, block layout and pretty printing are the "slow" things in the backend as far as I remember. - There are also a handful of TODO's in the x86 codegen which still apply. So you can try to grep for these. - Strength reduction for division by a constant</blockquote>
<ul>
<li>
 <a href=https://gitlab.haskell.org/ghc/ghc/issues/9041>
NCG generates slow loop code</a>

</li>

</ul>

<h3><a id=ghctestsuitetestsrtst7160hs href='#ghctestsuitetestsrtst7160hs'> § </a> Varargs in GHC: <code>ghc/testsuite/tests/rts/T7160.hs</code></h3>
A comment from this test case tells us why the function <code>debugBelch2</code> exists:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> ghc/testsuite/tests/rts/T7160.hs
<font color="#000000">3:</font> <i><font color="#222222">-- Don't use debugBelch() directly, because we cannot call varargs functions</font></i>
<font color="#000000">4:</font> <i><font color="#222222">-- using the FFI (doing so produces a segfault on 64-bit Linux, for example).</font></i>
<font color="#000000">5:</font> <i><font color="#222222">-- See Debug.Trace.traceIO, which also uses debugBelch2.</font></i>
<font color="#000000">6:</font> foreign <b><u><font color="#000000">import</font></u></b> ccall <font color="#808080">"&amp;debugBelch2"</font> fun :: <b><font color="#000000">FunPtr</font></b> (<b><font color="#000000">Ptr</font></b> () -&gt; <b><font color="#000000">Ptr</font></b> () -&gt; <b><font color="#000000">IO</font></b> ())
<font color="#000000">7:</font> </tt></pre>
</div>

The implementation is:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> ghc/libraries/base/cbits/PrelIOUtils.c
<font color="#000000">3:</font> 
<font color="#000000">4:</font> <b><font color="#000000">void</font></b> debugBelch2(<b><u><font color="#000000">const</font></u></b> <b><font color="#000000">char</font></b>*s, <b><font color="#000000">char</font></b> *t)
<font color="#000000">5:</font> {
<font color="#000000">6:</font>     debugBelch(s,t);
<font color="#000000">7:</font> }
<font color="#000000">8:</font> </tt></pre>
</div>

<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> ghc/rts/RtsMessages.c
<font color="#000000">03:</font> 
<font color="#000000">04:</font> RtsMsgFunction *debugMsgFn  = rtsDebugMsgFn;
<font color="#000000">05:</font> ...
<font color="#000000">06:</font> 
<font color="#000000">07:</font> void
<font color="#000000">08:</font> debugBelch(const char*s, ...)
<font color="#000000">09:</font> {
<font color="#000000">10:</font>   va_list ap;
<font color="#000000">11:</font>   va_start(ap,s);
<font color="#000000">12:</font>   (*debugMsgFn)(s,ap);
<font color="#000000">13:</font>   va_end(ap);
<font color="#000000">14:</font> }
<font color="#000000">15:</font> </tt></pre>
</div>

<h3><a id=debugging-debug-info-in-ghc href='#debugging-debug-info-in-ghc'> § </a> <a href=#debugging-debug-info-in-GHC>
Debugging debug info in GHC</a>
</h3>
I wanted to use debug info to help build a better debugging experience
within <a href=http://github.com/tweag/asterius>
<code>tweag/asterius</code></a>
. So, I was
reading through the sources of <code>cmm/Debug.hs</code>.
I'd never considered how to debug debug-info, and I found the information
tucked inside a cute note in GHC (<code>Note [Debugging DWARF unwinding info]</code>):
<blockquote> This makes GDB produce a trace of its internal workings. Having gone this far, it's just a tiny step to run GDB in GDB. Make sure you install debugging symbols for gdb if you obtain it through a package manager.</blockquote>
<ul>
<li>
 <a href=https://github.com/ghc/ghc/blob/535a26c90f458801aeb1e941a3f541200d171e8f/compiler/cmm/Debug.hs#L458>
Link to GHC sources</a>

</li>

</ul>

<h3><a id=ghc-llvm-code-generator-switch-to-unreachable href='#ghc-llvm-code-generator-switch-to-unreachable'> § </a> <a href=#ghc-llvm-code-generator-switch-to-unreachable>
GHC LLVM code generator: Switch to unreachable</a>
</h3>
The <a href=https://github.com/ghc/ghc/blob/master/compiler/llvmGen/LlvmCodeGen/CodeGen.hs#L1102>
switch to out of range</a>

code generator switches to the first label. It should be more profitable
to switch to a <code>unreachable</code> block. That way, LLVM can take advantage of UB.
<h3><a id=concurrency-in-haskell href='#concurrency-in-haskell'> § </a> <a href=#concurrency-in-haskell>
Concurrency in Haskell</a>
</h3>
Great link to the GHC wiki that describes the concurrency primitives
"bottom up": https://gitlab.haskell.org/ghc/ghc/wikis/lightweight-concurrency
<h3><a id=handy-list-of-differential-geometry-definitions href='#handy-list-of-differential-geometry-definitions'> § </a> <a href=#handy-list-of-differential-geometry-definitions>
Handy list of differential geometry definitions</a>
</h3>
There are way too many objects in diffgeo, all of them subtly connected.
Here I catalogue all of the ones I have run across:
<h4><a id=manifold href='#manifold'> § </a> Manifold</h4>
A manifold <span class='latexinline'>
<span style="font-style:italic">M</span></span> of dimension <span class='latexinline'>
<span style="font-style:italic">n</span></span> is a topological space. So, there is a
topological structure <span class='latexinline'>
<span style="font-style:italic">T</span></span> on <span class='latexinline'>
<span style="font-style:italic">M</span></span>. There is also an <i>Atlas</i>, which is a family
of <i>Chart</i>s that satisfy some properties.
<h4><a id=chart href='#chart'> § </a> Chart</h4>
A chart is a pair <span class='latexinline'>
(<span style="font-style:italic">O</span> &#X2208; <span style="font-style:italic">T</span> , <span style="font-style:italic">cm</span>: <span style="font-style:italic">O</span> &#X2212;&gt; &#X211D;<sup><span style="font-style:italic">n</span></sup></span>. The <span class='latexinline'>
<span style="font-style:italic">O</span></span> is an open set of the
manifold, and <span class='latexinline'>
<span style="font-style:italic">cm</span></span> ("chart for "m") is a continuous mapping from <span class='latexinline'>
<span style="font-style:italic">O</span></span> to <span class='latexinline'>
&#X211D;<sup><span style="font-style:italic">n</span></sup></span>
under the subspace topology for <span class='latexinline'>
<span style="font-style:italic">U</span></span> and the standard topology for <span class='latexinline'>
&#X211D;<sup><span style="font-style:italic">n</span></sup></span>.
<h4><a id=atlas href='#atlas'> § </a>  Atlas</h4>
An <i>Atlas</i> is a collection of <i>Chart</i>s such that the charts cover the manifold,
and the charts are pairwise compatible. That is, <span class='latexinline'>
<span style="font-style:italic">A</span> = { (<span style="font-style:italic">U</span><sub><span style="font-style:italic">i</span></sub>, &#X3C6;<sub><span style="font-style:italic">i</span></sub>) }</span>, such
that <span class='latexinline'>
&#X222A;<span style="font-style:italic">i</span> <span style="font-style:italic">U</span><sub><span style="font-style:italic">i</span></sub> = <span style="font-style:italic">M</span></span>, and <span class='latexinline'>
&#X3C6;<sub><span style="font-style:italic">j</span></sub> &#X2218; <span style="font-style:italic">phi</span><sub><span style="font-style:italic">i</span></sub><sup>&#X2212;1</sup></span> is smooth.
<h4><a id=differentiable-map href='#differentiable-map'> § </a> Differentiable map</h4>
<span class='latexinline'>
<span style="font-style:italic">f</span>: <span style="font-style:italic">M</span> &#X2192; <span style="font-style:italic">N</span></span> be a mapping from an <span class='latexinline'>
<span style="font-style:italic">m</span></span> dimensional manifold to an <span class='latexinline'>
<span style="font-style:italic">n</span></span> dimensional
manifold. Let <span class='latexinline'>
<span style="font-style:italic">frep</span> = <span style="font-style:italic">cn</span> &#X2218; <span style="font-style:italic">f</span> &#X2218; <span style="font-style:italic">cm</span><sup>&#X2212;1</sup>: &#X211D;<sup><span style="font-style:italic">m</span></sup> &#X2212;&gt; &#X211D;<sup><span style="font-style:italic">n</span></sup></span>
where <span class='latexinline'>
<span style="font-style:italic">cm</span>: <span style="font-style:italic">M</span> &#X2192; &#X211D;<sup><span style="font-style:italic">m</span></sup></span> is a chart for <span class='latexinline'>
<span style="font-style:italic">M</span></span>, <span class='latexinline'>
<span style="font-style:italic">cn</span>: <span style="font-style:italic">N</span> &#X2192; &#X211D;<sup><span style="font-style:italic">n</span></sup></span>
is a chart for <span class='latexinline'>
<span style="font-style:italic">N</span></span>. <span class='latexinline'>
<span style="font-style:italic">frep</span></span> is <span class='latexinline'>
<span style="font-style:italic">f</span></span> represented
in local coordinates. If <span class='latexinline'>
<span style="font-style:italic">frep</span></span> is smooth for all choices of <span class='latexinline'>
<span style="font-style:italic">cm</span>, <span style="font-style:italic">cn</span></span>,
then <span class='latexinline'>
<span style="font-style:italic">f</span></span> is a differentiable map from <span class='latexinline'>
<span style="font-style:italic">M</span></span> to <span class='latexinline'>
<span style="font-style:italic">N</span></span>.
<h4><a id=curve href='#curve'> § </a> Curve:</h4>
Let <span class='latexinline'>
<span style="font-style:italic">I</span></span> be an open interval of <span class='latexinline'>
&#X211D;</span> which includes the point <code>0</code>.  A Curve is a
differentiable map <span class='latexinline'>
<span style="font-style:italic">C</span>: (<span style="font-style:italic">a</span>, <span style="font-style:italic">b</span>) &#X2192; <span style="font-style:italic">M</span></span> where <span class='latexinline'>
<span style="font-style:italic">a</span> &lt; 0 &lt; <span style="font-style:italic">b</span></span>.
<h4><a id=function-i-hate-this-term-i-prefer-something-like-valuation href='#function-i-hate-this-term-i-prefer-something-like-valuation'> § </a> Function: (I hate this term, I prefer something like Valuation):</h4>
A differentiable mapping from <span class='latexinline'>
<span style="font-style:italic">M</span></span> to <span class='latexinline'>
<span style="font-style:italic">R</span></span>.
<h4><a id=fnoted-as-to-a-curve-f-a-function- href='#fnoted-as-to-a-curve-f-a-function-'> § </a> Directional derivative of a function <code>f(m): M -> R</code> with respect to a curve <code>c(t): I -> M</code>, denoted as <code>c[f]</code>.</h4>
Let <code>g(t) = (f . c)(t) :: I -c-> M -f-> R = I -> R</code>.
This this is the value <code>dg/dt(t0) = (d (f . c) / dt) (0)</code>.
<h4><a id=tangent-vector-at-a-point- href='#tangent-vector-at-a-point-'> § </a> Tangent vector at a point <code>p</code>:</h4>
On a <code>m</code> dimensional manifold <code>M</code>, a tangent vector at a point <code>p</code> is an
equivalence class of curves that have <code>c(0) = p</code>, such that <code>c1(t) ~ c2(t)</code> iff
:
<ul>
<li>
 For a (all) charts <code>(O, ch)</code> such that <code>c1(0) ∈  O</code>, <code>d/dt (ch . c1: R -> R^m) = d/dt (ch . c2: R -> R^m)</code>.
</li>

</ul>
 That is, they have equal derivatives.
<h4><a id=mngent-space href='#mngent-space'> § </a> Tangent space(<code>TpM</code>):</h4>
The set of all tangent vectors at a point <code>p</code> forms a vector space <code>TpM</code>.
We prove this by creating a bijection from every curve to a vector <code>R^n</code>.
Let <code>(U, ch: U -> R)</code> be a chart around the point <code>p</code>, where <code>p ∈ U ⊆ M</code>. Now,
the bijection is defined as:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> forward: (I -&gt; M) -&gt; R^n
<font color="#000000">3:</font> forward(c) = d/dt (c . ch)
<font color="#000000">4:</font> 
<font color="#000000">5:</font> reverse: R^n -&gt; (I -&gt; M)
<font color="#000000">6:</font> reverse(v)(t) = ch^-1 (tv)
<font color="#000000">7:</font> </tt></pre>
</div>

<h4><a id=to-ual-space-of-the-tangent-space-space-of-all-linear-functions-from- href='#to-ual-space-of-the-tangent-space-space-of-all-linear-functions-from-'> § </a> Cotangent space(<code>TpM*</code>): dual space of the tangent space / Space of all linear functions from <code>TpM</code> to <code>R</code>.</h4>
<ul>
<li>
 Associated to every function <code>f</code>, there is a cotangent vector, colorfully
  called <code>df</code>. The definition is <code>df: TpM -> R</code>, <code>df(c: I -> M) = c[f]</code>. That is,
  given a curve <code>c</code>, we take the directional derivative of the function <code>f</code>
  along the curve <code>c</code>. We need to prove that this is constant for all vectors
  in the equivalence class and blah.
</li>

</ul>

<h4><a id=pushf-tpm--tpn href='#pushf-tpm--tpn'> § </a>  Pushforward <code>push(f): TpM -> TpN</code></h4>
Given a curve <code>c: I -> M</code>, the pushforward
is the curve <code>f . c : I -> N</code>. This extends to the equivalence classes
and provides us a way to move curves in <code>M</code> to curves in <code>N</code>, and thus
gives us a mapping from the tangent spaces.
This satisfies the identity:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> push(f)(v)[g] === v[g . f]
<font color="#000000">3:</font> </tt></pre>
</div>

<h4><a id=pullf-tpn--tpm href='#pullf-tpn--tpm'> § </a> Pullback <code>pull(f): TpN* -> TpM*</code></h4>
Given a linear functional <code>wn : TpN -> R</code>, the pullback is defined as
<code> wn . push(f) : TpM -> R</code>.
This satisfies the identity:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> (pull wn)(v) === wn (push v)
<font color="#000000">3:</font> (pull (wn : TpN-&gt;R): TpM-&gt;R) (v : TpM) : R  = (wn: TpN-&gt;R) (push (v: TpM): TpN) : R
<font color="#000000">4:</font> </tt></pre>
</div>

<h4><a id=vector-field-as-derivation href='#vector-field-as-derivation'> § </a> Vector field as derivation</h4>
TODO
<h4><a id=lie-derivation href='#lie-derivation'> § </a> Lie derivation</h4>
<h4><a id=lie-derivation-as-lie-bracket href='#lie-derivation-as-lie-bracket'> § </a> Lie derivation as lie bracket</h4>
<h3><a id=lazy-programs-have-space-leaks-strict-programs-have-time-leaks href='#lazy-programs-have-space-leaks-strict-programs-have-time-leaks'> § </a> <a href=#lazy-programs-have-space-leaks-strict-programs-have-time-leaks>
Lazy programs have space leaks, Strict programs have time leaks</a>
</h3>
Stumbled across this idea while reading some posts on a private discourse.
<ul>
<li>
 Continually adding new thunks without forcing them can lead to a space leak,
  aka the dreaded monadic parsing backtracking problem.
</li>

</ul>

<ul>
<li>
 Continually <i>running</i> new thunks can lead to a "time leak", where we spend
  far too much time running things that should not be run in the first place!
</li>

</ul>

This is an interesting perspective that I've never seen articulated before, and
somehow helps make space leaks feel more... palatable? Before, I had no
analogue to a space leak in the strict world, so I saw them as a pathology. But
with this new perspective, I can see that the strict world's version of a space
leak is a time leak.
<h3><a id=presburger-arithmetic-can-represent-the-collatz-conjecture href='#presburger-arithmetic-can-represent-the-collatz-conjecture'> § </a> <a href=#presburger-arithmetic-can-represent-the-collatz-conjecture>
Presburger arithmetic can represent the Collatz Conjecture</a>
</h3>
An observation I had: the function
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> f(x) = x/2      if (x % 2 == 0)
<font color="#000000">3:</font> f(x) = 3x + 1   otherwise
<font color="#000000">4:</font> </tt></pre>
</div>

is a Presburger function, so by building better approximations to the
transitive closure of a presburger function, one could get better answers
to the Collatz conjecture. Unfortunately, ISL (the integer set library) of today
is not great against the formidable foe.
The code:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> <b><u><font color="#000000">#include</font></u></b> <font color="#808080">&lt;isl/set.h&gt;</font>
<font color="#000000">03:</font> <b><u><font color="#000000">#include</font></u></b> <font color="#808080">&lt;isl/version.h&gt;</font>
<font color="#000000">04:</font> <b><u><font color="#000000">#include</font></u></b> <font color="#808080">&lt;isl/map.h&gt;</font>
<font color="#000000">05:</font> <b><u><font color="#000000">#include</font></u></b> <font color="#808080">&lt;isl/aff.h&gt;</font>
<font color="#000000">06:</font> <b><u><font color="#000000">#include</font></u></b> <font color="#808080">&lt;isl/local_space.h&gt;</font>
<font color="#000000">07:</font> <b><u><font color="#000000">#include</font></u></b> <font color="#808080">&lt;isl/constraint.h&gt;</font>
<font color="#000000">08:</font> <b><u><font color="#000000">#include</font></u></b> <font color="#808080">&lt;isl/space.h&gt;</font>
<font color="#000000">09:</font> 
<font color="#000000">10:</font> <b><font color="#000000">int</font></b> main() {
<font color="#000000">11:</font>     isl_ctx *ctx = isl_ctx_alloc();
<font color="#000000">12:</font>     <b><u><font color="#000000">const</font></u></b> <b><font color="#000000">char</font></b> *s = <font color="#808080">"{ [x] -&gt; [x / 2] : x % 2 = 0; [x] -&gt; [3 * x + 1] : x % 2 = 1}"</font>;
<font color="#000000">13:</font> 
<font color="#000000">14:</font>     isl_map *m = isl_map_read_from_str(ctx, s);
<font color="#000000">15:</font> 
<font color="#000000">16:</font>     isl_map_dump(m);
<font color="#000000">17:</font> 
<font color="#000000">18:</font>     isl_bool b;
<font color="#000000">19:</font>     isl_map *p = isl_map_transitive_closure(m, &amp;b);
<font color="#000000">20:</font>     printf(<font color="#808080">"exact: %d</font>\n<font color="#808080">"</font>, b);
<font color="#000000">21:</font>     printf(<font color="#808080">"map:</font>\n<font color="#808080">"</font>);
<font color="#000000">22:</font>     isl_map_dump(p);
<font color="#000000">23:</font> 
<font color="#000000">24:</font> }
<font color="#000000">25:</font> </tt></pre>
</div>

Produces the somewhat disappointing, and yet expected output:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> $ clang bug.c -lisl -Lisl-0.20/.libs -o bug -I/usr/local/include/
<font color="#000000">3:</font> $ ./bug
<font color="#000000">4:</font> { [x] -&gt; [o0] : 2o0 = x or (exists (e0 = floor((1 + x)/2): o0 = 1 + 3x and 2e0 = 1 + x)) }
<font color="#000000">5:</font> exact: 0
<font color="#000000">6:</font> map:
<font color="#000000">7:</font> { [x] -&gt; [o0] }
<font color="#000000">8:</font> </tt></pre>
</div>

I find it odd that it is unable to prove <i>anything</i> about the image, even that
it is non-negative, for example. This is an interesting direction in which
to improve the functions <code>isl_map_power</code> and <code>isl_map_transitive_closure</code>
though.
<h3><a id=using-compactness-to-argue-about-covers href='#using-compactness-to-argue-about-covers'> § </a> <a href=#using-compactness-to-argue-about-covers>
Using compactness to argue about covers</a>
</h3>
I've always seen compactness be used by <i>starting</i> with a possibly infinite
coverm and then <i>filtering it</i> into a finite subcover. This finite
subcover is then used for finiteness properties (like summing, min, max, etc.).
I recently ran across a use of compactness when one <i>starts</i> with the set
of <i>all possible subcovers</i>, and then argues about why a cover cannot be built
from these subcovers if the set is compact. I found it to be a very cool
use of compactness, which I'll record below:
<h4><a id=theorem href='#theorem'> § </a> Theorem:</h4>
If a family of compact, countably infinite sets <code>S_a</code> have all
<i>finite intersections</i> non-empty, then the intersection of the family <code>S_a</code>
is non-empty.
<h4><a id=proof href='#proof'> § </a> Proof:</h4>
Let <code>S = intersection of S_a</code>. We know that <code>S</code> must be compact since
all the <code>S_a</code> are compact, and the intersection of a countably infinite
number of compact sets is compact.
Now, let <code>S</code> be empty. Therefore, this means there must be a point <code>p ∈ P</code>
such that <code>p !∈ S_i</code> for some arbitrary <code>i</code>.
<h4><a id=cool-use-of-theorem href='#cool-use-of-theorem'> § </a> Cool use of theorem:</h4>
We can see that the cantor set is non-empty, since it contains a family
of closed and bounded sets <code>S1, S2, S3, ...</code> such that  <code>S1 ⊇ S2 ⊇ S3 ...</code>
where each <code>S_i</code> is one step of the cantor-ification. We can now see
that the cantor set is non-empty, since:
<ol>
<li>
 Each finite intersection is non-empty, and will be equal to the set that
   has the highest index in the finite intersection.
</li>
<li>
 Each of the sets <code>Si</code> are compact since they are closed and bounded subsets of <code>R</code>
</li>
<li>
 Invoke theorem.
</li>

</ol>

<h3><a id=japanese-financial-counting-system href='#japanese-financial-counting-system'> § </a> <a href=#japanese-financial-counting-system>
Japanese Financial Counting system</a>
</h3>
<ul>
<li>
 <a href=https://en.wikipedia.org/wiki/Japanese_numerals#Formal_numbers>
Wikipedia</a>

</li>

</ul>

Japanese contains a separate kanji set called <code>daiji</code>, to prevent people
from adding strokes to stuff previously written.
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> ##  |Common |Formal
<font color="#000000">3:</font> 1  |一     |壱
<font color="#000000">4:</font> 2  |二     |弐
<font color="#000000">5:</font> 3  |三     |参
<font color="#000000">6:</font> </tt></pre>
</div>

<h3><a id=stephen-wolframs-live-stream href='#stephen-wolframs-live-stream'> § </a> <a href=#stephen-wolframs-live-stream>
Stephen wolfram's live stream</a>
</h3>
<ul>
<li>
 <a href=https://www.twitch.tv/videos/408653972>
Twitch.tv link</a>

</li>

</ul>

I've taken to watching the live stream when I have some downtime and want
some interesting content.
The discussions of Wolfram with his group are great, and they bring up
<i>really</i> interesting ideas (like that of cleave being very irregular).
<h3><a id=as-a-word-has-some-of-the-most-irregular-inflections href='#as-a-word-has-some-of-the-most-irregular-inflections'> § </a> <a href=#cleave-as-a-word-has-some-of-the-most-irregular-inflections>
<code>Cleave</code> as a word has some of the most irregular inflections</a>
</h3>
<ul>
<li>
 cleave
</li>
<li>
 clove
</li>
<li>
 cleaved
</li>
<li>
 clave
</li>
<li>
 cleft
</li>

</ul>

<h3><a id=mccunes-single-axiom-for-group-theory href='#mccunes-single-axiom-for-group-theory'> § </a> <a href=#mccunes-single-axiom-for-group-theory>
McCune's single axiom for group theory</a>
</h3>
<a href=http://ftp.mcs.anl.gov/pub/tech_reports/reports/P270.pdf>
Single Axioms for Groups and Abelian Groups with Various Operations</a>

provides a single axiom for groups. This can be useful for some ideas I have
for training groups, where we can use this axiom as the loss function!
<h3><a id=c-code-implements-gradient-descent-really-weirdly href='#c-code-implements-gradient-descent-really-weirdly'> § </a> <code>Word2Vec</code> C code implements gradient descent really weirdly</h3>
I'll be posting snippets of the original source code, along with a
link to the Github sources. We are interested in exploring the skip-gram
implementation of Word2Vec, with negative sampling, without hierarchical
softmax. I assume basic familiarity with word embeddings and the skip-gram
model.
<h4><a id=construction-of-the-sigmoid-lookup-table href='#construction-of-the-sigmoid-lookup-table'> § </a> Construction of the sigmoid lookup table</h4>
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> <i><font color="#222222">// https://github.com/tmikolov/word2vec/blob/master/word2vec.c#L708</font></i>
<font color="#000000">03:</font> 
<font color="#000000">04:</font> expTable = (real *)malloc((EXP_TABLE_SIZE + <font color="#000000">1</font>) * <b><u><font color="#000000">sizeof</font></u></b>(real));
<font color="#000000">05:</font> <b><u><font color="#000000">for</font></u></b> (i = <font color="#000000">0</font>; i &lt; EXP_TABLE_SIZE; i++) {
<font color="#000000">06:</font>   expTable[i] = exp((i / (real)EXP_TABLE_SIZE * <font color="#000000">2</font> - <font color="#000000">1</font>) *
<font color="#000000">07:</font>                     MAX_EXP);  <i><font color="#222222">// Precompute the exp() table</font></i>
<font color="#000000">08:</font>   expTable[i] =
<font color="#000000">09:</font>       expTable[i] / (expTable[i] + <font color="#000000">1</font>);  <i><font color="#222222">// Precompute f(x) = x / (x + 1)</font></i>
<font color="#000000">10:</font> }
<font color="#000000">11:</font> </tt></pre>
</div>

Here, the code constructs a lookup table which maps <code>[0...EXP_TABLE_SIZE-1]</code>
to <code>[sigmoid(-MAX_EXP)...sigmoid(MAX_EXP)]</code>. The index <code>i</code> first gets mapped
to <code>(i / EXP_TABLE_SIZE) * 2 - 1</code>, which sends <code>0</code> to <code>-1</code> and <code>EXP_TABLE_SIZE</code>
to <code>1</code>. This is then rescaled by <code>MAX_EXP</code>.
<h4><a id=layer-initialization href='#layer-initialization'> § </a> Layer initialization</h4>
<ul>
<li>
 <code>syn0</code> is a global variable, initialized with random weights in the range of
  <code>[-0.5...0.5]</code>. It has dimensions <code>VOCAB x HIDDEN</code>.  This layer holds the
   hidden representations of word vectors.
</li>

</ul>

<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> <i><font color="#222222">// https://github.com/imsky/word2vec/blob/master/word2vec.c#L341</font></i>
<font color="#000000">03:</font> a = posix_memalign((<b><font color="#000000">void</font></b> **)&amp;syn0, <font color="#000000">128</font>,
<font color="#000000">04:</font>                (<b><font color="#000000">long</font></b> <b><font color="#000000">long</font></b>)vocab_size * layer1_size * <b><u><font color="#000000">sizeof</font></u></b>(real));
<font color="#000000">05:</font> ...
<font color="#000000">06:</font> 
<font color="#000000">07:</font> <i><font color="#222222">// https://github.com/imsky/word2vec/blob/master/word2vec.c#L355</font></i>
<font color="#000000">08:</font> <b><u><font color="#000000">for</font></u></b> (a = <font color="#000000">0</font>; a &lt; vocab_size; a++)
<font color="#000000">09:</font>         <b><u><font color="#000000">for</font></u></b> (b = <font color="#000000">0</font>; b &lt; layer1_size; b++) {
<font color="#000000">10:</font>             next_random = next_random * (<b><font color="#000000">unsigned</font></b> <b><font color="#000000">long</font></b> <b><font color="#000000">long</font></b>)<font color="#000000">25214903917</font> + <font color="#000000">11</font>;
<font color="#000000">11:</font>             syn0[a * layer1_size + b] =
<font color="#000000">12:</font>                 (((next_random &amp; <font color="#000000">0xFFFF</font>) / (real)<font color="#000000">65536</font>) - <font color="#000000">0.5</font>) / layer1_size;
<font color="#000000">13:</font>         }
<font color="#000000">14:</font> </tt></pre>
</div>

<ul>
<li>
 <code>syn1neg</code> is a global variable that is zero-initialized. It has dimensions
  <code>VOCAB x HIDDEN</code>. This layer also holds hidden representations of word vectors,
  <i>when they are used as a negative sample</i>.
</li>

</ul>

<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> <i><font color="#222222">// https://github.com/imsky/word2vec/blob/master/word2vec.c#L350</font></i>
<font color="#000000">3:</font> a = posix_memalign((<b><font color="#000000">void</font></b> **)&amp;syn1neg, <font color="#000000">128</font>,
<font color="#000000">4:</font>                    (<b><font color="#000000">long</font></b> <b><font color="#000000">long</font></b>)vocab_size * layer1_size * <b><u><font color="#000000">sizeof</font></u></b>(real));
<font color="#000000">5:</font> ...
<font color="#000000">6:</font> <b><u><font color="#000000">for</font></u></b> (a = <font color="#000000">0</font>; a &lt; vocab_size; a++)
<font color="#000000">7:</font>     <b><u><font color="#000000">for</font></u></b> (b = <font color="#000000">0</font>; b &lt; layer1_size; b++) syn1neg[a * layer1_size + b] = <font color="#000000">0</font>;
<font color="#000000">8:</font> </tt></pre>
</div>

<ul>
<li>
 <code>neu1e</code> is a temporary per-thread buffer (Remember that the <code>word2vec</code> C code
  use CPU threads for parallelism) which is zero initialized. It has dimensions
  <code>1 x HIDDEN</code>.
</li>

</ul>

<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> <i><font color="#222222">// https://github.com/imsky/word2vec/blob/master/word2vec.c#L370</font></i>
<font color="#000000">3:</font> real *neu1e = (real *)calloc(layer1_size, <b><u><font color="#000000">sizeof</font></u></b>(real));
<font color="#000000">4:</font> </tt></pre>
</div>

<h4><a id=backpropogation href='#backpropogation'> § </a> Backpropogation</h4>
Throughout <code>word2vec</code>, no 2D arrays are used. Indexing of the form
<code>arr[word][ix]</code> is manually written as <code>arr[word * layer1_size + ix]</code>. So, I
will call <code>word * layer1_size</code> as the "base address", and <code>ix</code> as the "offset
of the array index expression henceforth.
Here, <code>l1</code> is the base address of the word at the center of window (the focus
word).  <code>l2</code> is the base address of either the word that is negative sampled
from the corpus, or the word that is a positive sample from within the context
window.
<code>label</code> tells us whether the sample is a positive or a negative sample.
<code>label = 1</code> for positive samples, and <code>label = 0</code> for negative samples.
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> <i><font color="#222222">// zero initialize neu1e</font></i>
<font color="#000000">03:</font> <i><font color="#222222">// https://github.com/imsky/word2vec/blob/master/word2vec.c#L419</font></i>
<font color="#000000">04:</font> <b><u><font color="#000000">for</font></u></b> (c = <font color="#000000">0</font>; c &lt; layer1_size; c++) neu1e[c] = <font color="#000000">0</font>;
<font color="#000000">05:</font> ...
<font color="#000000">06:</font> <i><font color="#222222">// loop through each negative sample</font></i>
<font color="#000000">07:</font> <i><font color="#222222">// https://github.com/imsky/word2vec/blob/master/word2vec.c#L508</font></i>
<font color="#000000">08:</font> <b><u><font color="#000000">if</font></u></b> (negative &gt; <font color="#000000">0</font>)  <b><u><font color="#000000">for</font></u></b> (d = <font color="#000000">0</font>; d &lt; negative + <font color="#000000">1</font>; d++) {
<font color="#000000">09:</font>   ...
<font color="#000000">10:</font>   <i><font color="#222222">// https://github.com/imsky/word2vec/blob/master/word2vec.c#L521</font></i>
<font color="#000000">11:</font>   <i><font color="#222222">// take the dot product: f=  syn0[focus] . syn1neg[context]</font></i>
<font color="#000000">12:</font>   <b><u><font color="#000000">for</font></u></b> (c = <font color="#000000">0</font>; c &lt; layer1_size; c++) f += syn0[c + l1] * syn1neg[c + l2];
<font color="#000000">13:</font> 
<font color="#000000">14:</font>   <i><font color="#222222">// compute: g = (label - sigmoid(2f - 1)) * alpha</font></i>
<font color="#000000">15:</font>   <i><font color="#222222">// g is computed using lookups into a lookup table and clamping for</font></i>
<font color="#000000">16:</font>   <i><font color="#222222">// efficiency.</font></i>
<font color="#000000">17:</font>   <b><u><font color="#000000">if</font></u></b> (f &gt; MAX_EXP) g = (label - <font color="#000000">1</font>) * alpha;
<font color="#000000">18:</font>   <b><u><font color="#000000">else</font></u></b> <b><u><font color="#000000">if</font></u></b> (f &lt; -MAX_EXP) g = (label - <font color="#000000">0</font>) * alpha;
<font color="#000000">19:</font>   <b><u><font color="#000000">else</font></u></b>
<font color="#000000">20:</font>   g = (label - expTable[(<b><font color="#000000">int</font></b>)((f + MAX_EXP) *
<font color="#000000">21:</font>                               (EXP_TABLE_SIZE /
<font color="#000000">22:</font>                                MAX_EXP / <font color="#000000">2</font>))]) * alpha;
<font color="#000000">23:</font>   <i><font color="#222222">// Now that we have computed the gradient:</font></i>
<font color="#000000">24:</font>   <i><font color="#222222">// `g = (label - output) * learningrate`,</font></i>
<font color="#000000">25:</font>   <i><font color="#222222">// we need to perform backprop. This is where the code gets weird.</font></i>
<font color="#000000">26:</font> 
<font color="#000000">27:</font>   <b><u><font color="#000000">for</font></u></b> (c = <font color="#000000">0</font>; c &lt; layer1_size; c++) neu1e[c] += g * syn1neg[c + l2];
<font color="#000000">28:</font>   <b><u><font color="#000000">for</font></u></b> (c = <font color="#000000">0</font>; c &lt; layer1_size; c++) syn1neg[c + l2] += g * syn0[c + l1];
<font color="#000000">29:</font>   } <i><font color="#222222">// end loop through negative samples</font></i>
<font color="#000000">30:</font> <i><font color="#222222">// Learn weights input -&gt; hidden</font></i>
<font color="#000000">31:</font> <b><u><font color="#000000">for</font></u></b> (c = <font color="#000000">0</font>; c &lt; layer1_size; c++) syn0[c + l1] += neu1e[c];
<font color="#000000">32:</font> </tt></pre>
</div>

<ul>
<li>
 We have <i>two</i> vectors for each word, one called <code>syn0[l1 + _]</code> and
  the other <code>syn1neg[l2 + _]</code>. The <code>syn1neg</code> word embedding is used whenever
  a word is used a negative sample, and is not used anywhere else. Also,
  the <code>syn1neg</code> vector is zero initialized, while the <code>syn0</code> vectors are
  randomly initialized.
</li>

</ul>

<ul>
<li>
 The values we backprop with <code>g * syn1neg[l2 + _]</code>, <code>g * syn0[l1 + _]</code> are
  <i>not</i> the correct gradients of the error term! The derivative of a sigmoid
  is <code>dsigmoid(x)/dx = sigmoid(x) [1 - sigmoid(x)]</code>. The <code>[1 - sigmoid(x)]</code>
  is nowhere to be seen, let alone the fact that we are using
  <code>sigmoid(2x - 1)</code> and not regular sigmoid. Very weird.
</li>

</ul>

<ul>
<li>
 We hold the value of <code>syn0</code> constant throughout all the negative samples,
  which was not mentioned in any tutorial I've read.
</li>

</ul>

The paper does not mentioned these implementation details, and neither
does <i>any blog post that I've read</i>. I don't understand what's going on,
and I plan on updating this section when I understand this better.
<h3><a id=arthur-whitney-dense-code href='#arthur-whitney-dense-code'> § </a> <a href=#arthur-whitney-dense-code>
Arthur Whitney: dense code</a>
</h3>
<ul>
<li>
 Guy who wrote a bunch of APL dialects, write code in an eclectic style
  that has very little whitespace and single letter variable names.
</li>
<li>
 Believes that this allows him to hold the entire program in his head.
</li>
<li>
 Seems legit from my limited experience with APL, haskell one-liners.
</li>
<li>
 <a href=http://kparc.com/b/readme.txt>
The b programming language</a>
. It's quite
  awesome to read the sources. For example, <a href=http://kparc.com/b/a.c>
<code>a.c</code></a>

</li>

</ul>

<ul>
<li>
 <a href=https://www.jsoftware.com/papers/50/>
A history of APL in 50 functions</a>
 ---
  A great list of APL snippets that solve classical problems.
</li>

</ul>

<h3><a id=how-does-one-work-with-arrays-in-a-linear-language href='#how-does-one-work-with-arrays-in-a-linear-language'> § </a> <a href=#how-does-one-work-with-arrays-in-a-linear-language>
How does one work with arrays in a linear language?</a>
</h3>
Given an array of qubits <code>xs: Qubit[]</code>, I want to switch to little endian.
Due to no-cloning, I can't copy them! I suppose I can use recursion to build
up a new "list". But this is not the efficient array version we know and love
and want.
The code that I want to work but does not:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> function switchEndian(xs: Qubit[]): Unit {
<font color="#000000">3:</font>     <b><u><font color="#000000">for</font></u></b>(i <b><u><font color="#000000">in</font></u></b> <font color="#000000">0</font>..Length(xs) - <font color="#000000">1</font>) {
<font color="#000000">4:</font>         Qubit q = xs[i]; <i><font color="#222222">// boom, this does not work!</font></i>
<font color="#000000">5:</font>         xs[i] = xs[Length(xs) - <font color="#000000">1</font> - i]
<font color="#000000">6:</font>         xs[Length(xs) - <font color="#000000">1</font> - i] = q;
<font color="#000000">7:</font>     }
<font color="#000000">8:</font> }
<font color="#000000">9:</font> </tt></pre>
</div>

On the other hand, what <i>does work</i> is to setup a quantum circuit that
performs this flipping, since it's a permutation matrix at the end of
the day. But this is very slow, since it needs to simulate the "quantumness"
of the solution, since it takes <code>2^n</code> basis vectors for <code>n</code> qubits.
However, the usual recursion based solution works:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> function switchEndian(xs: Qubit[]): Qubit[] {
<font color="#000000">3:</font>     <b><u><font color="#000000">if</font></u></b>(Length(xs) == <font color="#000000">1</font>) {
<font color="#000000">4:</font>         <b><u><font color="#000000">return</font></u></b> xs;
<font color="#000000">5:</font>     } <b><u><font color="#000000">else</font></u></b> {
<font color="#000000">6:</font>         switchEndian(xs[<font color="#000000">1</font>..(Length(xs) - <font color="#000000">1</font>)] + xs[<font color="#000000">0</font>]
<font color="#000000">7:</font>     }
<font color="#000000">8:</font> }
<font color="#000000">9:</font> </tt></pre>
</div>

This is of course, suboptimal.
I find it interesting that in the linear types world, often the "pure" solution
is <i>forced</i> since mutation very often involves temporaries / copying!
(I'm solving assignments in <a href=https://docs.microsoft.com/en-us/quantum/>
qsharp</a>

for my course in college)
<h3><a id=linear-optimisation-is-the-same-as-linear-feasibility-checking href='#linear-optimisation-is-the-same-as-linear-feasibility-checking'> § </a> <a href=#linear-optimisation-is-the-same-as-linear-feasibility-checking>
Linear optimisation is the same as linear feasibility checking</a>
</h3>
Core building block of effectively using the ellipsoid algorithm.
<ul>
<li>
 If we posess a way to check if a point <span class='latexinline'>
<span style="font-style:italic">p</span> &#X2208; <span style="font-style:italic">P</span></span> where <span class='latexinline'>
<span style="font-style:italic">P</span></span> is a polytope, we
  can use this to solve optimisation problems.
</li>
<li>
 Given the optimisation problem maximise <span class='latexinline'>
<span style="font-style:italic">c</span><sup><span style="font-style:italic">T</span></sup><span style="font-style:italic">x</span></span> subject to <span class='latexinline'>
<span style="font-style:italic">Ax</span> = <span style="font-style:italic">b</span></span>, we can
  construct a new <i>non-emptiness</i> problem. This allows us to convert optimisation
  into <i>feasibility</i>.
</li>
<li>
 The new problem is <span class='latexinline'>
<span style="font-style:italic">Ax</span> = <span style="font-style:italic">b</span>, <span style="font-style:italic">A</span><sup><span style="font-style:italic">T</span></sup><span style="font-style:italic">y</span> = <span style="font-style:italic">c</span>, <span style="font-style:italic">c</span><sup><span style="font-style:italic">T</span></sup><span style="font-style:italic">x</span> = <span style="font-style:italic">b</span><sup><span style="font-style:italic">T</span></sup> <span style="font-style:italic">y</span></span>. Note that by duality,
  a point in this new polyhedra will <i>be an optimal solution to the above linear program</i>.
  We are forcing <span class='latexinline'>
<span style="font-style:italic">c</span><sup><span style="font-style:italic">T</span></sup><span style="font-style:italic">x</span> = <span style="font-style:italic">b</span><sup><span style="font-style:italic">T</span></sup><span style="font-style:italic">y</span></span>, which will be the optimal solution, since the
  solution where the primal and dual agree is the optimal solution by strong
  duality.
</li>
<li>
 This way, we have converted a <i>linear programming</i> problem into a
  <i>check if this polytope is empty</i> problem!
</li>

</ul>

<h3><a id=quantum-computation-without-complex-numbers href='#quantum-computation-without-complex-numbers'> § </a> <a href=#quantum-computation-without-complex-numbers>
Quantum computation without complex numbers</a>
</h3>
I recently learnt that the Toeffili and Hadamard gates are universal for
quantum computation. The description of these gates involve no complex numbers.
So, we can write any quantum circuit in a "complex number free" form. The caveat
is that we may very well have <i>input qubits</i> that require complex numbers.
Even so, a large number (all?) of the basic algorithms shown in Nielsen and
Chaung can be encoded in an entirely complex-number free fashion.
I don't really understand the ramifications of this, since I had the intuition
that the power of quantum computation comes from the ability to express
complex phases along with superposition (tensoring). However, I now have
to remove the power from going from R to C in many cases. This is definitely
something to ponder.
<ul>
<li>
 <a href=https://arxiv.org/pdf/quant-ph/0301040>
Dorit Aharonov: A Simple Proof that Toffoli and Hadamard are Quantum Universal</a>

</li>

</ul>

<h3><a id=linguistic-fun-fact-comparative-illusion href='#linguistic-fun-fact-comparative-illusion'> § </a> <a href=#linguistic-fun-fact-comparative-illusion>
Linguistic fun fact: Comparative Illusion</a>
</h3>
I steal from wikipedia:
<blockquote> Comparative Illusion, which is a grammatical illusion where certain sentences seem grammatically correct when you read them, but upon further reflection actually make no sense.</blockquote>
For example: "More people have been to Berlin than I have."
<h3><a id=long-form-posts href='#long-form-posts'> § </a> Long-form posts:</h3>
<h3><a id=reading href='#reading'> § </a> Reading</h3>
<ul>
<li>
 <a href=content/blog/stuff-i-learnt-this-year-2018.md>
2018 reading</a>

</li>
<li>
 <a href=content/blog/papers-I-read-and-loved-in-2017.md>
2017 reading</a>

</li>

</ul>

<h3><a id=haskell href='#haskell'> § </a> Haskell</h3>
<ul>
<li>
 <a href=content/blog/reading-kmett-structs.md>
Reading the <code>structs</code> library</a>

</li>
<li>
 <a href=content/blog/machines/reading-kmett-machines.md>
Reading the <code>machines</code> library (WIP)</a>

</li>
<li>
 <a href=content/blog/laziness-for-c-programmers.md>
Explaining laziness (WIP)</a>

</li>
<li>
 <a href=stg-explained.md>
Explaining STG(WIP)</a>

</li>

</ul>

<h3><a id=llvm-compiler-progress href='#llvm-compiler-progress'> § </a> Simplexhc (STG -> LLVM compiler) progress</h3>
<ul>
<li>
 <a href=content/blog/ghc-micro-optimisations-or-why-proc-points-suck.md>
proc points suck / making GHC an order of magnitude faster</a>

</li>
<li>
 <a href=this-month-in-simplexhc-dec-2017.md>
dec 2017</a>

</li>
<li>
 <a href=this-week-in-simpexhc-oct-29-2017.md>
oct 29 2017</a>

</li>
<li>
 <a href=this-week-in-simplexhc-07-2017.md>
july 2017</a>

</li>
<li>
 <a href=this-week-in-simplexhc-2017-07-06.md>
july 6th 2017</a>

</li>
<li>
 <a href=content/blog/announcing-simplexhc.md>
announcement</a>

</li>

</ul>

<h3><a id=gsoc-2015 href='#gsoc-2015'> § </a> GSoC (2015)</h3>
<ul>
<li>
 <a href=content/blog/gsoc-vispy.md>
proposal</a>

</li>
<li>
 <a href=content/blog/gsoc-vispy-week-1-and-2.md>
week 1</a>

</li>
<li>
 <a href=content/blog/gsoc-vispy-week-3-and-4.md>
week 3 and 4</a>

</li>
<li>
 <a href=content/blog/gsoc-vispy-week-5.md>
week 5</a>

</li>
<li>
 <a href=content/blog/gsoc-vispy-week-6.md>
week 6</a>

</li>
<li>
 <a href=content/blog/gsoc-vispy-week-7.md>
week 7</a>

</li>
<li>
 <a href=content/blog/gsoc-vispy-report-6.md>
final report</a>

</li>

</ul>

<h2><a id=big-list-of-emacs-gripes href='#big-list-of-emacs-gripes'> § </a> <a href=#big-list-of-emacs-gripes>
Big list of emacs gripes</a>
</h2>
<h4><a id=for-a-linki-open-a-paren- href='#for-a-linki-open-a-paren-'> § </a> <code>markdown-mode</code> lags when I open a paren <code>[for a link</code>.</h4>
I suppose this is because
it's attempting to match it, and is unable to figure out
what to match to. I now edit markdown in <code>text-mode</code>.
<h4><a id=kills-far-too-much href='#kills-far-too-much'> § </a> <code>ctrl-backspace</code>/<code>backward-kill-word</code> kills far too much.</h4>
<ul>
<li>
 <a href=https://emacs.stackexchange.com/questions/30401/backward-kill-word-kills-too-much-how-to-make-it-more-intelligent>
reference <code>emacs.se</code></a>

</li>

</ul>

The answer seems to be:
yes, it kills a word. You can redefine what a word is,
and break lots of other stuff in the process, or redefine
what <code>ctrl-backspace</code> does. However, as a non-expert, it's hard
to say what redefining this will mean. Will it still interact
with history the same way?
<h4><a id=go-back-to-where-i-came-fromof- href='#go-back-to-where-i-came-fromof-'> § </a> there is no centralized notion of <code>C-o</code> (go back to where I came from).</h4>
<ul>
<li>
 <a href=https://emacs.stackexchange.com/questions/9908/can-cursor-jump-back-to-the-previous-position>
reference <code>emacs.se</code></a>

</li>
<li>
 <a href=https://stackoverflow.com/questions/4918707/in-emacs-how-to-go-back-to-previous-line-position-after-using-semantic-jump-to>
reference <code>stackoverflow</code></a>

</li>

</ul>

Instead, it differentiates between "go back in buffer" versus
"go back across buffers".
This is extremely confusing when one is attempting to read
code and understand control-flow: I want a <i>unified</i> way
to say "go forward in my history; OK go back" when I am
exploring code. I don't <i>want</i> to keep track of whether
I came to this buffer from the same buffer or another buffer.
The fact that emacs needs this is moronic.
<h4><a id=scrolling-half-a-page-is-broken href='#scrolling-half-a-page-is-broken'> § </a> Scrolling half a page is broken</h4>
<ul>
<li>
 <a href=https://emacs.stackexchange.com/questions/27698/how-can-i-scroll-a-half-page-on-c-v-and-m-v>
reference <code>emacs.se</code></a>

</li>
<li>
 <a href=https://www.emacswiki.org/emacs/HalfScrolling>
reference <code>emacswiki</code></a>

</li>

</ul>

There is no inbuilt functionality to scroll half a page. The canonical 
reference points to this:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> (autoload <b><font color="#000000">'View-scroll-half-page-forward</font></b> <font color="#808080">"view"</font>)
<font color="#000000">3:</font> (autoload <b><font color="#000000">'View-scroll-half-page-backward</font></b> <font color="#808080">"view"</font>)
<font color="#000000">4:</font> (global-set-key (kbd <font color="#808080">"C-d"</font>) <b><font color="#000000">'View-scroll-half-page-forward</font></b>)
<font color="#000000">5:</font> (global-set-key (kbd <font color="#808080">"C-u"</font>) <b><font color="#000000">'View-scroll-half-page-backward</font></b>)
<font color="#000000">6:</font> </tt></pre>
</div>

However, this does not work well. On press <code>C-u</code> to go to
the top of the file, it does not move the cursor to the
top completely; once  <i>the first line is in view</i>
(with my cursor still on line 30),
emacs obstinately refuses to scroll up with a 'beginning of buffer'
message. I'm sure there's more <code>elisp</code> I can write to fix this,
but the fact that something like moving-half-a-page
is rocket science just rubs me the wrong way.
This code that is given in <code>emacswiki</code> also
has the exact same issue, I don't understand
how the poster says they come from vim and
did not notice this inconsistency.
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> (<b><u><font color="#000000">defun</font></u></b> zz-scroll-half-page (direction)
<font color="#000000">03:</font>   <font color="#808080">"Scrolls half page up if `direction' is non-nil, otherwise will scroll half page down."</font>
<font color="#000000">04:</font>   (<b><u><font color="#000000">let</font></u></b> ((opos (<b><u><font color="#000000">cdr</font></u></b> (nth <font color="#000000">6</font> (posn-at-point)))))
<font color="#000000">05:</font>     <i><font color="#222222">;; opos = original position line relative to window</font></i>
<font color="#000000">06:</font>     (move-to-window-line nil)  <i><font color="#222222">;; Move cursor to middle line</font></i>
<font color="#000000">07:</font>     (<b><u><font color="#000000">if</font></u></b> direction
<font color="#000000">08:</font>         (recenter-top-bottom <font color="#000000">-1</font>)  <i><font color="#222222">;; Current line becomes last</font></i>
<font color="#000000">09:</font>       (recenter-top-bottom <font color="#000000">0</font>))  <i><font color="#222222">;; Current line becomes first</font></i>
<font color="#000000">10:</font>     (move-to-window-line opos)))  <i><font color="#222222">;; Restore cursor/point position</font></i>
<font color="#000000">11:</font> 
<font color="#000000">12:</font> (<b><u><font color="#000000">defun</font></u></b> zz-scroll-half-page-down ()
<font color="#000000">13:</font>   <font color="#808080">"Scrolls exactly half page down keeping cursor/point position."</font>
<font color="#000000">14:</font>   (interactive)
<font color="#000000">15:</font>   (zz-scroll-half-page nil))
<font color="#000000">16:</font> 
<font color="#000000">17:</font> (<b><u><font color="#000000">defun</font></u></b> zz-scroll-half-page-up ()
<font color="#000000">18:</font>   <font color="#808080">"Scrolls exactly half page up keeping cursor/point position."</font>
<font color="#000000">19:</font>   (interactive)
<font color="#000000">20:</font>   (zz-scroll-half-page t))
<font color="#000000">21:</font> 
<font color="#000000">22:</font> 
<font color="#000000">23:</font> (global-set-key (kbd <font color="#808080">"C-d"</font>) <b><font color="#000000">'zz-scroll-half-page-down</font></b>)
<font color="#000000">24:</font> (global-set-key (kbd <font color="#808080">"C-u"</font>) <b><font color="#000000">'zz-scroll-half-page-up</font></b>)
<font color="#000000">25:</font> </tt></pre>
</div>

<h4><a id=chinese-iso-8bitg-is-weird- href='#chinese-iso-8bitg-is-weird-'> § </a> Default encoding is weird: <code>chinese-iso-8bit</code></h4>
<ul>
<li>
 <a href=https://emacs.stackexchange.com/questions/34322/set-default-coding-system-utf-8>
<code>emacs.se reference</code></a>

</li>

</ul>

Why in the world is this the option that shows up by default?
There are so many better options, with <code>utf-8</code> being the
sanest of them all; this is a nice spherical cow of
the problems with emacs: too much stuff, too like sanity.
The spell is:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> (set-language-environment "UTF-8")
<font color="#000000">3:</font> </tt></pre>
</div>

<h4><a id=linum-lags-on-large-files href='#linum-lags-on-large-files'> § </a> linum lags on large files</h4>
<code>global-linum-mode</code> lags on very long files.
<h4><a id=emacs-lags-on-long-lines href='#emacs-lags-on-long-lines'> § </a> emacs lags on long lines</h4>
<code>emacs</code> lags given very long lines.
<a href=https://old.reddit.com/r/emacs/comments/9qtpak/what_would_it_take_to_make_emacs_perform_well_on/>
A comment by <code>eli-zaretskli</code> on reddit</a>

says:
<blockquote> That is true, but the "fix" part misses the point. There's nothing wrong with the current algorithms, they just cannot handle these situations better than they already do. The main problem that makes redisplay slow in these cases is that, given a cursor motion command, such as <code>C-n</code> or <code>M-v</code>, the display engine needs first to find where in the buffer that command puts point. And that is non-trivial when variable-size fonts are supported and variable-size characters (or images) can be anywhere on display.</blockquote>
So there's a fundamental problem. He continues:
<blockquote> ... we are talking about one of the following two alternatives: Add new members to the data structures used by the display engine, that would allow it to find good approximations for buffer positions corresponding to given screen coordinates, then augment the algorithms to generate and use this additional data.  edesign the display code to use a model that is entirely different from the current simple 2D canvas. </blockquote>
<h4><a id=emacs-single-threading-causes-pauses-on-auto-completecompany href='#emacs-single-threading-causes-pauses-on-auto-completecompany'> § </a> emacs' single threading causes pauses on auto-complete/company</h4>
<h4><a id=emacs-crashes-on-attempting-to-open-an-svg-file href='#emacs-crashes-on-attempting-to-open-an-svg-file'> § </a> emacs crashes on attempting to open an SVG file</h4>
<ul>
<li>
 <a href=http://emacs.1067599.n8.nabble.com/bug-29581-26-0-90-SVG-file-can-cause-emacs-to-crash-imagemagick-td443659.html>
Link to <code>emacs</code> bug repo about segfault</a>

</li>

</ul>

My <code>emacs --version</code> says:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> ╰─$ emacs --version
<font color="#000000">3:</font> GNU Emacs 26.2
<font color="#000000">4:</font> Copyright (C) 2019 Free Software Foundation, Inc.
<font color="#000000">5:</font> GNU Emacs comes with ABSOLUTELY NO WARRANTY.
<font color="#000000">6:</font> You may redistribute copies of GNU Emacs
<font color="#000000">7:</font> under the terms of the GNU General Public License.
<font color="#000000">8:</font> For more information about these matters, see the file named COPYING.
<font color="#000000">9:</font> </tt></pre>
</div>

I ran it with <code>emacs -q</code>. The bactrace points at a segfault in <code>ImageMagick</code>:
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">01:</font> 
<font color="#000000">02:</font> Fatal error 11: Segmentation fault
<font color="#000000">03:</font> Backtrace:
<font color="#000000">04:</font> emacs[0x50fdc9]
<font color="#000000">05:</font> emacs[0x4f61f7]
<font color="#000000">06:</font> emacs[0x50e77e]
<font color="#000000">07:</font> emacs[0x50ea83]
<font color="#000000">08:</font> emacs[0x50eac0]
<font color="#000000">09:</font> /lib/x86_64-linux-gnu/libpthread.so.0(+0x11390)[0x7f213756b390]
<font color="#000000">10:</font> /usr/lib/x86_64-linux-gnu/ImageMagick-6.8.9/modules-Q16/coders/svg.so(+0xb8b8)[0x7f211676e8b8]
<font color="#000000">11:</font> /usr/lib/x86_64-linux-gnu/libMagickCore-6.Q16.so.2(ReadImage+0x198)[0x7f213d439a18]
<font color="#000000">12:</font> /usr/lib/x86_64-linux-gnu/libMagickWand-6.Q16.so.2(MagickReadImage+0x6a)[0x7f213d90ba3a]
<font color="#000000">13:</font> emacs[0x5e65fc]
<font color="#000000">14:</font> emacs[0x5eed1d]
<font color="#000000">15:</font> emacs[0x5ef1a0]
<font color="#000000">16:</font> emacs[0x56cf26]
<font color="#000000">17:</font> emacs[0x5a5ff8]
<font color="#000000">18:</font> emacs[0x56ce93]
<font color="#000000">19:</font> emacs[0x5a5ff8]
<font color="#000000">20:</font> emacs[0x56ce93]
<font color="#000000">21:</font> emacs[0x5a5ff8]
<font color="#000000">22:</font> emacs[0x56ce93]
<font color="#000000">23:</font> emacs[0x5a5ff8]
<font color="#000000">24:</font> emacs[0x56ce93]
<font color="#000000">25:</font> emacs[0x5a5ff8]
<font color="#000000">26:</font> emacs[0x56ce93]
<font color="#000000">27:</font> emacs[0x5a5ff8]
<font color="#000000">28:</font> emacs[0x56ce93]
<font color="#000000">29:</font> emacs[0x5a5ff8]
<font color="#000000">30:</font> emacs[0x56ce93]
<font color="#000000">31:</font> emacs[0x5a5ff8]
<font color="#000000">32:</font> emacs[0x56ce93]
<font color="#000000">33:</font> emacs[0x5a5ff8]
<font color="#000000">34:</font> emacs[0x56ce93]
<font color="#000000">35:</font> emacs[0x5a5ff8]
<font color="#000000">36:</font> emacs[0x56ce93]
<font color="#000000">37:</font> emacs[0x5a5ff8]
<font color="#000000">38:</font> emacs[0x56ce93]
<font color="#000000">39:</font> emacs[0x5a5ff8]
<font color="#000000">40:</font> emacs[0x56ce93]
<font color="#000000">41:</font> emacs[0x568c9d]
<font color="#000000">42:</font> emacs[0x56cf26]
<font color="#000000">43:</font> emacs[0x56eb24]
<font color="#000000">44:</font> emacs[0x56904e]
<font color="#000000">45:</font> ...
<font color="#000000">46:</font> [3]    7224 segmentation fault (core dumped)  emacs -q ~/work/IIIT-H-Code/softwarefoundations/project
<font color="#000000">47:</font> </tt></pre>
</div>

This is tagged as "not a bug" --- because
"if imagemagick crashes, there is no recourse".
<h2><a id=big-list-of-latex href='#big-list-of-latex'> § </a> <a href=#big-list-of-latex>
Big list of Latex</a>
</h2>
<h4><a id=write-text-under-some-equation--variable-under-max-or-argmax href='#write-text-under-some-equation--variable-under-max-or-argmax'> § </a> write text under some equation --- variable under max or argmax</h4>
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> y = \underset{x \in X}{\max} f(x)
<font color="#000000">3:</font> </tt></pre>
</div>

<h2><a id=big-list-of-coq href='#big-list-of-coq'> § </a> <a href=#big-list-of-coq>
Big list of Coq</a>
</h2>
Things in Coq that I keep forgetting, and are hard to lookup.
<h4><a id=manually-set-the-value-of-an-existential href='#manually-set-the-value-of-an-existential'> § </a> Manually set the value of an existential</h4>
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> instantiate
<font color="#000000">3:</font> </tt></pre>
</div>

	
<h4><a id=rename-an-expression-with-an-identifier-throughout-the-proof href='#rename-an-expression-with-an-identifier-throughout-the-proof'> § </a> Rename an expression with an identifier throughout the proof</h4>
<div class='code'>
<!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><font color="#000000">1:</font> 
<font color="#000000">2:</font> set (ident := expr) in *
<font color="#000000">3:</font> </tt></pre>
</div>

This is useful to not lose information when <code>destruct</code> ing.
<h2><a id=big-list-of-writing href='#big-list-of-writing'> § </a> <a href=#big-list-of-writing>
Big list of writing</a>
</h2>
<h4><a id=books-about-charming-sentences-and-how-to-construct-them href='#books-about-charming-sentences-and-how-to-construct-them'> § </a> Books about charming sentences and how to construct them</h4>
<h4><a id=active-vs-passive-vocabulary href='#active-vs-passive-vocabulary'> § </a> Active v/s passive vocabulary</h4>
<ul>
<li>
 passive vocabulary: Words one knows and can understand from context.
</li>
<li>
 active vocabulary: Words one uses actively while speaking.
</li>

</ul>

The key to good writing for those who read a lot is to expand their
active vocabulary to match their passive vocabulary.
<ul>
<li>
 A useful exercise is to look for synonyms during speech; This way,
  one forces an enlargening of active vocabulary. 
</li>

</ul>

<ul>
<li>
 Moulding one's inner mologoue to reach the ideal 'Voice' might also be
  benificial; However, there is a tendency that speech is not the same as
  writing --- very few people speak as they write. I wish to write like my idol
  (David Foster Wallace), who does speak like he writes. I surmise it's
  worthwhile to mould my inner speech to align with how my writing is supposed
  to be.
</li>

</ul>

<h4><a id=punctuation href='#punctuation'> § </a> Punctuation</h4>
Should one use punctuation, or shoud not? How much should one use punctuation?
What range of punctuation should one use --- from the common<code>,</code> and <code>.</code>, all the
way up to <code>:</code>, <code>;</code>, and <code>---</code>. 
There appear to be three distinct schools of thought. 
<ul>
<li>
 The first school of thought is prescriptive;
  They hold the belief that one must use <i>as much</i> punctuation as is necessary to 
  accurately transcribe cadence.
</li>

</ul>

<ul>
<li>
 The second school are the moderates. Too much of
  punctuation can leave writing stilted, or worse, give it an appearance of putting
  on a veneer of respectability. Use as much punctation as is necessary, they say.
</li>

</ul>

<ul>
<li>
 The third school of thought is anarchic and recommend no punctuation at all 
  except for <code>.</code> as this is a terrific way to get a sense for how to place words as one is forced to switch up vocabulary based on the cadence one wishes for instead of
  relying on artificial markers afforded by our system of writing.
</li>

</ul>

<h4><a id=english-grammar href='#english-grammar'> § </a> English grammar</h4>
<ul>
<li>
 <a href=https://www.englishclub.com/grammar/pronouns-relative.htm>
english club</a>

</li>
<li>
 <a href=https://www.gingersoftware.com/content/grammar-rules/>
ginger software: grammar rules</a>

</li>
<li>
 <a href=https://literarydevices.net/>
Literary devices</a>

</li>

</ul>

I couldn't really find a good "grammar book", so I decided
to simply poll friends every time I came across a word that I 
didn't know. Assumes knowledge of <code>noun</code>, <code>pronoun</code>,
<code>verb</code>, <code>adjective</code>.
<h4><a id=pronoun-resolution href='#pronoun-resolution'> § </a> Pronoun resolution</h4>
<ul>
<li>
 cataphora: later reference, anaphora: past reference?
</li>

</ul>

The connection between this and <code>catamorphism</code>/<code>anamorphism</code>
is something I wish to explore.
<ul>
<li>
 <code>let ([x 5]) (+ x 3))</code>: <code>x</code> is anaphora resolution.
</li>
<li>
 
</li>

</ul>

<h2><a id=link-dump href='#link-dump'> § </a> Link dump</h2>
<ul>
<li>
 <a href=https://gekk.info/articles/adhd.html>
ADHD: A lifelong struggle: Why organisation systems don't work</a>

</li>
<li>
 <a href=http://www.cs.nott.ac.uk/~pszgmh/bctcs-slides/hinze.pdf>
Slides for intuition on converting number systems to data structures by Ralf Hinze</a>

</li>
<li>
 <a href=https://www.usenix.org/system/files/1401_08-12_mickens.pdf>
James mickens: hilarious articles --- this one on security</a>

</li>
<li>
 <a href=https://gekk.info/articles/adhd.html>
ADHD: A lifelong struggle | Why organisation systems don't work</a>

</li>

</ul>

<h2><a id=recipes href='#recipes'> § </a> <a href=#recipes>
Recipes</a>
</h2>
<h4><a id=upma href='#upma'> § </a> Upma</h4>
<ul>
<li>
 start with ghee, sesame seeds, curry leaves, red + green chili, ginger garlic
  paste, hing (asaefodita).
</li>
<li>
 finely chopped onion, allow this to caramelize.
</li>
<li>
 A dash of turmeric for depth.
</li>
<li>
 Add in the rava, allow it to cook/heat.
</li>
<li>
 Add in tomato and a little water when it's done heating. Allow tomato to cook.
</li>
<li>
 Add in more water, cover with a lid, and let it come to a boil. Keep stirring
  to prevent clumps.
</li>
<li>
 Garnish with coriander.
</li>

</ul>

<h4><a id=general-coconut-based-thickening-agent href='#general-coconut-based-thickening-agent'> § </a> General Coconut based thickening agent</h4>
<ul>
<li>
 A few methi seeds (pungent, deep scent)
</li>
<li>
 some coriander seeds (mild herbal scent) 
</li>
<li>
 Chopped up red chilis (heat, spice, color)
</li>
<li>
 Chopped up green chilis (spice)
</li>
<li>
 Chopped up green chilis (spice)
</li>
<li>
 Chopped up garlic (some; strong, garlicky flavour and scent)
</li>

</ul>

Heat the spices with oil to create a fragrant mix (Tadka[Hindi] / Oggarane[Kannada]).
<ul>
<li>
 Grated coconut
</li>
<li>
 Salt (to taste)
</li>

</ul>

Finally, throw in the above heated spices into the blender along with the
grated coconut and blend all of it. It turns into a thick red paste.
<h4><a id=breadfruit-sambhar href='#breadfruit-sambhar'> § </a> Breadfruit Sambhar</h4>
<ul>
<li>
 Heat up oil.
</li>
<li>
 Fry <b>sesame seeds, cumin seeds, curry leaves, a tiny cinnamon stick</b> first. 
</li>
<li>
 Once fried, add in <b>garlic</b> to taste. 
</li>
<li>
 After garlic has fried as well, saute <b>onions</b> till golden. 
</li>
<li>
 Finely chop <b>tomatoes</b> and add it to the sauteed onions. Cover with a lid
</li>
<li>
 till the tomatoes release all their water.
</li>
<li>
 Now that we have a solid flavour base, pour in water to cook the breadfruit.
</li>
<li>
 Add in the <b>chopped breadfruit</b> --- chop the breadfruit in thin slices
</li>
<li>
 along the center; the center has interesting texture we wish to maximize. 
</li>
<li>
 Add in the <b><a href=#general-coconut-based-thickening-agent>
General coconut based thickening agent</a>
</b>.
</li>
<li>
 Also add salt to taste.
</li>
<li>
 Cover with a lid. Allow breadfruit, water, and thickening agent to come to a boil.
</li>
<li>
 Lower flame to low. Allow breadfruit to soften and cook.
</li>
<li>
 Once breadfruit is cooked, pour in <b>coconut milk</b>. Continue cooking for
  ten minutes.
</li>

</ul>

<h2><a id=words href='#words'> § </a> Words</h2>
<h4><a id=decephalized href='#decephalized'> § </a> decephalized</h4>
We need to clone decephalized humans and livestock.
With thousands of brainless bodies kept alive on life support, you have test
subjects for a limitless number of experiments that would have never been
possible before. You also create a never-ending O negative blood supply and
organ harvesting program.
It the case of decephalized animals, you also get cruelty free meat. And that's
how you bootstrap the program and port it to the human model.
<h4><a id=demagoguery href='#demagoguery'> § </a> demagoguery</h4>
The ancient Greeks had a word for our modern systems “demagoguery” which
equates to charismatic liars manipulating gullible people to vote against their
own good
</container></body></html>