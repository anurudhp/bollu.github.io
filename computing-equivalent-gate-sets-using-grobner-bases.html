<!DOCTYPE html><meta charset='UTF-8'><html><head><link rel='stylesheet' href='katex/katex.min.css'    integrity='sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X'    crossorigin='anonymous'><!-- The loading of KaTeX is deferred to speed up page rendering --><title> A Universe of Sorts </title><style>@font-face {font-family: 'Blog Mono'; src: url('/static/iosevka-etoile-fixed.ttf');}@font-face {font-family: 'Blog Symbol'; src: url('/static/Symbola.ttf');}@font-face {font-family: 'Blog Text'; src: url('/static/Exo2-Regular.ttf');}html { font-size: 100%; }html,body { text-size-adjust: none; -webkit-text-size-adjust: none; -moz-text-size-adjust: none; -ms-text-size-adjust: none; } body { background-color: #FFFFFF; color: #000000;  font-family: 'Blog Text', sans-serif; font-size: 18px; line-height: 1.4em;  max-width: 100%; }
img { display:block; }.container { overflow-x: hidden }@media (max-width: 480px) { .container { margin-left: 5%; margin-right: 2%; } body { font-size: 40px; } }@media (max-width: 1024px) { .container { margin-left: 5%; margin-right: 2%; } body { font-size: 40px; } }@media (min-width: 1024px) { .container { margin-left: 30%; margin-right: 25%; } }.image { }
a:hover { color: #1a73e8; text-decoration: underline;  }
a { color: #1a73e8; text-decoration: none; }
a:visited { color: #1a73e8; text-decoration: none; }
a:active { color: #1a73e8; text-decoration: none; }

 .code, .latexblock, blockquote { border-left-color:#BBB;  border-left-style: solid;      border-left-width: 1px; }.code pre, blockquote { padding-left: 10px; }
 .code { font-family: 'Blog Mono', monospace; font-size: 90%;  }.latexblock, blockquote, .code, code { margin-top: 10px; margin-bottom: 10px; padding-bottom: 5px; padding-top: 5px; background-color: #FFFFFF; }.code, code { background-color: #FFFFFF; width: 100%; }.latexblock { line-height: 1em } .latexblock {  width: 100%; overflow-x: auto; white-space: nowrap; } .code pre { width: 100%; overflow-x: auto; margin: 0px; overflow-y: hidden; padding-top: 5px; padding-bottom: 5px; margin: 0px; }
.latexinline { white-space: nowrap }.code { white-space: nowrap }pre, code, kbd, samp, tt{ font-family:'Blog Mono',monospace; }ul, ol { list-style-position: inside; padding-left: 0; }</style></head><body><div class='container'><h2><a id=computing-equivalent-gate-sets-using-grobner-bases href='#computing-equivalent-gate-sets-using-grobner-bases'> § </a> Computing equivalent gate sets using grobner bases</h2>
Here's a fun little problem, whose only solution I know involves a fair
bit of math and computer algebra:
We are given the grammar for a language <code>L</code>:
<div class='code'><!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>    G[q](ηo(id_o)) = ηo(q'(id_o))
    G[q](ηo(id_o)) = ηo(q' . id_o)
    G[q](ηo(id_o)) = ηo(q')
    ηo(q') = G[q](ηo(id_o))
</tt></pre>
</div>
where <code>+_mod8</code> is addition modulo 8, <code>-_mod8</code> is subtraction modulo 8,
and <code>^</code> is XOR.
This language is equipped with the obvious
evaluation rules, corresponding to those of arithmetic. We are guaranteed
that during evaluation, the variables <code>a_i</code> will only have values <code>0</code> and <code>1</code>.
Since we have addition, we can perform multiplication by a constant
by repeated addition. So we can perform <code>3*a</code> as <code>a+a+a</code>.
We are then given the input expression <code>(a0 ^ a1 ^ a2 ^ a3)</code>. We wish
to find an equivalent expression in terms of the above language <code>L</code>.
We think of <code>E</code> as some set of logic gates we are allowed to use, and we are
trying to express the operation <code>(a0 ^ a1 ^ a2 ^ a3)</code> in terms of these gates.
The first idea that I thought was that of employing a grobner basis,
since they essentially embody rewrite rules modulo polynomial equalities, which
is precisely our setting here.
In this blog post, I'm going to describe what a grobner basis is and why it's
natural to reach for them to solve this problem, the code, and the eventual
solution.
As a spolier, the solution is:
<div class='code'><!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>    G[q](ηo(id_o)) = ηo(q'(id_o))
    G[q](ηo(id_o)) = ηo(q' . id_o)
    G[q](ηo(id_o)) = ηo(q')
    ηo(q') = G[q](ηo(id_o))
</tt></pre>
</div>
Clearly, this contains only additions/subtractions and multiplications by
a constant.
If there's some principled way to derive this (beyond throwing symbolic
algebra machinery), I'd really love to know ---
<a href=https://github.com/bollu/bollu.github.io/issues>Please raise an issue with the explanation!</a>
<h4><a id=what-the-hell-is-grobner-basis href='#what-the-hell-is-grobner-basis'> § </a> What the hell is Grobner Basis?</h4>
The nutshell is that a grobner basis is a way to construct rewrite rules which
also understand arithmetic (I learnt this viewpoint from the book "Term
rewriting and all that". Fantastic book in general). Expanding on the
nutshell, assume we have a term rewriting system:
<div class='code'><!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>    G[q](ηo(id_o)) = ηo(q'(id_o))
    G[q](ηo(id_o)) = ηo(q' . id_o)
    G[q](ηo(id_o)) = ηo(q')
    ηo(q') = G[q](ηo(id_o))
</tt></pre>
</div>
over an alphabet <code>{A, B, C}</code>.
Now, given the string <code>C + AB</code>, we wish to find out if it can be rewritten to
<code>0</code> or not. Let's try to substitute and see what happens:
<div class='code'><!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>    G[q](ηo(id_o)) = ηo(q'(id_o))
    G[q](ηo(id_o)) = ηo(q' . id_o)
    G[q](ηo(id_o)) = ηo(q')
    ηo(q') = G[q](ηo(id_o))
</tt></pre>
</div>
At this point, we're stuck! we don't have rewrite rules to allow us to
rewrite <code>(-1*B)B</code> into <code>-B^2</code>. Indeed, creating such a list would be
infinitely long. But if we are willing to accept that we somehow have
the rewrite rules that correspond to polynomial arithmetic, where we view
<code>A, B, C</code> as variables, then we <i>can</i> rewrite the above string to 0:
<div class='code'><!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>    G[q](ηo(id_o)) = ηo(q'(id_o))
    G[q](ηo(id_o)) = ηo(q' . id_o)
    G[q](ηo(id_o)) = ηo(q')
    ηo(q') = G[q](ηo(id_o))
</tt></pre>
</div>
A Grobner basis is the algorithmic / mathematical machine that allows us
to perform this kind of substitution.
In this example, this might appear stupid: what is so special? We simply
substituted variables and arrived at <code>0</code> by using arithmetic. What's
so complicated about that? To understand why this is not always so easy,
let's consider a pathological, specially constructed example
<h4><a id=a-complicated-example-that-shatters-dreams href='#a-complicated-example-that-shatters-dreams'> § </a> A complicated example that shatters dreams</h4>
Here's the pathological example:
<div class='code'><!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>    G[q](ηo(id_o)) = ηo(q'(id_o))
    G[q](ηo(id_o)) = ηo(q' . id_o)
    G[q](ηo(id_o)) = ηo(q')
    ηo(q') = G[q](ηo(id_o))
</tt></pre>
</div>
And we consider the string <code>S = AB + B^2</code>.  If we blindly apply the
first rule, we arrive at:
<div class='code'><!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>    G[q](ηo(id_o)) = ηo(q'(id_o))
    G[q](ηo(id_o)) = ηo(q' . id_o)
    G[q](ηo(id_o)) = ηo(q')
    ηo(q') = G[q](ηo(id_o))
</tt></pre>
</div>
However, if we apply <code>(2)</code> and then <code>(1)</code>:
<div class='code'><!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>    G[q](ηo(id_o)) = ηo(q'(id_o))
    G[q](ηo(id_o)) = ηo(q' . id_o)
    G[q](ηo(id_o)) = ηo(q')
    ηo(q') = G[q](ηo(id_o))
</tt></pre>
</div>
This tells us that we <i>can't just apply the rewrite rules willy-nilly</i>.
It's sensitive to the <i>order</i> of the rewrites! That is, the rewrite system
is not <a href=https://en.wikipedia.org/wiki/Confluence_(abstract_rewriting>confluent</a>).
The grobner basis is a function from rewrite systems to rewrite systems.
When given a rewrite system <code>R</code>, it produces a <i>new</i> rewrite system <code>R'</code>
that <i>is confluent</i>. So, we can apply the rewrite rules of <code>R'</code> in any order,
and we guaranteed that we will only get a 0 from <code>R'</code> if and only if
we could have gotten a <code>0</code> from <code>R</code> for all strings.
We can then go on to phrase this whole rewriting setup in the language of
ideals from ring theory, and that is the language in which it is most
often described. I've gone into more depth on that perspective here: 
<a href=#what-the-hell-is-a-grobner-basis-ideals-as-rewrite-systems>"What is a grobner basis? polynomial factorization as rewrite systems"</a>.
Now that we have a handle on what a grobner basis is, let's go on to solve
the original problem:
<h4><a id=an-explanation-through-a-slightly-simpler-problem href='#an-explanation-through-a-slightly-simpler-problem'> § </a> An explanation through a slightly simpler problem</h4>
I'll first demonstrate the idea of how to solve the original problem
by solving a slightly simpler problem:
<blockquote> Rewrite <code>a^b^c</code> in terms of <code>a^b</code>, <code>b^c</code>, <code>c^a</code> and the same <code>+_mod8</code> instruction set as the original problem. The only difference this time is that we do <i>not</i> have <code>T -> V ^ V ^ V</code>.</blockquote>
The idea is to construct the polynomial ring over <code>Z/8Z</code> (integers modulo 8) with
variables as <code>a, b, c, axorb, bxorc, axorc</code>. Now, we know that <code>a^b = a + b - 2ab</code>. So,
we setup rewrite rules such that <code>a + b - 2ab -> axorb</code>, <code>b + c - 2bc -> bxorb</code>,
<code>c + a - 2ca -> cxora</code>.
We construct the <i>polynomial</i> <code>f(a, b, c) = a^b^c</code>, which
has been written in terms of addition and multiplication, defined
as <code>f_orig(a, b, c) = 4*a*b*c - 2*a*b - 2*a*c - 2*b*c + a + b + c</code>. We then
rewrite <code>f_orig</code> with respect to our rewrite rules. Hopefully, the rewrite
rules should give us a clean expression in terms of one variable and
two-variable <code>xor</code>s. There is the danger that we may have some term
such as <code>a * bxorc</code>, and we do get such a term (<code>2*b*axorc</code>) in this case,
but it does not appear in the <i>original</i> problem.
<div class='code'><!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>    G[q](ηo(id_o)) = ηo(q'(id_o))
    G[q](ηo(id_o)) = ηo(q' . id_o)
    G[q](ηo(id_o)) = ηo(q')
    ηo(q') = G[q](ηo(id_o))
</tt></pre>
</div>
Running the code gives us the reduced polynomial <code>-2*b*axorc + b + axorc</code>
which unfortunately contains a term that is <code>b * axorc</code>. So, this approach
does not work, and I was informed by my friend that she is unaware
of a solution to this problem (writing <code>a^b^c</code> in terms of smaller xors and
sums).
The full code output is:
<div class='code'><!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>    G[q](ηo(id_o)) = ηo(q'(id_o))
    G[q](ηo(id_o)) = ηo(q' . id_o)
    G[q](ηo(id_o)) = ηo(q')
    ηo(q') = G[q](ηo(id_o))
</tt></pre>
</div>
That is, both the original polynomial and the reduced polynomial match
the expected results. But the reduced polynomial is not in our language <code>L</code>,
since it has a term that is a <i>product</i> of <code>b</code> with <code>axorc</code>.
<h4><a id=tacking-the-original-problem href='#tacking-the-original-problem'> § </a> Tacking the original problem.</h4>
We try the exact same approach to the original problem of expressing
<code>a ^ b ^ c ^ d</code>. We find that the reduced polynomial is
<div class='code'><!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>    G[q](ηo(id_o)) = ηo(q'(id_o))
    G[q](ηo(id_o)) = ηo(q' . id_o)
    G[q](ηo(id_o)) = ηo(q')
    ηo(q') = G[q](ηo(id_o))
</tt></pre>
</div>
which happily has no products between terms! It also passes our sanity
check, so we've now found the answer.
The full output is:
<div class='code'><!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>    G[q](ηo(id_o)) = ηo(q'(id_o))
    G[q](ηo(id_o)) = ηo(q' . id_o)
    G[q](ηo(id_o)) = ηo(q')
    ηo(q') = G[q](ηo(id_o))
</tt></pre>
</div>
<h4><a id=code-for-abcd-reduction href='#code-for-abcd-reduction'> § </a> code for <code>a^b^c^d</code> reduction:</h4>
<div class='code'><!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>    G[q](ηo(id_o)) = ηo(q'(id_o))
    G[q](ηo(id_o)) = ηo(q' . id_o)
    G[q](ηo(id_o)) = ηo(q')
    ηo(q') = G[q](ηo(id_o))
</tt></pre>
</div>
<h4><a id=closing-thoughts href='#closing-thoughts'> § </a> Closing thoughts</h4>
This was a really fun exercise: Around a hundred lines of code illuminates
the use of machinery such as grobner basis for solving real-world problems!
I really enjoyed hacking this up and getting nerd sniped.
</container></body></html>