<!DOCTYPE html><meta charset='UTF-8'><html><head><link rel='stylesheet' href='katex/katex.min.css'    integrity='sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X'    crossorigin='anonymous'><!-- The loading of KaTeX is deferred to speed up page rendering --><script defer src='katex/katex.min.js'    integrity='sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4'    crossorigin='anonymous'></script><script>    function on_katex_load() {        const katex_opts = [            {left: '$', right: '$', display: false},            {left: '$$', right: '$$', display: true}        ];        renderMathInElement(document.body, katex_opts);        let elemsInline = document.getElementsByClassName('latexinline');        for (var i = 0; i < elemsInline.length; i++) {katex.render(elemsInline.item(i).textContent, elemsInline.item(i));}        let elemsBlock = document.getElementsByClassName('latexblock');        for (var i = 0; i < elemsInline.length; i++) {katex.render(elemsBlock.item(i).textContent, elemsBlock.item(i), {displayMode: true});}    }</script><!-- To automatically render math in text elements, include the auto-render extension: --><script defer src='katex/auto-render.min.js'    integrity='sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa'    crossorigin='anonymous'    onload='on_katex_load();'></script><title> A Universe of Sorts </title><style>@font-face {font-family: 'Blog Mono'; src: url('/static/iosevka-etoile-fixed.ttf');}@font-face {font-family: 'Blog Symbol'; src: url('/static/Symbola.ttf');}@font-face {font-family: 'Blog Text'; src: url('/static/Exo2-Regular.ttf');}html { font-size: 100%; }html,body { text-size-adjust: none; -webkit-text-size-adjust: none; -moz-text-size-adjust: none; -ms-text-size-adjust: none; } body { background-color: #FFFFFF; color: #000000;  font-family: 'Blog Text', sans-serif; font-size: 18px; line-height: 1.4em;  max-width: 100%; }
img { display:block; }.container { overflow-x: hidden }@media (max-width: 480px) { .container { margin-left: 5%; margin-right: 2%; } body { font-size: 40px; } }@media (max-width: 1024px) { .container { margin-left: 5%; margin-right: 2%; } body { font-size: 40px; } }@media (min-width: 1024px) { .container { margin-left: 30%; margin-right: 25%; } }.image { }
a:hover { color: #1a73e8; text-decoration: underline;  }
a { color: #1a73e8; text-decoration: none; }
a:visited { color: #1a73e8; text-decoration: none; }
a:active { color: #1a73e8; text-decoration: none; }

 .code, .latexblock, blockquote { border-left-color:#BBB;  border-left-style: solid;      border-left-width: 1px; }.code pre, blockquote { padding-left: 10px; }
 .code { font-family: 'Blog Mono', monospace; font-size: 90%;  }.latexblock, blockquote, .code, code { margin-top: 10px; margin-bottom: 10px; padding-bottom: 5px; padding-top: 5px; background-color: #FFFFFF; }.code, code { background-color: #FFFFFF; width: 100%; }.latexblock { line-height: 1em } .latexblock {  width: 100%; overflow-x: auto; white-space: nowrap; } .code pre { width: 100%; overflow-x: auto; margin: 0px; overflow-y: hidden; padding-top: 5px; padding-bottom: 5px; margin: 0px; }
.latexinline { white-space: nowrap }.code { white-space: nowrap }pre, code, kbd, samp, tt{ font-family:'Blog Mono',monospace; }ul, ol { list-style-position: inside; padding-left: 0; }</style></head><body><div class='container'><h2><a id=bounding-chains-uniformly-sample-colorings href='#bounding-chains-uniformly-sample-colorings'> § </a> <a href=#bounding-chains-uniformly-sample-colorings>Bounding chains: uniformly sample colorings</a></h2>
We wish to <i>uniformly sample</i> <code>k</code> colorings of a graph <span class='latexinline'>G</span> with maximum degree
<span class='latexinline'>\Delta</span>. Hence, we require <span class='latexinline'>k \geq \Delta + 1</span>. To perform this sampling,
we use MCMC to sample from a markov chain whose states are <span class='latexinline'>k</span>-colorings of <span class='latexinline'>G</span>,
whose stationary distribution is the uniform distribution over valid colorings.
The issue with MCMC techniques is that we never know when our chain has reached
the stationary state. To ensure we receive uniformly distributed samples,
we built a "bounding chain" <span class='latexinline'>W</span> which has the following properties:
<ul><li> States of <span class='latexinline'>W</span> cover states of <span class='latexinline'>X</span> [ie, state space of <span class='latexinline'>W</span> are subsets of the state space of <span class='latexinline'>X</span>].</li><li> <span class='latexinline'>W</span>'s convergence to a stationary state can be checked.</li><li> Upon convergence of <span class='latexinline'>W</span>, state of <span class='latexinline'>W</span> = state of <span class='latexinline'>X</span>.</li></ul>
We will in fact run the <span class='latexinline'>W</span> chain, and prove that running the <span class='latexinline'>W</span> chain
is equivalent to running a 'shadow' of the <span class='latexinline'>X</span> chain, and that stationary
states of the <span class='latexinline'>W</span> chain correspond to stationary sates of the <span class='latexinline'>X</span> chain.
Let <span class='latexinline'>X</span> be the chain whose states are valid <span class='latexinline'>k</span> colorings of <span class='latexinline'>G</span>. In one step
of the chain <span class='latexinline'>X</span>, we choose a vertex <span class='latexinline'>v</span> uniformly at random; we then choose a
color <span class='latexinline'>c'_v</span> uniformly at random for <span class='latexinline'>v</span> that makes it a proper coloring. The vertex
<span class='latexinline'>v</span> is changed to this new color <span class='latexinline'>c'</span>. This is a symmetric proposal distribution,
Hence this chain has the uniform distribution over <span class='latexinline'>k</span>-colorings to be
the stationary state.
Sampling exactly from this chain is hard: construct an initial state <span class='latexinline'>X_0</span>
amounts to finding some valid <span class='latexinline'>k</span> coloring which in itself might be
challenging. Worse, we do not know whether the chain <span class='latexinline'>X</span> has reached a
stationary state or not.
<h4><a id=bounding-chain href='#bounding-chain'> § </a> Bounding Chain</h4>
We construct a new chain <span class='latexinline'>W</span> (the bounding chain of <span class='latexinline'>X</span>), whose states are <i>sets of colors</i> for
vertices in <span class='latexinline'>G</span>. Formally, the states of <span class='latexinline'>W</span> are functions <span class='latexinline'>Vert(G) \rightarrow 2^C</span> where
<span class='latexinline'>Vert(G)</span> denotes the vertices of <span class='latexinline'>G</span>; <span class='latexinline'>C</span> the set of colors. The transition
will be to pick a vertex <span class='latexinline'>v</span> uniformly at random. Then, pick a new set of
legal colors <span class='latexinline'>C'_v</span> for <span class='latexinline'>v</span>, such that:
<ul><li> It is guaranteed that if <span class='latexinline'>X</span> were transitioning on <span class='latexinline'>v</span>, the
  color <span class='latexinline'>c'_v</span> that would be picked by <span class='latexinline'>X</span> for <span class='latexinline'>v</span> is a member of <span class='latexinline'>C'_v</span>. [state is covered]</li><li> The size of the set <span class='latexinline'>C'_v</span> attempts to be smaller than the current set of colorings <span class='latexinline'>C_v</span>. [convergence]</li></ul>
We describe the transition function next. But first, we need an alternate
lens on the transitions of <span class='latexinline'>X</span> that is amenable to massaging. 
<h4><a id=equivalent-description-of-the-transitions-of-x href='#equivalent-description-of-the-transitions-of-x'> § </a> Equivalent description of the transitions of <span class='latexinline'>X</span>:</h4>
<ol><li> Choosing a color uniformly at random from the set of valid colors
   for a vertex.</li><li> Choosing colors from <span class='latexinline'>C</span> without replacement until we get a color 
   that is a valid color. </li></ol>
We claim that (1) and (2) have the same probability distribution.
Abstracting slightly, we state:
<ol><li> Probability of choosing an element <span class='latexinline'>t \in T</span> uniformly from  <span class='latexinline'>T \subseteq S</span>.
   This has probability <span class='latexinline'>1/|T|</span>.</li><li> Probability of choosing a particular element <span class='latexinline'>t \in T</span>, by picking elements
   from <span class='latexinline'>S</span> without replacement until we get some element in <span class='latexinline'>T</span>.</li></ol>
(1) and (2) have the same probability distribution.
<h4><a id=proof-by-induction href='#proof-by-induction'> § </a> Proof by induction:</h4>
Process (2) in code is the following:
<div class='code'><!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>          ∃!id(p)
          +---+
          |   |
          |   v
+---------ppppp--------+
| πa      |   ^     πb |  
v      ∃!p2q  |        v
a         |   |        b
^         |  ∃!q2p     ^
| π'b     v   |    π'b |
+---------qqqqq--------+
</tt></pre>
</div>
We claim that the probability that <code>process(S, T) = t0</code> for a fixed <code>t0</code> in <code>T</code>
is <span class='latexinline'>1/|T|</span>. We create a new function <code>indicator</code> to express this:
<div class='code'><!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>          ∃!id(p)
          +---+
          |   |
          |   v
+---------ppppp--------+
| πa      |   ^     πb |  
v      ∃!p2q  |        v
a         |   |        b
^         |  ∃!q2p     ^
| π'b     v   |    π'b |
+---------qqqqq--------+
</tt></pre>
</div>
Let's push in <code>t0 ==</code> into the definiton of <code>process</code> after inling <code>process</code>.
This gives us:
<div class='code'><!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>          ∃!id(p)
          +---+
          |   |
          |   v
+---------ppppp--------+
| πa      |   ^     πb |  
v      ∃!p2q  |        v
a         |   |        b
^         |  ∃!q2p     ^
| π'b     v   |    π'b |
+---------qqqqq--------+
</tt></pre>
</div>
Now, we write down the recurrence for the probability that we are trying
to compute: <span class='latexinline'>P(t0, S, T)</span> is the probability that <code>indicator(t0, S, T)</code> returns
<code>True</code>. Alternatively, it's the probability that <code>process(S, T)</code> returns <code>t0</code>.
<div class='code'><!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>          ∃!id(p)
          +---+
          |   |
          |   v
+---------ppppp--------+
| πa      |   ^     πb |  
v      ∃!p2q  |        v
a         |   |        b
^         |  ∃!q2p     ^
| π'b     v   |    π'b |
+---------qqqqq--------+
</tt></pre>
</div>
We assume for induction that <code>P(t0, |S|-1, T) = 1/|T|</code>. On substitution into <code>[induction]</code>,
we get:
<div class='code'><!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>          ∃!id(p)
          +---+
          |   |
          |   v
+---------ppppp--------+
| πa      |   ^     πb |  
v      ∃!p2q  |        v
a         |   |        b
^         |  ∃!q2p     ^
| π'b     v   |    π'b |
+---------qqqqq--------+
</tt></pre>
</div>
Which is indeed the same probability as (1):
<blockquote> 1. Choosing an element uniformly from a subset <span class='latexinline'>T</span> = <code>1/|T|</code>.</blockquote>
<h4><a id=proof-by-program-analysis-version-1 href='#proof-by-program-analysis-version-1'> § </a> Proof by program analysis, Version 1</h4>
<div class='code'><!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>          ∃!id(p)
          +---+
          |   |
          |   v
+---------ppppp--------+
| πa      |   ^     πb |  
v      ∃!p2q  |        v
a         |   |        b
^         |  ∃!q2p     ^
| π'b     v   |    π'b |
+---------qqqqq--------+
</tt></pre>
</div>
Notice that the last return is tail-call. This program can be rewritten as:
<div class='code'><!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>          ∃!id(p)
          +---+
          |   |
          |   v
+---------ppppp--------+
| πa      |   ^     πb |  
v      ∃!p2q  |        v
a         |   |        b
^         |  ∃!q2p     ^
| π'b     v   |    π'b |
+---------qqqqq--------+
</tt></pre>
</div>
As previously, we create an <code>indicator</code> function and study its behaviour:
<div class='code'><!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>          ∃!id(p)
          +---+
          |   |
          |   v
+---------ppppp--------+
| πa      |   ^     πb |  
v      ∃!p2q  |        v
a         |   |        b
^         |  ∃!q2p     ^
| π'b     v   |    π'b |
+---------qqqqq--------+
</tt></pre>
</div>
We know that this programs only returns a value from the line:
<ul><li> <code>if s in T: return t0 == s</code></li></ul>
We now compute <code>P(process(S, T) == t0)</code>.
Whatever the return value of <code>indicator</code>, we can assume that it occured within
the <code>if</code> condition. We can use this to compute:
<div class='code'><!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>          ∃!id(p)
          +---+
          |   |
          |   v
+---------ppppp--------+
| πa      |   ^     πb |  
v      ∃!p2q  |        v
a         |   |        b
^         |  ∃!q2p     ^
| π'b     v   |    π'b |
+---------qqqqq--------+
</tt></pre>
</div>
<h4><a id=proof-by-program-analysis-version-2 href='#proof-by-program-analysis-version-2'> § </a> Proof by program analysis, Version 2</h4>
Alternatively, we can also analyze this as we did in the <i>first</i> proof,
using the rule:
<div class='code'><!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>          ∃!id(p)
          +---+
          |   |
          |   v
+---------ppppp--------+
| πa      |   ^     πb |  
v      ∃!p2q  |        v
a         |   |        b
^         |  ∃!q2p     ^
| π'b     v   |    π'b |
+---------qqqqq--------+
</tt></pre>
</div>
will have probability:
<div class='code'><!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>          ∃!id(p)
          +---+
          |   |
          |   v
+---------ppppp--------+
| πa      |   ^     πb |  
v      ∃!p2q  |        v
a         |   |        b
^         |  ∃!q2p     ^
| π'b     v   |    π'b |
+---------qqqqq--------+
</tt></pre>
</div>
Using this, we can analyze <code>indicator </code>as:
<div class='code'><!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>          ∃!id(p)
          +---+
          |   |
          |   v
+---------ppppp--------+
| πa      |   ^     πb |  
v      ∃!p2q  |        v
a         |   |        b
^         |  ∃!q2p     ^
| π'b     v   |    π'b |
+---------qqqqq--------+
</tt></pre>
</div>
<h4><a id=sampling-using-the-above-definition href='#sampling-using-the-above-definition'> § </a> Sampling using the above definition</h4>
Recall that <span class='latexinline'>State(X) \equiv V \rightarrow C</span>, <span class='latexinline'>State(W) \equiv V \rightarrow 2^C</span>.
Let <span class='latexinline'>x[~], w[~]</span> be the states of some run in the markov chains.
We start by having <span class='latexinline'>x[0]</span> to be <i>any</i> valid k-coloring of <span class='latexinline'>G</span>, and <span class='latexinline'>w[0]</span> to
be the state where all vertices have all possible colors; <span class='latexinline'>w[0] \equiv \_ \mapsto C</span>.
Clearly, <span class='latexinline'>x[0] \in w[0]</span>.
By induction we assume that <span class='latexinline'>x[n-1] \in w[n-1]</span>. We must now calculate a
<span class='latexinline'>w[n], x[n]</span> such that (1) <span class='latexinline'>x[n] \in w[n]</span>, (2) <span class='latexinline'>x[n]</span>'s proposal is symmetric. 
(3) <span class='latexinline'>w[n]</span>'s proposal is symmetric.
<h4><a id=occluded-set-o href='#occluded-set-o'> § </a> Occluded set <span class='latexinline'>O</span></h4>
Define <span class='latexinline'>O \subseteq C</span> (for occluded) be the set colors that might possibly
be blocked for <span class='latexinline'>v</span> from our view of <code>w</code>. Note that this is an
<b>over-approxmation</b>: that is, there may be colors that are not blocked for <code>v</code>, which we
believe to be blocked from <code>w</code>'s point of view.
<div class='latexblock'>O \equiv  \{ c \in C : (v, \alpha) \in E, c \in w[n-1](\alpha) \}</div>
<h4><a id=allowed-set-a href='#allowed-set-a'> § </a> Allowed set <span class='latexinline'>A</span></h4>
Define <span class='latexinline'>A \subset C</span> (for allowed) to be <span class='latexinline'>C - O</span>. Note that <span class='latexinline'>A</span> is
an <b>under-approxmation</b>, since <code>O</code> was an <i>over-approximation</i>. That is:
<ul><li> Any color in <code>A</code> is definitely a legal color for <code>v</code> in <code>x[n]</code>.  </li><li> There are colors which are legal for <code>v</code> in <code>x[n]</code> that is not in <code>A</code>.</li></ul>
<h4><a id=s-the-sequence-of-states-for-transition href='#s-the-sequence-of-states-for-transition'> § </a> S: the sequence of states for transition</h4>
Now, we pick elements of <span class='latexinline'>C</span> in sequence till we get an element of <code>A</code>.
call this sequence <span class='latexinline'>S</span>. 
We will at worst pick <span class='latexinline'>\Delta + 1</span> elements for <span class='latexinline'>S</span>, since the max-degree
of the graph is <span class='latexinline'>\Delta</span>.
<h4><a id=transition href='#transition'> § </a> Transition</h4>
Let <span class='latexinline'>i</span> be the first index in <span class='latexinline'>S</span> where we get a color that is <i>truly legal</i>
for <span class='latexinline'>v</span> in <span class='latexinline'>x[n]</span>. Note that such an index will always exist: We pick
elements into <span class='latexinline'>S</span> till we get an element in <span class='latexinline'>A</span>, and elements of <span class='latexinline'>A</span> are 
always legal. However, there can be elements which are not in <span class='latexinline'>A</span> that
are still legal for <span class='latexinline'>v</span> in <span class='latexinline'>x[n]</span>, since <span class='latexinline'>A</span> is an under-approximation.
<ul><li> We assign <span class='latexinline'>x[n](v) = i</span>. So, <code>x</code> only cares about <code>S[:i]</code>.</li><li> We assign  <span class='latexinline'>w[n](v) = A</span>. So, <code>W</code> cares about the entire sequence.</li></ul>
By the lemma proven, we know that this process of picking colors <code>C</code> 
in a sequence till we get a color that is legal for <span class='latexinline'>v</span> at index <span class='latexinline'>i</span>
is the same as picking uniformly at random from the set of colors that are legal for 
<span class='latexinline'>v</span>. 
<h4><a id=an-example href='#an-example'> § </a> An example</h4>
For example, we could have:
<div class='code'><!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>          ∃!id(p)
          +---+
          |   |
          |   v
+---------ppppp--------+
| πa      |   ^     πb |  
v      ∃!p2q  |        v
a         |   |        b
^         |  ∃!q2p     ^
| π'b     v   |    π'b |
+---------qqqqq--------+
</tt></pre>
</div>
If we analyze <code>S = [2, 1, 3]</code> we notice that:
<div class='code'><!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>          ∃!id(p)
          +---+
          |   |
          |   v
+---------ppppp--------+
| πa      |   ^     πb |  
v      ∃!p2q  |        v
a         |   |        b
^         |  ∃!q2p     ^
| π'b     v   |    π'b |
+---------qqqqq--------+
</tt></pre>
</div>
So, what we are really sampling ix:
<ul><li> A <i>prefix</i> sequence <code>SX = [1]</code> (for Xs transition)</li><li> A <i>leftover</i> sequence <code>SW = [2, 3]</code> (for Ws transition)</li></ul>
To transition <code>X</code>, we can safely drop <code>SW</code>. However, to transition <code>W</code> correctly,
we generate more elements in the sequence, till we hit a "safe" element.
<h4><a id=an-optimisation-on-picking-colors-why-we-need-a-blocking-set href='#an-optimisation-on-picking-colors-why-we-need-a-blocking-set'> § </a> An optimisation on picking colors: why we need a blocking set</h4>
Define the set <span class='latexinline'>B \subseteq C</span> (for blocked) which governs which values
<span class='latexinline'>x[n]</span> <b>surely cannot take</b> from our view of <span class='latexinline'>w[n-1]</span>.
Note that <span class='latexinline'>B</span> is an <b>under-approximation</b>. <code>v</code> might have
more colors that are blocked than what <code>w</code> sees.
<div class='latexblock'>B \equiv \{ c \in C : (v, \alpha) \in E, w[n-1](\alpha) = \{c\} \}</div>
       
Rather than sampling colors from <code>C</code> till we get an element of <code>A</code>, we can
sample colors from <code>C/B</code>. We know that the colors in <code>B</code> can <b>never</b> be used 
by <span class='latexinline'>X</span>, since the colors in <code>B</code> are those that we know are blocked <b>for sure</b>.
This is used in the theoretical analysis of the paper.
<h4><a id=termination href='#termination'> § </a> Termination</h4>
We terminate when <span class='latexinline'>W</span> has "trapped" <span class='latexinline'>X</span>. That is, <span class='latexinline'>|w[n](v)| = 1</span> forall <span class='latexinline'>v \in V</span>.
In such a case, the states of <span class='latexinline'>W</span> is equal to states of <span class='latexinline'>X</span>. This is
a coalescence (as it occurs in coupling from the past). From the coupling
from the past theory, we know that we have reached a stationary state of <span class='latexinline'>A</span>
when this happens.
<h4><a id=pseudocode href='#pseudocode'> § </a> Pseudocode</h4>
<div class='code'><!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>          ∃!id(p)
          +---+
          |   |
          |   v
+---------ppppp--------+
| πa      |   ^     πb |  
v      ∃!p2q  |        v
a         |   |        b
^         |  ∃!q2p     ^
| π'b     v   |    π'b |
+---------qqqqq--------+
</tt></pre>
</div>
<h4><a id=references href='#references'> § </a> References</h4>
<ul><li> <a href=https://dl.acm.org/doi/10.1145/276698.276709>Exact Sampling and Approximate Counting Techniques</a></li></ul>
</container></body></html>