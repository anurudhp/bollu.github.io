<!DOCTYPE html><meta charset='UTF-8'><html><head><link rel='stylesheet' href='katex/katex.min.css'    integrity='sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X'    crossorigin='anonymous'><!-- The loading of KaTeX is deferred to speed up page rendering --><script defer src='katex/katex.min.js'    integrity='sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4'    crossorigin='anonymous'></script><script>    function on_katex_load() {        const katex_opts = [            {left: '$', right: '$', display: false},            {left: '$$', right: '$$', display: true}        ];        renderMathInElement(document.body, katex_opts);        let elemsInline = document.getElementsByClassName('latexinline');        for (var i = 0; i < elemsInline.length; i++) {katex.render(elemsInline.item(i).textContent, elemsInline.item(i));}        let elemsBlock = document.getElementsByClassName('latexblock');        for (var i = 0; i < elemsInline.length; i++) {katex.render(elemsBlock.item(i).textContent, elemsBlock.item(i), {displayMode: true});}    }</script><!-- To automatically render math in text elements, include the auto-render extension: --><script defer src='katex/auto-render.min.js'    integrity='sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa'    crossorigin='anonymous'    onload='on_katex_load();'></script><title> A Universe of Sorts </title><style>@font-face {font-family: 'Blog Mono'; src: url('/static/iosevka-etoile-fixed.ttf');}@font-face {font-family: 'Blog Symbol'; src: url('/static/Symbola.ttf');}@font-face {font-family: 'Blog Text'; src: url('/static/Exo2-Regular.ttf');}html { font-size: 100%; }html,body { text-size-adjust: none; -webkit-text-size-adjust: none; -moz-text-size-adjust: none; -ms-text-size-adjust: none; } body { background-color: #FFFFFF; color: #000000;  font-family: 'Blog Text', sans-serif; font-size: 18px; line-height: 1.4em;  max-width: 100%; }
img { display:block; }.container { overflow-x: hidden }@media (max-width: 480px) { .container { margin-left: 5%; margin-right: 2%; } body { font-size: 40px; } }@media (max-width: 1024px) { .container { margin-left: 5%; margin-right: 2%; } body { font-size: 40px; } }@media (min-width: 1024px) { .container { margin-left: 30%; margin-right: 25%; } }.image { }
a:hover { color: #1a73e8; text-decoration: underline;  }
a { color: #1a73e8; text-decoration: none; }
a:visited { color: #1a73e8; text-decoration: none; }
a:active { color: #1a73e8; text-decoration: none; }

 .code, .latexblock, blockquote { border-left-color:#BBB;  border-left-style: solid;      border-left-width: 1px; }.code pre, blockquote { padding-left: 10px; }
 .code { font-family: 'Blog Mono', monospace; font-size: 90%;  }.latexblock, blockquote, .code, code { margin-top: 10px; margin-bottom: 10px; padding-bottom: 5px; padding-top: 5px; background-color: #FFFFFF; }.code, code { background-color: #FFFFFF; width: 100%; }.latexblock { line-height: 1em } .latexblock {  width: 100%; overflow-x: auto; white-space: nowrap; } .code pre { width: 100%; overflow-x: auto; margin: 0px; overflow-y: hidden; padding-top: 5px; padding-bottom: 5px; margin: 0px; }
.latexinline { white-space: nowrap }.code { white-space: nowrap }pre, code, kbd, samp, tt{ font-family:'Blog Mono',monospace; }ul, ol { list-style-position: inside; padding-left: 0; }</style></head><body><div class='container'><h2><a id=perspectives-on-yoneda href='#perspectives-on-yoneda'> § </a> <a href=#perspectives-on-yoneda>Perspectives on Yoneda</a></h2>
We can try to gain intuition for Yoneda by considering a finite category
where we view arrows as directed paths. 
The "interpretation" of a path is taken by going from edges to labels and then
concatenating all edge labels. We "interpret" the label <code>id_x</code> as <code>""</code> (the
empty string), and we "interpret" all other arrows <code>a</code> as some unique string
associated to each arrow. Composition of arrows becomes concatenation of
strings. This obeys all the axioms of a category. We are basically of a
category as a free monoid.
Let's being our consideration of the covariant functor <code>Hom(O, -): C → Set</code>.
Note that the objects of this category are <b>sets</b> of arrows <code>Hom(O, P)</code>.
To every arrow <code>a: P → Q</code> we associate the set function
<code>a': Hom(O, P) → Hom(O, Q)</code>. <code>a'(op) = pq . op</code>.
Now, to apply Yoneda, we need another covariant functor <code>G: S → Set</code>. We now
need to show that the set of natural transformations <code>η: F → G</code>  are in bijection
with the set <code>G[O] ∈ Set</code>.
We do this by the following consideration. Recall that for the natural transformation,
we have the commuting diagram:
<div class='code'><!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>x -p-&gt; y

Hom(o, x) -p'-&gt; Hom(o, y)
|                |
ηx               ηy
|                |
v                v
G[x] -G[p] --&gt; G[y]
</tt></pre>
</div>
<div class='code'><!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>∀ x y ∈ C,
  o2x ∈ Hom(o, x),
  p ∈ Hom(x, y),
    G[p](ηx(o2x)) = ηy(p'(o2x))
</tt></pre>
</div>
Which on using the definition of <code>p'</code> becomes:
<div class='code'><!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>∀ x y ∈ C,
  o2x ∈ Hom(o, x),
  p ∈ Hom(x, y),
  G[p](ηx(o2x)) = ηy(o2x . p')
</tt></pre>
</div>
Now pick the magic <code>x = o</code> and <code>o2x = o2o = id_o</code>. This gives:
<div class='code'><!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>x = o, y ∈ C
o2x = id_o

∀ y ∈ C, 
  p ∈ Hom(o, y),
  G[p](ηo(id_o)) = ηy(id_o . p')
  G[p](ηo(id_o)) = ηy(p') [By identity arrow]
  [assume we fix ηo(id_o) ∈ G[o] ]
  ηy(p') = G[p](ηo(id_o)) [ηy is now forced.
                          everything on the RHS is known]
</tt></pre>
</div>
Hence, we learn how to map every other arrow <code>ηy(p)</code>. If we know how to map
the arrows, we can map the objects in the hom-sets as images of the arrows,
since we know what <code>ηo[id_o]</code> maps to. Concretely:
<h4><a id=images-oq-for-q-homo-o-after-oido-is-fixed href='#images-oq-for-q-homo-o-after-oido-is-fixed'> § </a> Images <code>ηo(q)</code> for <code>q ∈ Hom(o, o)</code> after <code>ηo(id_o)</code> is fixed:</h4>
We have the relation <code>id_o . q = q</code>. So we get that the arrow <code>q': Hom(o, o) → Hom(o, o)</code>
takes <code>id_o</code> to <code>q</code>. By the structure of the natural transformation, we have that:
<div class='code'><!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>∀ x y ∈ C,
  o2x ∈ Hom(o, x),
  p ∈ Hom(x, y),
    G[p](ηx(o2x)) = ηy(p'(o2x))
</tt></pre>
</div>
<ul><li> Pick <code>x = y = o</code>, <code>o2x = id_o</code>, <code>p = q</code>. This gives:</li></ul>
<div class='code'><!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>    G[q](ηo(id_o)) = ηo(q'(id_o))
    G[q](ηo(id_o)) = ηo(q' . id_o)
    G[q](ηo(id_o)) = ηo(q')
    ηo(q') = G[q](ηo(id_o))
</tt></pre>
</div>
Hence, we've deduced <code>ηo(q')</code>, so we know what element <code>q</code> gets mapped to.
The same process works with <i>any</i> arrow!
<h4><a id=a-shift-in-perspective-yoneda-as-partial-monoid href='#a-shift-in-perspective-yoneda-as-partial-monoid'> § </a> A shift in perspective: Yoneda as partial monoid.</h4>
Since we're considering the sets <span class='latexinline'>Hom(o, -)</span>, note that we can always
pre-compose any element of <span class='latexinline'>Hom(o, o)</span> to every <span class='latexinline'>Hom(o, p)</span>. More-over,
if we know the value of <span class='latexinline'>id_o</span>, then we have the equation that <span class='latexinline'>id_o \circ a = a</span>.
since <span class='latexinline'>id_o</span> is the identity. Moreover, <span class='latexinline'>id_o</span> is the <b>only</b> identity arrow
we possess across all <span class='latexinline'>Hom(o, -)</span>: We can only access the identity arrow
inside <span class='latexinline'>Hom(o, o)</span>. For all other <span class='latexinline'>Hom(o, p)</span> where <span class='latexinline'>p \neq o</span>, we do
not have the identity arrow <span class='latexinline'>id_o</span> or <span class='latexinline'>id_p</span>. So we have a sort of <i>partial monoid</i>,
where we have a unique identity element <span class='latexinline'>id_o</span>, and arrows that compose <i>partially</i>
based on domain/codomain conditions.
From this perspective, we can read the commutative diagram laws as a sort
of "Cayley's theorem". We have as elements the elements of the set <span class='latexinline'>Hom(o, -)</span>.
For every arrow <span class='latexinline'>a: p \rightarrow q</span>, we have the action
<span class='latexinline'>Hom(o, p) \xrightarrow{a} Hom(o, q)</span>.
From this perspective, it is trivial to see that:
<ul><li> Every monoid can be embedded into its action space (Cayley's theorem).</li><li> This mapping of yoneda from <span class='latexinline'>Hom(o, -)</span> to arbitrary sets is like a "forgetful"
  functor from a monoid into a semigroup.</li><li> If our monoid is "well represented" by a semigroup, then once we know what
  the identity maps to, we can discover all of the other elements by using the
  relation <span class='latexinline'>f(ex) = f(e) f(x)</span>. The only "arbitrariness" introduced by forgetting
  the monoid structure is the loss of the unique identity. <b>NOTE</b>: This is handwavy,
  since the data given by a natural transformation is somehow "different", in a way
  that I'm not sure how to make precise.</li></ul>
</container></body></html>