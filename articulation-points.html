<!DOCTYPE html><meta charset='UTF-8'><html><head><link rel='stylesheet' href='katex/katex.min.css'    integrity='sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X'    crossorigin='anonymous'><!-- The loading of KaTeX is deferred to speed up page rendering --><link rel='stylesheet' href='prism/prism.css'><title> A Universe of Sorts </title><style>@font-face {font-family: 'Blog Mono'; src: url('/static/iosevka-fixed-extended.ttf');}@font-face {font-family: 'Blog Text'; src: url('/static/Exo2-Regular.ttf');}html { font-size: 100%; }html,body { text-size-adjust: none; -webkit-text-size-adjust: none; -moz-text-size-adjust: none; -ms-text-size-adjust: none; } body { background-color: #FFFFFF; color: #000000;  font-family: 'Blog Text', sans-serif; font-size: 18px; line-height: 1.4em;  max-width: 100%; overflow-x: hidden; }
img { display:block; width: 100%; max-width: 800px; height: auto }.container { overflow-x: auto; overflow-y: hidden;  max-width:100%; }@media (max-width: 480px) { .container { margin-left: 5%; margin-right: 5%; } body { font-size: 30px; } }@media (max-width: 1024px) { .container { margin-left: 5%; margin-right: 5%; } body { font-size: 30px; } }@media (min-width: 1024px) { .container { margin-left: 25%; margin-right: 20%; } }.image { }
a:hover { color: #1a73e8; text-decoration: underline;  }
a { color: #1a73e8; text-decoration: none; }
a:visited { color: #1a73e8; text-decoration: none; }
a:active { color: #1a73e8; text-decoration: none; }

blockquote { margin-left: 0px; margin-right: 0px; } pre, .latexblock, blockquote { border-left-color:#BBB;  border-left-style: solid;      border-left-width: 5px; }pre, blockquote { padding-left: 10px; }
pre { font-family: 'Blog Mono', monospace; font-size: 90%;  }pre {  overflow-x: auto; }.latexblock, blockquote, pre { margin-top: 10px; margin-bottom: 10px; padding-bottom: 5px; padding-top: 5px; background-color: #FFFFFF; }.latexblock { line-height: 1em }
pre, kbd, samp, tt{ font-family:'Blog Mono',monospace; }ul, ol { list-style-position: inside; padding-left: 0; }</style></head><body><div class='container'><h2><a id=articulation-points href='#articulation-points'> § </a><span class='centered'> Articulation points</h2>
I find DFS fascinating, and honestly insane for how much structral
information of the graph it manages to retain. 
<h4><a id=mengers-theorem href='#mengers-theorem'> § </a><span class='centered'> Menger's theorem</h4>
Let <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span></span> be a connected undirected graph. Let <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo separator="true">,</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">u, v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></span> be two non-adjacent
vertices.  The minimum number of vertices whose removal from <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span></span> disconnects
<span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">u</span></span></span></span></span> and <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></span> is equal to the <b><span class='centered'>maximal number of vertex disjoint paths</b> from <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></span>
to <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">u</span></span></span></span></span>.
<h4><a id=whitneys-theorem-corollary href='#whitneys-theorem-corollary'> § </a><span class='centered'> Whitney's theorem (corollary)</h4>
An undirected graph is <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></span> connected iff <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></span> vertices must be removed to
disconnect the graph.
<h4><a id=biconnected-components href='#biconnected-components'> § </a><span class='centered'> Biconnected components</h4>
Menger's theorem tells us that a graph is not biconnected <b><span class='centered'>iff</b> we can find a vertex
whose removal disconnected the graph. Such a vertex is an articulation vertex.
<blockquote><span class='centered'> A biconnected component is a maximal subset of edges, such that the induced<span class='centered'> subgraph is biconnected. Vertices can belong to many components;<span class='centered'> Indeeed, articulation vertices are those that belong to more than one component.</blockquote>
<img src="./static/structure-of-non-biconnected-graph.png"/>
<h4><a id=lemma-characterization-of-biconnected-components href='#lemma-characterization-of-biconnected-components'> § </a><span class='centered'> Lemma: Characterization of biconnected components</h4>
<h4><a id=dfs-for-articulation-vertices-undirected href='#dfs-for-articulation-vertices-undirected'> § </a><span class='centered'> DFS for articulation vertices - undirected:</h4>
<img src="./static/articulation-vertex-undirected.png"/>
                                                                                                                        
<ul><li><span class='centered'> The connectivity of a graph is the smallest number of vertices that need to
  be deleted to disconnect the graph.</li><li><span class='centered'> If the graph has an articulation vertex, the connectivity is 1. More robust
  graphs that don't have a single point of failure/articulation vertex are
  said to be <i><span class='centered'>binconnected</i>.</li><li><span class='centered'> To test for an articulation vertex by brute force, delete each vertex,
  and check if the graph has disconnected into components. this is <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">(</mo><mi>V</mi><mo>+</mo><mi>E</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(V(V+E))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span> time.</li></ul>
<blockquote><span class='centered'> Joke: an articulate vertex is one that speaks very well, and is thus important<span class='centered'> to the functioning of the graph. If it is killed, it will disconnect society,<span class='centered'> as there is no one to fulfil its ability to cross barriers with its eloquent<span class='centered'> speech.</blockquote>
<h4><a id=articulation-vertices-on-the-dfs-tree-undirected href='#articulation-vertices-on-the-dfs-tree-undirected'> § </a><span class='centered'> Articulation vertices on the DFS tree - undirected</h4>
<ul><li><span class='centered'> If we think of only the DFS tree for a moment of an undirected graph 
  and ignore all other edges, then
  all interneal non-leaf vertices become articulation vertices, because they
  disconnect the graph into two parts: the part below them (for concreteness,
  think of a child leaf), and the root component. </li></ul>
<ul><li><span class='centered'> Blowing up a leaf has no effect, since it does not connect two <i><span class='centered'>components</i>, 
  a leaf only connects itself to the main tree.</li></ul>
<ul><li><span class='centered'> The root of the tree is special; If it has only one child, then it acts like
  a leaf, since the root connects itself to the only component. On the other
  hand, if there are multiple components, then the root acts like an internal
  node, holding these different components together, making the root an
  articulation vertex.</li></ul>
<h4><a id=articulation-vertices-on-the-dfs-graph-undireced href='#articulation-vertices-on-the-dfs-graph-undireced'> § </a><span class='centered'> Articulation vertices on the DFS graph - undireced</h4>
<ul><li><span class='centered'> DFS of a general undirected graph also contains <i><span class='centered'>back edges</i>. These act as
  security cables that link a vertex back to its ancestor. The security
  cable from <code>x</code> to <code>y</code> ensures that none of the nodes on the path <code>[x..y]</code>
  can be articulation vertices.</li></ul>
<ul><li><span class='centered'> So, to find articulation vertices, we need to see how far back 
  the security cables go.</li></ul>
<pre><code><span class="token keyword">int</span> anc<span class="token punctuation">[</span>V<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">int</span> dfs_outdeg<span class="token punctuation">[</span>V<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">processs_vertex_early</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span> anc<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">process_edge</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>dfsedge<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">.</span>type <span class="token operator">==</span> TREE<span class="token punctuation">)</span> <span class="token punctuation">{</span> dfs_outdeg<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token comment">// y &lt;-*</span>
  <span class="token comment">//     |</span>
  <span class="token comment">//     BACK</span>
  <span class="token comment">//     |</span>
  <span class="token comment">// x --*</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>dfsedge<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">.</span>type <span class="token operator">==</span> BACK <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>parent<span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">!=</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
     <span class="token keyword">if</span><span class="token punctuation">(</span>entry_time<span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">&lt;</span> entry_time<span class="token punctuation">[</span>anc<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       anc<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> y<span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<img src="/home/bollu/blog/static/articulation-vertices-undirected-3-cases.png"/>
<blockquote><span class='centered'> In a DFS tree, a vertex v (other than the root) is an articulation<span class='centered'> vertex iff v is not a leaf and some subtree of v has no back edge incident<span class='centered'> until a proper ancestor of v.</blockquote>
<h4><a id=references href='#references'> § </a><span class='centered'> References</h4>
<ul><li><span class='centered'> Udi Manber: Introduction to algorithms: A creative approach.</li><li><span class='centered'> Steven Skeina: The algorithm design manual.</li></ul>
</container></body></html>