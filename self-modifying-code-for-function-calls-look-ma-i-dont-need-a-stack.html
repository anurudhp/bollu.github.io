<!DOCTYPE html><meta charset='UTF-8'><html><head><link rel='stylesheet' href='katex/katex.min.css'    integrity='sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X'    crossorigin='anonymous'><!-- The loading of KaTeX is deferred to speed up page rendering --><script defer src='katex/katex.min.js'    integrity='sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4'    crossorigin='anonymous'></script><script>    function on_katex_load() {        const katex_opts = [            {left: '$', right: '$', display: false},            {left: '$$', right: '$$', display: true}        ];        renderMathInElement(document.body, katex_opts);        let elemsInline = document.getElementsByClassName('latexinline');        for (var i = 0; i < elemsInline.length; i++) {katex.render(elemsInline.item(i).textContent, elemsInline.item(i));}        let elemsBlock = document.getElementsByClassName('latexblock');        for (var i = 0; i < elemsInline.length; i++) {katex.render(elemsBlock.item(i).textContent, elemsBlock.item(i), {displayMode: true});}    }</script><!-- To automatically render math in text elements, include the auto-render extension: --><script defer src='katex/auto-render.min.js'    integrity='sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa'    crossorigin='anonymous'    onload='on_katex_load();'></script><title> A Universe of Sorts </title><style>@font-face {font-family: 'Blog Mono'; src: url('/static/iosevka-etoile-fixed.ttf');}@font-face {font-family: 'Blog Symbol'; src: url('/static/Symbola.ttf');}@font-face {font-family: 'Blog Text'; src: url('/static/Exo2-Regular.ttf');}html { font-size: 100%; }html,body { text-size-adjust: none; -webkit-text-size-adjust: none; -moz-text-size-adjust: none; -ms-text-size-adjust: none; } body { background-color: #FFFFFF; color: #000000;  font-family: 'Blog Text', sans-serif; font-size: 18px; line-height: 1.4em;  max-width: 100%; }
img { display:block; }.container { overflow-x: hidden }@media (max-width: 480px) { .container { margin-left: 5%; margin-right: 2%; } body { font-size: 40px; } }@media (max-width: 1024px) { .container { margin-left: 5%; margin-right: 2%; } body { font-size: 40px; } }@media (min-width: 1024px) { .container { margin-left: 30%; margin-right: 25%; } }.image { }
a:hover { color: #1a73e8; text-decoration: underline;  }
a { color: #1a73e8; text-decoration: none; }
a:visited { color: #1a73e8; text-decoration: none; }
a:active { color: #1a73e8; text-decoration: none; }

 .code, .latexblock, blockquote { border-left-color:#BBB;  border-left-style: solid;      border-left-width: 1px; }.code pre, blockquote { padding-left: 10px; }
 .code { font-family: 'Blog Mono', monospace; font-size: 90%;  }.latexblock, blockquote, .code, code { margin-top: 10px; margin-bottom: 10px; padding-bottom: 5px; padding-top: 5px; background-color: #FFFFFF; }.code, code { background-color: #FFFFFF; width: 100%; }.latexblock { line-height: 1em } .latexblock {  width: 100%; overflow-x: auto; white-space: nowrap; } .code pre { width: 100%; overflow-x: auto; margin: 0px; overflow-y: hidden; padding-top: 5px; padding-bottom: 5px; margin: 0px; }
.latexinline { white-space: nowrap }.code { white-space: nowrap }pre, code, kbd, samp, tt{ font-family:'Blog Mono',monospace; }ul, ol { list-style-position: inside; padding-left: 0; }</style></head><body><div class='container'><h2><a id=self-modifying-code-for-function-calls-look-ma-i-dont-need-a-stack href='#self-modifying-code-for-function-calls-look-ma-i-dont-need-a-stack'> § </a> <a href=#self-modifying-code-for-function-calls-look-ma-i-dont-need-a-stack>Self modifying code for function calls: Look ma, I don't need a stack!</a></h2>
If one does not have recursive calls, one can eliminate the need to push
return addresses on a call stack by writing self-modifying code ---
I leant of this from TAOCP, volume 1. 
Knuth shows this off once he introduces <code>MIXAL</code>, his fantasy
aseembly language in which TAOCP programs are written.
I'll explain the usual way one performs call-return, then explain the nifty
self-modifying-code way. I think this is the cleanest, most accessible
example of self-modifying-code that I know. 
<h4><a id=the-traditional-solution-for-callret href='#the-traditional-solution-for-callret'> § </a> The traditional solution for <code>call/ret</code></h4>
We wish to have function <code>f</code> call function <code>g</code>. For <code>g</code> to be able to
return control to <code>f</code>, <code>f</code> pushes a return address into the call stack,
that <code>g</code> pops and <code>jmp</code>s to
<div class='code'><!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>          ∃!id(p)
          +---+
          |   |
          |   v
+---------ppppp--------+
| πa      |   ^     πb |  
v      ∃!p2q  |        v
a         |   |        b
^         |  ∃!q2p     ^
| π'b     v   |    π'b |
+---------qqqqq--------+
</tt></pre>
</div>
<div class='code'><!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>          ∃!id(p)
          +---+
          |   |
          |   v
+---------ppppp--------+
| πa      |   ^     πb |  
v      ∃!p2q  |        v
a         |   |        b
^         |  ∃!q2p     ^
| π'b     v   |    π'b |
+---------qqqqq--------+
</tt></pre>
</div>
Rather than <code>push</code>ing and <code>pop</code>ing, we can <i>rewrite</i> the code of <code>g</code>, to <i>change</i> <code>retloc</code> before a call
to <code>g</code>. In made-up-pseudocode, here's what that would look like:
<h4><a id=the-jump-based-solution href='#the-jump-based-solution'> § </a> The jump based solution</h4>
<div class='code'><!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>          ∃!id(p)
          +---+
          |   |
          |   v
+---------ppppp--------+
| πa      |   ^     πb |  
v      ∃!p2q  |        v
a         |   |        b
^         |  ∃!q2p     ^
| π'b     v   |    π'b |
+---------qqqqq--------+
</tt></pre>
</div>
<div class='code'><!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>          ∃!id(p)
          +---+
          |   |
          |   v
+---------ppppp--------+
| πa      |   ^     πb |  
v      ∃!p2q  |        v
a         |   |        b
^         |  ∃!q2p     ^
| π'b     v   |    π'b |
+---------qqqqq--------+
</tt></pre>
</div>
instead of having a call stack, before <code>f</code> calls g, <code>f</code> modify <code>g</code>'s code at location <code>RETG</code>
into a <code>jmp</code> instruction by <code>store</code> ing the instruction <code>jmp addr(L1)</code>.
This effectively creates a 'custom' <code>g</code> that knows how  to return
control flow into <code>f</code>.
<div class='code'><!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>          ∃!id(p)
          +---+
          |   |
          |   v
+---------ppppp--------+
| πa      |   ^     πb |  
v      ∃!p2q  |        v
a         |   |        b
^         |  ∃!q2p     ^
| π'b     v   |    π'b |
+---------qqqqq--------+
</tt></pre>
</div>
This way, we have obviated the need for a <code>push/pop</code> sequence, by directly
modifying <code>g</code>'s code. This is really neat --- we replace the overhead of
a <code>push/pop</code> with a single <code>store</code>.
<h4><a id=why-recursion-breaks href='#why-recursion-breaks'> § </a> Why recursion breaks.</h4>
We don't actually need a call stack, as long as we don't want to write recursive functions.
We can't have recursion, or more generally "re-entrance": consider a call chain of the form:
<ul><li> <code>A -> B -> C -> B</code>.</li><li> during <code>A -> B</code>, <code>A</code> will scribble a <code><return to A></code> into <code>B</code>.</li><li> during  <code>B -> C</code>, <code>B</code> will scribble a <code><return to  B></code> into <code>C</code>.</li><li> during <code>C -> B</code>, <code>C</code> will scribble <code><return to C></code> into <code>B</code>,
  <b>destroying the previous <code><return to A></code> </b>.</li><li> This creates a cycle, where <code>C</code> will attempt to return to <code>B</code>
  and vice versa.</li></ul>
<h3><a id=adjunctions-as-advice href='#adjunctions-as-advice'> § </a> <a href=#adjunctions-as-advice>Adjunctions as advice</a></h3>
An adjunction <code>F |- U</code> allows us to go from <code>F a -> x</code> to <code>a -> U x</code>. We 
can look at this as shifting the "before-advice" from the <i>input</i> to an 
"after advice" of the <i>output</i>, where I'm using

Also, to remember this, we can write it as:
<div class='code'><!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>          ∃!id(p)
          +---+
          |   |
          |   v
+---------ppppp--------+
| πa      |   ^     πb |  
v      ∃!p2q  |        v
a         |   |        b
^         |  ∃!q2p     ^
| π'b     v   |    π'b |
+---------qqqqq--------+
</tt></pre>
</div>
Where <code>F</code> is for <code>F</code>ree and <code>U</code> is for forgetf<code>U</code>l.
Recall that if <code>F</code> is free and <code>U</code> is forgetful, then <code>U(F(x)) = x</code>, since
adding more structure through the free functor and then stripping it away gives
us the object back. We can prove that if <code>U(F(x)) = x</code> and <code>U, F</code> are functors,
then we have a function <code>fwd: (f a -> x) -> (a -> u x)</code> as:
<div class='code'><!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>          ∃!id(p)
          +---+
          |   |
          |   v
+---------ppppp--------+
| πa      |   ^     πb |  
v      ∃!p2q  |        v
a         |   |        b
^         |  ∃!q2p     ^
| π'b     v   |    π'b |
+---------qqqqq--------+
</tt></pre>
</div>
<h4><a id=references href='#references'> § </a> References</h4>
<ul><li> <a href=https://www.youtube.com/watch?v=l1FCXUi6Vlw>Profunctor optics: the categorical approach, <code>33:00</code> onwards</a></li></ul>
<h3><a id=reversible-computation-as-groups-on-programs href='#reversible-computation-as-groups-on-programs'> § </a> <a href=#reversible-computation-as-groups-on-programs>Reversible computation as groups on programs</a></h3>
If we consider a language like <a href=https://en.wikipedia.org/wiki/Janus_(time-reversible_computing_programming_language><code>Janus</code></a>
where every program is reversible, we can then get a group structure on
programs with the identity program not computing anything at all, the inverse
performing the reverse operation. 
Alternatively, one can use the trick from quantum mechanics of using anciliary
qubits to build reversible classical gates. 
The question is, do either of these approaches allow for better-than-STOKE
exploration of the program space? Ie, can we somehow exploit the 
discrete group structure (in the case of Janus) or the Lie group structure
of the unitary group (as in the QM case) to find programs in far quicker ways?
<h3><a id=blazing-fast-math-rendering-on-the-web href='#blazing-fast-math-rendering-on-the-web'> § </a> <a href=#blazing-fast-math-rendering-on-the-web>Blazing fast math rendering on the web</a></h3>
So, I've shifted the blog to be static-site-generated using a
static-site-generator written by yours truly. The code clocks in at around a
thousand lines of C++:
<ul><li> <a href=https://github.com/bollu/bollu.github.io/tree/master/builder/builder.cpp>bollu/bollu.github.io/builder/builder.cpp</a></li></ul>
What did I gain?
<ol><li> My generator is a real compiler, so I get errors on math and markdown
  malformation.</li><li> I can write math that <i>loads</i> instantly on your browser, using no MathJax,
   KaTeX or any client side processing, <i>nor</i> the need to fetch images, which looks like this:</li></ol>
<div class='latexblock'>
h(x) \equiv 
\begin{cases} 
\int_{i=0}^\infty f(x) g(x) dx & x > 0 \\
\sum_{i=0}^\infty f(x) + g(x) & \text{otherwise}
\end{cases}
</div>
<h4><a id=why href='#why'> § </a> Why?</h4>
My blog is a <a href=https://github.com/bollu/bollu.github.io/blob/master/README.md>single 9000 line markdown file</a>,
rendered as a <i>single HTML page</i>, so I 
<i>need it to compile fast, render fast, render beautiful</i>. 
Existing tools compromise on one or the other.
<h4><a id=no-seriously-why-a-single-markdown-file href='#no-seriously-why-a-single-markdown-file'> § </a> No seriously, why a single markdown file?</h4>
I need a single file to edit, so I can rapidly jot down new ideas. This is 
the essence of why I'm able to log most of what I study: 
<i>because it's seamless</i>.
Far more importantly, it provides <b>spatio-temporal locality</b>. I add things
in chronological order to tbe blog, as I learn thing. If I need to recall
something I had studied, go to that location in the blog 
<i>based on a sense of when</i>. 
When I do get to a location I want, the scrollbar gives me a sense of 
<i>where I am</i> in the file.  this is important to me, since it hepls me reason
spatially about what i know and what I've learnt. It's someting I love about
books, and deeply miss when navigtaing the web.I'm determined to keep this
spatio-temporal locality on my little slice of the internet.
<h4><a id=why-is-this-awful href='#why-is-this-awful'> § </a> Why is this awful?</h4>
As elegant as this model is to <i>edit</i>, it's awful for browsers to render. The
file used to take on the order of minutes for all the math to finish
rendering. MathJax (and KaTeX) painfully attempt to render each
math block. As they do, the page jumps around until everything has settled.
As this is happening, your CPU throttles, your lap or hand gets warm,
and the page is stuck. Clearly not great UX.
I still want math. What do I do?  The solution is easy: Approximate the math
rendering using ASCII/UTF-8 characters!  There are tools that do this ---
<a href=http://hevea.inria.fr/><code>hevea</code></a> is one of them. Unfortunately, there is no
markdown-based-blogging-platform that uses this, so I <i>had</i> to write my own.
<h4><a id=the-cure href='#the-cure'> § </a> The cure</h4>
The solution is easy. I wrote the tool. The page you're reading it
is rendered using the tool. All the math renders in under a second because
it's nothing crazy, it's just text and tables which browsers know how to
render. No JavaScript necessary. snappy performance. Whoo!
<h4><a id=the-details-writing-my-own-markdown-to-html-transpiler href='#the-details-writing-my-own-markdown-to-html-transpiler'> § </a> The details: Writing my own Markdown to HTML transpiler.</h4>
the final transpiler clocks in at <code>1300Loc</code> of C++,
which is very small for a feature-complete markdown-to-HTML piece of code
that's blazing fast, renders math correctly, and provides error messages.
<h4><a id=quirks-fixed-features-gained href='#quirks-fixed-features-gained'> § </a> Quirks fixed, features gained.</h4>
I got quite a bit "for free" as I wrote this, fixing mild annoyances
and larger pain points around using github + markdown for publishing on
the web:
<ul><li> I really don't want tables, but I do want the ability to write vertical bars 
  <code>|</code> freely in my text. Unfortunately, github <i>insists</i> that those are tables,
   and completely wrecks rendering.</li></ul>
<ul><li> I get line numbers in code blocks now, which Github Flavoured Markdown
  did not have.</li></ul>
<ul><li> I get error messages on incorrectly closed bold/italic/code blocks, using
  heuristics that prevent them from spanning across too many lines.</li></ul>
<ul><li> I get error messages on broken latex, since all my latex passes through
  <code>hevea</code>. This is awesome, since I no longer need to refresh my browser,
  wait for mathjax to load, go make myself tea (remember that mathjax was slow?),
  and then come back to see the errors.</li></ul>
<ul><li> I can get error messages if my internal document links are broken. To be
  fair, my tool doesn't currently give me these errors, but it can (and soon
  will).</li></ul>
<ul><li> In general, I get <i>control</i>, which was something I did not have with
  rendering directly using Github, or using someone else's tool.</li></ul>
<h4><a id=choice-of-language href='#choice-of-language'> § </a> Choice of language</h4>
I choose to write this in C-style-C++, primarily because I wanted the tool
to be fast, and I'd missed writing C++ for a while. I really enjoy how
stupid-simple C style C++ turns out to be: the C++ papers over some of C's
annoyances (like formatted output for custom types), while still preserving the
KISS feeling of writing C++.
<b>Why not Rust?</b> I freely admit that rust might have been a sane choice as
well.  unfortunately, asking rust to treat UTF-8 string as a "ball of bytes" is
hard, when it's stupidly easy with C. Plus, I wanted to use arena-style-allocation
where I make <i>huge</i> allocations in one go and then don't think about memory,
something that I don't have control over in Rust. I don't have any segfaults
(yet, perhaps), thanks to UBSAN and ASAN. I find Rust to have more impedance
than C on small applications, and this was indeed small.
<h4><a id=performance href='#performance'> § </a> Performance</h4>
Everything <i>except</i> the latex to HTML is blazing fast. Unfortunately,
calling <code>hevea</code> is slow, so I implemented a caching mechanism to make using
<code>hevea</code> not-slow. <code>hevea</code> does not have an API, so I need to <code>fork</code> and
talk to its process which is understandably flow. I built a "key-value-store"
(read: serialize data into a file) with the stupidly-simple approach of writing
an append-only log into a file. <code>hevea</code> is a pure function conceptally,
since on providing the same latex input it's going to produce the same HTML
output, so it's perfectly safe to cache it:
<div class='code'><!-- Generator: GNU source-highlight 3.1.8
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>          ∃!id(p)
          +---+
          |   |
          |   v
+---------ppppp--------+
| πa      |   ^     πb |  
v      ∃!p2q  |        v
a         |   |        b
^         |  ∃!q2p     ^
| π'b     v   |    π'b |
+---------qqqqq--------+
</tt></pre>
</div>
<h4><a id=for-the-future href='#for-the-future'> § </a> For the future</h4>
I plan to rip out <code>hevea</code> and write my own <code>latex -> HTML</code> converter for
the <i>subset of LaTeX I actually use</i>. <code>hevea</code>'s strength is its downfall:
It can handle all of LaTeX, which means it's really slow. If I can concentrate
on a small subset, I don't need to play caching tricks, and I can likely
optimise the layout further for my use-cases.
I also want colored error messages, because who doesn't?
I'll probably gradually improve my static site generator over time. Once it's
at a level of polish where I'm happy with it, I'll spin it out as a separate
project.
<h4><a id=conclusions href='#conclusions'> § </a> Conclusions</h4>
Am I glad I did it? Yes, purely because my chunk of the internet aligns with
how I want it to be, and that makes me <span class='latexinline'>\epsilon</span> more happy.
I think of it as an investment into future me, since I can extend the
markdown and the transpiler in the way <i>I</i> want it to be.
<h3><a id=vc-dimension href='#vc-dimension'> § </a> <a href=#vc-dimension>VC dimension</a></h3>
Consider a ground set <span class='latexinline'>X</span>. Let the space of all possible binary classifications
be the function space <span class='latexinline'>C \equiv \{ f \mid f : X \rightarrow \pm 1 \}</span>.
Now, a hypothesis class <span class='latexinline'>H</span> is a subset of <span class='latexinline'>C</span>. For example, some model
such as "return <span class='latexinline'>+1</span> if a point is inside a region, <span class='latexinline'>-1</span> otherwise" is a subset
of the full class <span class='latexinline'>C</span>.
The VC dimension of <span class='latexinline'>H</span> measures how good <span class='latexinline'>H</span> is generating different classification.
We first need the notion of shattering to define this.
A subset <span class='latexinline'>S \subseteq X</span> of the ground set shatters a hypothesis class <span class='latexinline'>H</span>
if the function <span class='latexinline'>act_S</span> has full range, where <span class='latexinline'>act_S</span> is defined as:
<div class='latexblock'>
act_S: H \rightarrow |S|^{\{0, 1\}}
act_S(h) = (h(s_0), h(s_1), h(s_2), \dots, h(s_n))
</div>
That is, the hypothesis class <span class='latexinline'>H</span> can classify all the subsets of <span class='latexinline'>S</span>.
Now the <b>VC dimension of the hypothesis class <span class='latexinline'>H</span> of a ground set <span class='latexinline'>X</span></b> is
the size of <b>largest possible <span class='latexinline'>S \subseteq X</span></b> such that <span class='latexinline'>S</span> is shattered
by <span class='latexinline'>H</span>.
<h4><a id=correct-interpretation href='#correct-interpretation'> § </a> Correct interpretation</h4>
<ul><li> We need <i>just one set</i> <span class='latexinline'>S</span> of size <span class='latexinline'>n</span> to be shattered by <span class='latexinline'>H</span>. We get
  to pick the set <span class='latexinline'>S</span>.</li></ul>
<h4><a id=subtletly-1 href='#subtletly-1'> § </a> Subtletly 1:</h4>
<ul><li> We do not need <i>all sets</i> of size <span class='latexinline'>n</span> to be shattered by <span class='latexinline'>H</span>.</li></ul>
We <b>can</b> have the case where:
<ul><li> All sets of size 3 are shattered by H</li><li> Only one set of size 4 is shattered by H. All other sets of size 4 are not.</li><li> Only one size of size 5 is shattered by H. All other sets of size 5 are not.</li><li> No set of size 6 is shattered by H.</li></ul>
In this case, the VC dimension of <span class='latexinline'>H</span> is <b>5, not 3</b>.
<h4><a id=subtletly-2 href='#subtletly-2'> § </a> Subtletly 2:</h4>
We <b>cannot</b> have the case where:
<ul><li> All sets of size 3 are shattered by H</li><li> No set of size 4 is shattered by H</li><li> Some set of size 5 is shattered by H</li></ul>
For contradiction, let <span class='latexinline'>S</span> be the set of size <span class='latexinline'>5</span> that is shattered by <span class='latexinline'>H</span>.
Let <span class='latexinline'>T \subsetneq S</span>, <span class='latexinline'>|T| = 4</span>. Now, <span class='latexinline'>H</span> shatters <span class='latexinline'>T</span> since <span class='latexinline'>H</span> shatters <span class='latexinline'>S</span>.
Hence, Some set of size 4 has been shattered. Contradiction, since we assumed
that no set of size 4 is shattered by <span class='latexinline'>H</span>.
So, to prove that sets of size <span class='latexinline'>(\geq n)</span> cannot be shattered, it suffices
to prove that sets of size equal to <span class='latexinline'>n</span> cannot be shattered.
<h4><a id=growth-of-number-of-sets-shattered-in-s-for-s-subseteq-x-for-a-fixed-h href='#growth-of-number-of-sets-shattered-in-s-for-s-subseteq-x-for-a-fixed-h'> § </a> Growth of number of sets shattered in <span class='latexinline'>|S|</span> for <span class='latexinline'>S \subseteq X</span> for a fixed <span class='latexinline'>H</span>.</h4>
If we fix a hypothesis class <span class='latexinline'>H</span> for <span class='latexinline'>X</span>, and we want to understand how <span class='latexinline'>H</span>
varies over subsets of <span class='latexinline'>X</span>, the idea is this:
Let <span class='latexinline'>S</span> be a set that is the maximum sized set that is shattered by <span class='latexinline'>X</span>. ie,
<span class='latexinline'>|S| = Vcdim(H)</span> and <span class='latexinline'>H</span> shatters <span class='latexinline'>S</span>.
Now, the idea is this:
<ul><li> For subsets <span class='latexinline'>T \subseteq S</span>, <span class='latexinline'>|act_T(H)| = 2^{|T|}</span> -- exponential.</li><li> For subpersets <span class='latexinline'>S \subsetneq Sup</span>, <span class='latexinline'>|act_{Sup}(H) = Comb(|Sup|, |S)</span> -- polynomial.</li></ul>
We can show that this exponential/polynomial behaviour happens in general
for <span class='latexinline'>S \subseteq X</span>. 
</container></body></html>